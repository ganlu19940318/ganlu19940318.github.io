<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java反射]]></title>
    <url>%2F2018%2F09%2F23%2FJava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[1. 前言Java反射也是日常开发和阅读源码中经常遇到的, 掌握反射是非常有必要的. 2. 概述2.1 什么是反射简单来说, 反射可以帮助我们在动态运行的时候, 对于任意一个类, 可以获得其所有的方法(包括 public protected private 默认状态的), 所有的变量(包括 public protected private 默认状态的). 反射就是把Java类中的各种成分映射成一个个的Java对象.例如: 一个类有: 成员变量, 方法, 构造方法, 包等等信息, 利用反射技术可以对一个类进行解剖, 把个个组成部分映射成一个个对象.如图是类的正常加载过程: 反射的原理在于Class对象. 2.2 反射有什么用a. 获取某些类的一些变量, 调用某些类的私有方法b. 增加代码的灵活性. 很多主流框架都使用了反射技术. 3. 反射的使用假如有这样一个类 Person, 它拥有多个成员变量, country,city,name,province,height,age 等, 同时它拥有多个 构造方法, 多个方法, 这些变量, 方法的访问权限既有 public 也有 private 的. 下面我们以这个为例子, 一起看怎样使用反射获得相应的 Filed, Constructor, Method.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.HashMap;public class Person &#123; public String country; public String city; private String name; private String province; private Integer height; private Integer age; public Person() &#123; System.out.println("调用Person的无参构造方法"); &#125; private Person(String country, String city, String name) &#123; this.country = country; this.city = city; this.name = name; &#125; public Person(String country, Integer age) &#123; this.country = country; this.age = age; &#125; private String getMobile(String number) &#123; String mobile = "010-110" + "-" + number; return mobile; &#125; private void setCountry(String country) &#123; this.country=country; &#125; public void getGenericHelper(HashMap&lt;String, Integer&gt; hashMap) &#123; &#125; public Class getGenericType() &#123; try &#123; HashMap&lt;String, Integer&gt; hashMap = new HashMap&lt;String, Integer&gt;(); Method method = getClass().getDeclaredMethod("getGenericHelper",HashMap.class); Type[] genericParameterTypes = method.getGenericParameterTypes(); if (null == genericParameterTypes || genericParameterTypes.length &lt; 1) &#123; return null; &#125; ParameterizedType parameterizedType=(ParameterizedType)genericParameterTypes[0]; Type rawType = parameterizedType.getRawType(); System.out.println("----&gt; rawType=" + rawType); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); if (actualTypeArguments==genericParameterTypes || actualTypeArguments.length&lt;1) &#123; return null; &#125; for (int i = 0; i &lt; actualTypeArguments.length; i++) &#123; Type type = actualTypeArguments[i]; System.out.println("----&gt; type=" + type); &#125; &#125; catch (Exception e) &#123; &#125; return null; &#125; @Override public String toString() &#123; return "Person&#123;" + "country='" + country + '\'' + ", city='" + city + '\'' + ", name='" + name + '\'' + ", province='" + province + '\'' + ", height=" + height + '&#125;'; &#125;&#125; 3.1 获得构造方法几个重要的方法| 方法 | 描述 || ———————————————————————– | —————————————————————————— || public Constructor getConstructor(Class… parameterTypes) | 获得指定的构造方法，注意只能获得 public 权限的构造方法，其他访问权限的获取不到 || public Constructor getDeclaredConstructor(Class… parameterTypes) | 获得指定的构造方法，注意可以获取到任何访问权限的构造方法。 || public Constructor[] getConstructors() throws SecurityException | 获得所有 public 访问权限的构造方法 || public Constructor[] getDeclaredConstructors() throws SecurityException | 获得所有的构造方法，包括（public, private,protected,默认权限的） | 3.1.1 获得所有的构造方法123456789101112131415161718192021222324import java.lang.reflect.Constructor;public class Main&#123; public static void main(String[] args)&#123; String className = Person.class.getName(); printConstructor(className); &#125; public static void printConstructor(String className) &#123; try &#123; Class aClass = Class.forName(className); Constructor[] constructors = aClass.getConstructors(); print(constructors); System.out.println("====================="); Constructor[] declaredConstructors = aClass.getDeclaredConstructors(); print(declaredConstructors); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static void print(Constructor[] constructors)&#123; for(Constructor constructor : constructors)&#123; System.out.println(constructor.toString()); &#125; &#125;&#125; 运行结果:123456public Person(java.lang.String,java.lang.Integer)public Person()=====================public Person(java.lang.String,java.lang.Integer)private Person(java.lang.String,java.lang.String,java.lang.String)public Person() 3.1.2 获得指定的构造方法123456789101112131415161718192021222324252627282930313233import java.lang.reflect.Constructor;public class Main&#123; public static void main(String[] args)&#123; String className = Person.class.getName(); Constructor constructor = getConstructor(className, String.class, Integer.class); try &#123; Object meinv = constructor.newInstance("CHINA", 24); Person person = (Person) meinv; System.out.println("testConstructor: = " + person.toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Constructor getConstructor(String className, Class&lt;?&gt;... clzs) &#123; try &#123; Class&lt;?&gt; aClass = Class.forName(className); Constructor&lt;?&gt; declaredConstructor = aClass.getDeclaredConstructor(clzs); print(declaredConstructor); // if Constructor is not public,you should call this declaredConstructor.setAccessible(true); return declaredConstructor; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static void print(Constructor constructor)&#123; System.out.println(constructor.toString()); &#125;&#125; 运行结果:12public Person(java.lang.String,java.lang.Integer)testConstructor: =Person&#123;country='CHINA', city='null', name='null', province='null', height=null&#125; 这说明我们成功通过反射调用 Person 带两个参数的沟改造方法. 3.1.3 注意事项如果该方法, 或者该变量不是 public 访问权限的, 我们应该调用相应的 setAccessible(true) 方法, 才能访问得到12//if Constructor is not public,you should call thisdeclaredConstructor.setAccessible(true); 3.2 获得Filed变量3.2.1 获得所有的Filed变量123456789101112131415161718192021222324import java.lang.reflect.Field;public class Main&#123; public static void main(String[] args)&#123; String className = Person.class.getName(); printFiled(className); &#125; public static void printFiled(String className) &#123; try &#123; Class aClass = Class.forName(className); Field[] fields = aClass.getFields(); print(fields); System.out.println("============================"); Field[] declaredFields = aClass.getDeclaredFields(); print(declaredFields); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static void print(Field[] fields)&#123; for(Field field : fields)&#123; System.out.println(field.toString()); &#125; &#125;&#125; 运行结果:123456789public java.lang.String Person.countrypublic java.lang.String Person.city============================public java.lang.String Person.countrypublic java.lang.String Person.cityprivate java.lang.String Person.nameprivate java.lang.String Person.provinceprivate java.lang.Integer Person.heightprivate java.lang.Integer Person.age 3.2.2 获得指定的Filed变量现在假如我们要获得 Person 中的私有变量 age , 我们可以通过以下的代码获得.1234567891011121314151617import java.lang.reflect.Field;public class Main&#123; public static void main(String[] args) throws Exception&#123; String className = Person.class.getName(); Person person = new Person("CHINA", 12); Field field = getFiled(className, "age"); Integer integer = (Integer) field.get(person); System.out.println("integer = " + integer); &#125; public static Field getFiled(String className, String filedName) throws Exception&#123; Class aClass = Class.forName(className); Field declaredField = aClass.getDeclaredField(filedName); //if not public,you should call this declaredField.setAccessible(true); return declaredField; &#125;&#125; 运行结果:1integer = 12 3.3 执行Method主要有以下几个方法,1234public Method[] getDeclaredMethods()public Method[] getMethods() throws SecurityExceptionpublic Method getDeclaredMethod()public Method getMethod(String name, Class&lt;?&gt; ... parameterTypes) 3.3.1 获取所有的Method123456789101112131415161718192021import java.lang.reflect.Method;public class Main&#123; public static void main(String[] args)&#123; String className = Person.class.getName(); printMethods(className); &#125; public static void printMethods(String className) &#123; try &#123; Class&lt;?&gt; aClass = Class.forName(className); Method[] declaredMethods = aClass.getDeclaredMethods(); print(declaredMethods); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static void print(Method[] declaredMethods)&#123; for(Method method : declaredMethods)&#123; System.out.println(method.toString()); &#125; &#125;&#125; 运行结果:12345public java.lang.String Person.toString()public java.lang.Class Person.getGenericType()private void Person.setCountry(java.lang.String)public void Person.getGenericHelper(java.util.HashMap)private java.lang.String Person.getMobile(java.lang.String) 3.3.2 获取指定的Method12345678910111213141516171819import java.lang.reflect.Method;public class Main&#123; public static void main(String[] args) throws Exception&#123; String className = Person.class.getName(); Person person=new Person(); Method method = getMethod(className, "setCountry", String.class); // 执行方法，结果保存在 person 中 Object o = method.invoke(person, "CHINA"); // 拿到我们传递进取的参数 country 的值 China String country=person.country; System.out.println("country : " + country); &#125; public static Method getMethod(String className, String methodName, Class&lt;?&gt;... clzs) throws Exception &#123; Class&lt;?&gt; aClass = Class.forName(className); Method declaredMethod = aClass.getDeclaredMethod(methodName, clzs); declaredMethod.setAccessible(true); return declaredMethod; &#125;&#125; 运行结果:1country : CHINA 3.4 操作数组123456789101112131415161718192021222324import java.lang.reflect.Array;public class Main&#123; public static void main(String[] args) &#123; testArrayClass(); &#125; /** * 利用反射操作数组 * 1 利用反射修改数组中的元素 * 2 利用反射获取数组中的每个元素 */ public static void testArrayClass() &#123; String[] strArray = new String[]&#123;"5","7","暑期","美女","女生","女神"&#125;; Array.set(strArray,0,"帅哥"); Class clazz = strArray.getClass(); if (clazz.isArray()) &#123; int length = Array.getLength(strArray); for (int i = 0; i &lt; length; i++) &#123; Object object = Array.get(strArray, i); String className=object.getClass().getName(); System.out.println("----&gt; object=" + object+",className="+className); &#125; &#125; &#125;&#125; 运行结果:123456----&gt; object=帅哥,className=java.lang.String----&gt; object=7,className=java.lang.String----&gt; object=暑期,className=java.lang.String----&gt; object=美女,className=java.lang.String----&gt; object=女生,className=java.lang.String----&gt; object=女神,className=java.lang.String 从结果可以说明, 我们成功通过 Array.set(strArray,0,”帅哥”) 改变数组的值. 3.5 获得泛型类型12public static void getGenericHelper(HashMap&lt;String, Person&gt; map) &#123;&#125; 现在假设我们有这样一个方法, 那我们要怎样获得 HashMap 里面的 String, Person 的类型呢?123456789101112131415161718192021222324252627282930import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.HashMap;public class Main&#123; public static void main(String[] args) throws Exception&#123; getGenericType(); &#125; public static void getGenericType() throws Exception&#123; Method method =TestHelper.class.getDeclaredMethod("getGenericHelper", HashMap.class); Type[] genericParameterTypes = method.getGenericParameterTypes(); // 检验是否为空 if (null == genericParameterTypes || genericParameterTypes.length &lt; 1) &#123; return ; &#125; // 取 getGenericHelper 方法的第一个参数 ParameterizedType parameterizedType=(ParameterizedType)genericParameterTypes[0]; Type rawType = parameterizedType.getRawType(); System.out.println("----&gt; rawType=" + rawType); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); if (actualTypeArguments==genericParameterTypes || actualTypeArguments.length&lt;1) &#123; return ; &#125; // 打印出每一个类型 for (int i = 0; i &lt; actualTypeArguments.length; i++) &#123; Type type = actualTypeArguments[i]; System.out.println("----&gt; type=" + type); &#125; &#125;&#125; 运行结果:123----&gt; rawType=class java.util.HashMap----&gt; type=class java.lang.String----&gt; type=class Person 3.6 怎样获得Metho, Field, Constructor的访问权限(public, private, ptotected等)其实很简单, 我们阅读文档可以发现他们都有 getModifiers() 方法, 该方法放回 int 数字, 我们在利用 Modifier.toString() 就可以得到他们的访问权限.12int modifiers = method.getModifiers();Modifier.toString(modifiers); 4. 参考链接Java基础之—反射（非常重要）Java 反射机制详解]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java泛型]]></title>
    <url>%2F2018%2F09%2F23%2FJava%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1. 前言Java源码中有大量泛型的使用, 但是, 日常开发中, 对泛型特性的了解却仅限于表面的浅浅一层, 所以这里记录泛型相关的一些知识. 2. 泛型概述2.1 什么是泛型泛型, 即”参数化类型”. 一提到参数, 最熟悉的就是定义方法时有形参, 然后调用此方法时传递实参. 那么参数化类型怎么理解呢? 顾名思义, 就是将类型由原来的具体的类型参数化, 类似于方法中的变量参数, 此时类型也定义成参数形式(可以称之为类型形参), 然后在使用/调用时传入具体的类型(类型实参). 泛型的本质是为了参数化类型(在不创建新的类型的情况下, 通过泛型指定的不同类型来控制形参具体限制的类型). 也就是说在泛型使用过程中, 操作的数据类型被指定为一个参数, 这种参数类型可以用在类, 接口和方法中, 分别被称为泛型类, 泛型接口, 泛型方法. 2.2 为什么要有泛型代码示例:1234567891011public class Main &#123; public static void main(String[] args)&#123; List arrayList = new ArrayList(); arrayList.add("aaaa"); arrayList.add(100); for(int i = 0; i&lt; arrayList.size();i++)&#123; String item = (String)arrayList.get(i); System.out.println("泛型测试, item = " + item); &#125; &#125;&#125; 运行结果:123泛型测试, item = aaaaException in thread "main" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String at Main.main(Main.java:11) ArrayList可以存放任意类型, 例子中添加了一个String类型, 添加了一个Integer类型, 在使用时都以String的方式使用, 因此程序崩溃了. 为了解决类似这样的问题(在编译阶段就可以解决), 泛型应运而生.我们将第一行声明初始化list的代码更改一下, 编译器会在编译阶段就能够帮我们发现类似这样的问题.123List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();...//arrayList.add(100); 在编译阶段，编译器就会报错 2.3 特性泛型只在编译阶段有效. 看下面的代码 12345678910public class Main &#123; public static void main(String[] args)&#123; List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;(); Class classStringArrayList = stringArrayList.getClass(); Class classIntegerArrayList = integerArrayList.getClass(); System.out.println(classStringArrayList); System.out.println(classIntegerArrayList); &#125;&#125; 结果:12class java.util.ArrayListclass java.util.ArrayList 通过上面的例子可以证明, 在编译之后程序会采取去泛型化的措施. 也就是说Java中的泛型, 只在编译阶段有效. 在编译过程中, 正确检验泛型结果后, 会将泛型的相关信息擦除, 并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法. 也就是说, 泛型信息不会进入到运行时阶段. 3. 泛型的使用泛型有三种使用方式, 分别为: 泛型类, 泛型接口, 泛型方法 3.1 泛型类泛型类型用于类的定义中, 被称为泛型类. 通过泛型可以完成对一组类的操作对外开放相同的接口. 最典型的就是各种容器类, 如: List, Set, Map.泛型类的最基本写法(这么看可能会有点晕, 会在下面的例子中详解):12345class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123; private 泛型标识 /*（成员变量类型）*/ var; ..... &#125;&#125; 一个最普通的泛型类:123456789101112//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123; //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; &#125; public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; &#125;&#125; 1234567891011public class Main &#123; public static void main(String[] args)&#123; //泛型的类型参数只能是类类型（包括自定义类），不能是简单类型 //传入的实参类型需与泛型的类型参数类型相同，即为Integer. Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456); //传入的实参类型需与泛型的类型参数类型相同，即为String. Generic&lt;String&gt; genericString = new Generic&lt;String&gt;("key_vlaue"); System.out.println("泛型测试, key is " + genericInteger.getKey()); System.out.println("泛型测试, key is " + genericString.getKey()); &#125;&#125; 运行结果:12泛型测试, key is 123456泛型测试, key is key_vlaue 定义的泛型类, 就一定要传入泛型类型实参么? 并不是这样, 在使用泛型的时候如果传入泛型实参, 则会根据传入的泛型实参做相应的限制, 此时泛型才会起到本应起到的限制作用. 如果不传入泛型类型实参的话, 在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型.123456789101112public class Main &#123; public static void main(String[] args)&#123; Generic generic = new Generic("111111"); Generic generic1 = new Generic(4444); Generic generic2 = new Generic(55.55); Generic generic3 = new Generic(false); System.out.println("泛型测试, key is " + generic.getKey()); System.out.println("泛型测试, key is " + generic1.getKey()); System.out.println("泛型测试, key is " + generic2.getKey()); System.out.println("泛型测试, key is " + generic3.getKey()); &#125;&#125; 运行结果:1234泛型测试, key is 111111泛型测试, key is 4444泛型测试, key is 55.55泛型测试, key is false 3.2 泛型接口泛型接口与泛型类的定义及使用基本相同. 泛型接口常被用在各种类的生产器中, 可以看一个例子:1234//定义一个泛型接口public interface Generator&lt;T&gt; &#123; public T next();&#125; 当实现泛型接口的类, 未传入泛型实参时:1234567891011/** * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错："Unknown class" */class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; @Override public T next() &#123; return null; &#125;&#125; 当实现泛型接口的类, 传入泛型实参时:1234567891011121314151617/** * 传入泛型实参时： * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt; * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。 * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。 */public class FruitGenerator implements Generator&lt;String&gt; &#123; private String[] fruits = new String[]&#123;"Apple", "Banana", "Pear"&#125;; @Override public String next() &#123; Random rand = new Random(); return fruits[rand.nextInt(3)]; &#125;&#125; 3.3 泛型通配符我们知道Integer是Number的一个子类, 同时在特性章节中我们也验证过Generic与Generic实际上是相同的一种类型. 那么问题来了, 在使用Generic作为形参的方法中, 能否使用Generic的实例传入呢? 在逻辑上类似于Generic和Generic是否可以看成具有父子关系的泛型类型呢?为了弄清楚这个问题, 我们使用Generic这个泛型类继续看下面的例子:12345678910111213public class Main &#123; public static void main(String[] args)&#123; Generic&lt;Integer&gt; gInteger = new Generic&lt;Integer&gt;(123); Generic&lt;Number&gt; gNumber = new Generic&lt;Number&gt;(456); showKeyValue(gNumber); // 下面showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt; // cannot be applied to Generic&lt;java.lang.Number&gt; // showKeyValue(gInteger); &#125; public static void showKeyValue(Generic&lt;Number&gt; obj)&#123; System.out.println("泛型测试, key value is " + obj.getKey()); &#125;&#125; 123456789101112//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123; //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; &#125; public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; &#125;&#125; 通过提示信息我们可以看到Generic不能被看作为`Generic的子类. 由此可以看出:同一种泛型可以对应多个版本(因为参数类型是不确定的), 不同版本的泛型类实例是不兼容的.回到上面的例子, 如何解决上面的问题? 总不能为了定义一个新的方法来处理Generic类型的类, 这显然与java中的多台理念相违背. 因此我们需要一个在逻辑上可以表示同时是Generic和Generic父类的引用类型. 由此类型通配符应运而生.我们可以将上面的方法改一下:123public void showKeyValue(Generic&lt;?&gt; obj)&#123; System.out.println("泛型测试, key value is " + obj.getKey());&#125; 类型通配符一般是使用? 代替具体的类型实参, 注意了, 此处 ? 是类型实参, 而不是类型形参. 再直白点的意思就是, 此处的?和Number, String, Integer一样都是一种实际的类型, 可以把?看成所有类型的父类. 是一种真实的类型.可以解决当具体类型不确定的时候, 这个通配符就是?; 当操作类型时, 不需要使用类型的具体功能时, 只使用Object类中的功能. 那么可以用? 通配符来表未知类型. 3.4 泛型方法泛型类, 是在实例化类的时候指明泛型的具体类型, 泛型方法, 是在调用方法的时候指明泛型的具体类型.123456789101112131415/** * 泛型方法的基本介绍 * @param tClass 传入的泛型实参 * @return T 返回值为T类型 * 说明： * 1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。 * 2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 * 3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。 * 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 */public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException , IllegalAccessException&#123; T instance = tClass.newInstance(); return instance;&#125; 1Object obj = genericMethod(Class.forName(&quot;Test&quot;)); 3.4.1 泛型方法的基本用法光看上面的例子有的同学可能依然会非常迷糊, 我们再通过一个例子, 把我泛型方法再总结一下.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class GenericTest &#123; //这个类是个泛型类，在上面已经介绍过 public class Generic&lt;T&gt;&#123; private T key; public Generic(T key) &#123; this.key = key; &#125; //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。 //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。 //所以在这个方法中才可以继续使用 T 这个泛型。 public T getKey()&#123; return key; &#125; /** * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E" * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。 public E setKey(E key)&#123; this.key = key &#125; */ &#125; /** * 这才是一个真正的泛型方法。 * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T * 这个T可以出现在这个泛型方法的任意位置. * 泛型的数量也可以为任意多个 * 如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123; * ... * &#125; */ public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123; System.out.println("container key :" + container.getKey()); //当然这个例子举的不太合适，只是为了说明泛型方法的特性。 T test = container.getKey(); return test; &#125; //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。 public void showKeyValue1(Generic&lt;Number&gt; obj)&#123; System.out.println("泛型测试, key value is " + obj.getKey()); &#125; //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符? //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类 public void showKeyValue2(Generic&lt;?&gt; obj)&#123; System.out.println("泛型测试, key value is " + obj.getKey()); &#125; /** * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' " * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。 * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。 public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123; ... &#125; */ /** * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' " * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。 * 所以这也不是一个正确的泛型方法声明。 public void showkey(T genericObj)&#123; &#125; */ public static void main(String[] args) &#123; &#125;&#125; 3.4.2 类中的泛型方法当然这并不是泛型方法的全部, 泛型方法可以出现杂任何地方和任何场景中使用. 但是有一种情况是非常特殊的, 当泛型方法出现在泛型类中时, 我们再通过一个例子看一下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class GenericFruit &#123; class Fruit&#123; @Override public String toString() &#123; return "fruit"; &#125; &#125; class Apple extends Fruit&#123; @Override public String toString() &#123; return "apple"; &#125; &#125; class Person&#123; @Override public String toString() &#123; return "Person"; &#125; &#125; class GenerateTest&lt;T&gt;&#123; public void show_1(T t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。 //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。 public &lt;E&gt; void show_3(E t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。 public &lt;T&gt; void show_2(T t)&#123; System.out.println(t.toString()); &#125; &#125; public void main(String[] args) &#123; Apple apple = new Apple(); Person person = new Person(); GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;(); //apple是Fruit的子类，所以这里可以 generateTest.show_1(apple); //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person //generateTest.show_1(person); //使用这两个方法都可以成功 generateTest.show_2(apple); generateTest.show_2(person); //使用这两个方法也都可以成功 generateTest.show_3(apple); generateTest.show_3(person); &#125;&#125; 3.4.3 泛型方法与可变参数再看一个泛型方法和可变参数的例子:12345678910public class Main&#123; public static void main(String[] args)&#123; printMsg("111",222,"aaaa","2323.4",55.55); &#125; public static &lt;T&gt; void printMsg( T... args)&#123; for(T t : args)&#123; System.out.println("泛型测试, t is " + t); &#125; &#125;&#125; 3.4.4 静态方法与泛型静态方法有一种情况需要注意一下, 那就是在类中的静态方法使用泛型: 静态方法无法访问类上定义的泛型; 如果静态方法操作的引用数据类型不确定的时候, 必须要将泛型定义在方法上.即: 如果静态方法要使用泛型的话, 必须将静态方法也定义成泛型方法.12345678910111213public class StaticGenerator&lt;T&gt; &#123; .... .... /** * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法） * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。 * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息： "StaticGenerator cannot be refrenced from static context" */ public static &lt;T&gt; void show(T t)&#123; &#125;&#125; 3.4.5 泛型方法总结泛型方法能使方法独立于类而产生变化, 以下是一个基本的指导原则: 无论何时, 如果你能做到, 你就该尽量使用泛型方法. 也就是说, 如果使用泛型方法将整个类泛型化, 那么就应该使用泛型方法. 另外对于一个static的方法而言, 无法访问泛型类型的参数. 所以如果static方法要使用泛型能力, 就必须使其成为泛型方法. 3.5 泛型上下边界在使用泛型的时候, 我们还可以为传入的泛型类型实参进行上下边界的限制, 如: 类型实参只准传入某种类型的父类或某种类型的子类.为泛型添加上边界, 即传入的类型实参必须是指定类型的子类型.123456789101112131415161718public class Main&#123; public static void main(String[] args)&#123; Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;("11111"); Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222); Generic&lt;Float&gt; generic3 = new Generic&lt;Float&gt;(2.4f); Generic&lt;Double&gt; generic4 = new Generic&lt;Double&gt;(2.56); //这一行代码编译器会提示错误，因为String类型并不是Number类型的子类 //showKeyValue1(generic1); showKeyValue1(generic2); showKeyValue1(generic3); showKeyValue1(generic4); &#125; public static void showKeyValue1(Generic&lt;? extends Number&gt; obj)&#123; System.out.println("泛型测试, key value is " + obj.getKey()); &#125;&#125; 如果我们把泛型类的定义也改一下:123456789public class Generic&lt;T extends Number&gt;&#123; private T key; public Generic(T key) &#123; this.key = key; &#125; public T getKey()&#123; return key; &#125;&#125; 12//这一行代码也会报错，因为String不是Number的子类Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;("11111"); 再来一个泛型方法的例子:1234567//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错："Unexpected bound"public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container)&#123; System.out.println("container key :" + container.getKey()); T test = container.getKey(); return test;&#125; 通过上面的两个例子可以看出: 泛型的上下边界添加, 必须与泛型的声明在一起. 3.6 泛型数组在Java中 “是不能创建一个确切的泛型类型的数组” 的.也就是说下面的这个例子是不可以的:1List&lt;String&gt;[] ls = new ArrayList&lt;String&gt;[10];而使用通配符创建泛型数组是可以的, 如下面这个例子:1List&lt;?&gt;[] ls = new ArrayList&lt;?&gt;[10];这样也是可以的:1List&lt;String&gt;[] ls = new ArrayList[10];下面使用Sun的一篇文档的一个例子来说明这个问题:1234567List&lt;String&gt;[] lsa = new List&lt;String&gt;[10]; // Not really allowed. Object o = lsa; Object[] oa = (Object[]) o; List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;(); li.add(new Integer(3)); oa[1] = li; // Unsound, but passes run time store check String s = lsa[1].get(0); // Run-time error: ClassCastException. * 这种情况下, 由于JVM泛型的擦除机制, 在运行时JVM是不知道泛型信息的, 所以可以给oa[1]赋上一个ArrayList而不会出现异常, 但是在取出数据的时候却要做一次类型转换, 所以就会出现ClassCastException, 如果可以进行泛型数组的声明, 上面说的这种情况在编译期将不会出现任何的警告和错误, 只有在运行时才会出错.这个部分写不下去了, 记住一点就好, 不要使用泛型数组!!! 4. 参考链接java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java序列化]]></title>
    <url>%2F2018%2F09%2F23%2FJava%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1. 前言阅读源码和日常开发, 序列化也是基础中的基础, 这篇文章主要是记录序列化相关的知识点. 2. 基本概念2.1 什么是序列化和反序列化 Java序列化是指把Java对象转换为字节序列的过程, 而Java反序列化是指把字节序列恢复为Java对象的过程; 序列化: 对象序列化的最主要的用处就是在传递和保存对象的时候, 保证对象的完整性和可传递性. 序列化是把对象转换成有序字节流, 以便在网络上传输或者保存在本地文件中. 序列化后的字节流保存了Java对象的状态以及相关的描述信息. 序列化机制的核心作用就是对象状态的保存与重建. 反序列化: 客户端从文件中或网络上获得序列化后的对象字节流后, 根据字节流中所保存的对象状态及描述信息, 通过反序列化重建对象. 本质上讲, 序列化就是把实体对象状态按照一定的格式写入到有序字节流, 反序列化就是从有序字节流重建对象, 恢复对象状态. 2.2 为什么需要序列化与反序列化我们知道, 当两个进程进行远程通信时, 可以相互发送各种类型的数据, 包括文本, 图片, 音频, 视频等, 而这些数据都会以二进制序列的形式在网络上传送.那么当两个Java进程进行通信时, 能否实现进程间的对象传送呢? 答案是可以的! 如何做到? 这就需要Java序列化与反序列化了!换句话说, 一方面, 发送方需要把这个Java对象转换为字节序列, 然后在网络上传送; 另一方面, 接收方需要从字节序列中恢复出Java对象.当我们明晰了为什么需要Java序列化和反序列化后, 我们很自然地会想Java序列化的好处. 其好处一是实现了数据的持久化, 通过序列化可以把数据永久地保存到硬盘上(通常存放在文件里), 二是, 利用序列化实现远程通信, 即在网络上传送对象的字节序列.总的来说可以归结为以下几点: 永久性保存对象, 保存对象的字节序列到本地文件或者数据库中; 通过序列化以字节流的形式使对象在网络中进行传递和接收; 通过序列化在进程间传递对象; 2.3 序列化算法一般会按步骤做如下事情 将对象实例相关的类元数据输出. 递归地输出类的超类描述直到不再有超类. 类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值. 从上至下递归输出实例的数据. 2.4 Java如何实现序列化和反序列化2.4.1 JDK类库中序列化和反序列化APIjava.io.ObjectOutputStream: 表示对象输出流;它的writeObject(Object obj)方法可以对参数指定的obj对象进行序列化, 把得到的字节序列写到一个目标输出流中;java.io.ObjectInputStream: 表示对象输入流;它的readObject()方法源输入流中读取字节序列, 再把它们反序列化成为一个对象, 并将其返回; 2.4.2 实现序列化的要求只有实现了Serializable或Externalizable接口的类的对象才能被序列化, 否则抛出异常! 2.4.3 实现Java对象序列化与反序列化的方法假定一个User类, 它的对象需要序列化, 可以有如下三种方法: 若User类仅仅实现了Serializable接口, 则可以按照以下方式进行序列化和反序列化:ObjectOutputStream采用默认的序列化方式, 对User对象的非transient的实例变量进行序列化.ObjcetInputStream采用默认的反序列化方式, 对User对象的非transient的实例变量进行反序列化. 若User类仅仅实现了Serializable接口, 并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out), 则采用以下方式进行序列化与反序列化:ObjectOutputStream调用User对象的writeObject(ObjectOutputStream out)的方法进行序列化.ObjectInputStream会调用User对象的readObject(ObjectInputStream in)的方法进行反序列化. 若User类实现了Externalnalizable接口, 且User类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法, 则按照以下方式进行序列化与反序列化:ObjectOutputStream调用User对象的writeExternal(ObjectOutput out))的方法进行序列化.ObjectInputStream会调用User对象的readExternal(ObjectInput in)的方法进行反序列化. 2.5 JDK类库中序列化和反序列化的步骤序列化步骤:1234// 步骤一: 创建一个对象输出流, 它可以包装一个其它类型的目标输出流, 如文件输出流:ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("D:\\object.out"));// 步骤二: 通过对象输出流的writeObject()方法写对象:oos.writeObject(new User("xuliugen", "123456", "male")); 反序列化步骤:1234// 步骤一: 创建一个对象输入流, 它可以包装一个其它类型输入流，如文件输入流：ObjectInputStream ois= new ObjectInputStream(new FileInputStream("object.out"));// 步骤二: 通过对象输出流的readObject()方法读取对象：User user = (User) ois.readObject(); 2.6 示例1234567891011121314151617181920212223242526272829303132333435363738import java.io.*;public class Main &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //序列化 FileOutputStream fos = new FileOutputStream("object.out"); ObjectOutputStream oos = new ObjectOutputStream(fos); User user1 = new User("xuliugen", "123456", "male"); oos.writeObject(user1); oos.flush(); oos.close(); //反序列化 FileInputStream fis = new FileInputStream("object.out"); ObjectInputStream ois = new ObjectInputStream(fis); User user2 = (User) ois.readObject(); System.out.println(user2.getUserName()+ " " + user2.getPassword() + " " + user2.getSex()); //反序列化的输出结果为：xuliugen 123456 male &#125;&#125;class User implements Serializable &#123; private String userName; private String password; private String sex; public User(String userName, String password, String sex) &#123; this.userName = userName; this.password = password; this.sex = sex; &#125; public String getUserName() &#123; return userName; &#125; public String getPassword() &#123; return password; &#125; public String getSex() &#123; return sex; &#125;&#125; 序列化图示反序列化图示 3. 注意事项 序列化时, 只对对象的状态进行保存, 而不管对象的方法; 当一个父类实现序列化, 子类自动实现序列化, 不需要显式实现Serializable接口; 当一个对象的实例变量引用其他对象, 序列化该对象时也把引用对象进行序列化; 并非所有的对象都可以序列化, 至于为什么不可以, 有很多原因了, 比如:a. 安全方面的原因, 比如一个对象拥有private, public等field, 对于一个要传输的对象, 比如写到文件, 或者进行RMI传输等等, 在序列化进行传输的过程中, 这个对象的private等域是不受保护的;b. 资源分配方面的原因, 比如socket, thread类, 如果可以序列化, 进行传输或者保存, 也无法对他们进行重新的资源分配, 而且, 也是没有必要这样实现; 声明为static和transient类型的成员数据不能被序列化. 因为static代表类的状态, transient代表对象的临时数据. 序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联, 该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类. 为它赋予明确的值. 显式地定义serialVersionUID有两种用途:a. 在某些场合, 希望类的不同版本对序列化兼容, 因此需要确保类的不同版本具有相同的serialVersionUID;b. 在某些场合, 不希望类的不同版本对序列化兼容, 因此需要确保类的不同版本具有不同的serialVersionUID. Java有很多基础类已经实现了serializable接口, 比如String,Vector等.但是也有一些没有实现serializable接口的; 如果一个对象的成员变量是一个对象, 那么这个对象的数据成员也会被保存, 这是能用序列化解决深拷贝的重要原因. 4. 参考链接序列化和反序列化的底层实现原理是什么？深入理解JAVA序列化]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java关键字final]]></title>
    <url>%2F2018%2F09%2F23%2FJava%E5%85%B3%E9%94%AE%E5%AD%97final%2F</url>
    <content type="text"><![CDATA[1. 前言阅读Java源码或者日常后台开发中, 会不可避免的与final打交道, 那么final关键字究竟有哪些特性?这篇文章主要介绍final关键字及其相关知识点. 2. 基本用法在Java中, final可以用来修饰类,方法和变量(包括成员变量和局部变量). 我们先来简单介绍一下final关键字的这几个用法. 2.1 final修饰类常见的一个例子就是String类. 当用final修饰一个类时, 表明这个类不能被继承, 并且final类中的所有成员方法都会被隐式地指定为final方法, 但成员变量不会变.一般来说, 我们还是尽量不要将类设计为final类, 除非我们出于某些因素的考虑必须这么做. 比如不希望类被继承, 也就是说不希望类被修改语义. 如果我们继承String类, 那么就可以定义一个可被修改的String类, 这对于String类的使用者来说近乎是一种灾难. 2.2 final修饰方法使用final修饰方法有两个原因:一是把方法锁定, 以防任何继承类修改它的含义;二是效率. 在早期的Java实现版本中, 会将final方法转为内嵌调用. 但是如果方法过于庞大, 可能看不到内嵌调用带来的任何性能提升. 在最近的Java版本中, 不需要使用final方法进行这些优化了.同final类相似, 只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final. 另外,类 的private方法会隐式地被指定为final方法, 其语义要求private方法不能被重新定义. 2.3 final修饰变量final用得最多的地方就是修饰变量. 对于一个final变量, 如果是基本数据类型的变量, 则其数值一旦在初始化之后便不能更改;如果是引用类型的变量, 则在对其初始化之后便不能再让其指向另一个对象, 但是它指向的对象的内容是可变的.由于final变量初始化之后无法修改, 针对这个特性, Java编译器对此进行了优化. 当final变量是基本数据类型以及String类型时, 如果在编译期间能知道它的确切值, 则编译器会把它当做编译期常量使用. 这个优化通常对于程序逻辑没有太多影响, 但如果用==比较的时候, 可能会出乎意料. 3. 总结综上所述, final在修饰类和方法时, 代表不能再修改其定义, 而在修饰变量时, 则类似C++中的const关键字, 用于表示常量. 一个好的编程习惯是我们应该尽量将变量声明为final的, 除非变量必须是可变的. 例如当你在方法中不需要改变作为参数的变量时, 可以使用final进行声明, 这样可以防止你无意的修改, 尤其是当你的方法很长很复杂的时候. 当然是否用final修饰参数, 都不会影响方法之外的变量. 4. 参考链接聊聊Java的final关键字]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java字符串处理]]></title>
    <url>%2F2018%2F09%2F23%2FJava%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 前言对字符串的操作是后台开发中非常常见的, 对字符串相关的类有深刻的认识有助于写出高质量的代码. 这篇文章主要是介绍String, StringBuffer, StringBuilder这三个字符串相关的类. 2. 基本认识2.1 String1234567891011121314/** Strings are constant; their values cannot be changed after they * are created. String buffers support mutable strings. * Because String objects are immutable they can be shared. * 字符串是不变的，他们的值在创造后不能改变。 * 字符串缓冲区支持可变字符串，因为字符串对象是不可变的，所以它们可以共享。 * * @see StringBuffer * @see StringBuilder * @see Charset * @since 1.0 */public final class String implements Serializable, Comparable&lt;String&gt;, CharSequence &#123; private static final long serialVersionUID = -6849794470754667710L; private static final char REPLACEMENT_CHAR = (char) 0xfffd; 这句话总结归纳了String的两个最重要的特点:String是值不可变的常量, 是线程安全的(can be shared).String类使用了final修饰符, String类是不可继承的. 2.2 StringBufferStringBuffer字符串变量(线程安全)是一个容器, 最终会通过toString方法变成字符串;1234567891011121314151617181920public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, Appendable, CharSequence&#123; /** * Constructs a string buffer with no characters in it and an * initial capacity of 16 characters. */ public StringBuffer() &#123; super(16); &#125; public synchronized StringBuffer append(int i) &#123; super.append(i); return this; &#125; public synchronized StringBuffer delete(int start, int end) &#123; super.delete(start, end); return this; &#125;&#125; 2.3 StringBuilderStringBuilder 字符串变量(非线程安全).12345678910111213public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, Appendable, CharSequence &#123; public StringBuilder() &#123; super(16); &#125; public StringBuilder append(String str) &#123; super.append(str); return this; &#125; public StringBuilder delete(int start, int end) &#123; super.delete(start, end); return this; &#125;&#125; 3. 源码理解3.1 String 与 StringBuffer/StringBuilder 的区别String和StringBuffer/StringBuilder底层都是一个char数组, 但是String的char数组是final的;StringBuffer/StringBuilder的char数组不是final的.(1)String在修改时不会改变对象自身, 在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象, 然后将指针指向新的 String 对象, 所以经常改变内容的字符串最好不要用 String.1234567public class Main &#123; public static void main(String[] args) &#123; String str = "abc"; String str2 = str + ""; System.out.println(str == str2); &#125;&#125; 结果:1false (2)StringBuffer/StringBuilder在修改时会改变对象自身, 每次结果都会对StringBuffer/StringBuilder对象本身进行操作, 而不是生成新的对象, 再改变对象引用. 所以在一般情况下我们推荐使用StringBuffer/StringBuilder, 特别是字符串对象经常改变的情况下.StringBuffer/StringBuilder上的主要操作是 append 和 insert 方法.1234567public class Main &#123; public static void main(String[] args) &#123; StringBuffer stringBuffer = new StringBuffer("abc"); StringBuffer stringBuffer2 = stringBuffer.append("a"); System.out.println(stringBuffer == stringBuffer2); &#125;&#125; 结果:1true 3.2 StringBuffer 与 StringBuilder 的区别StringBuffer: 线程安全的, 通过synchronized实现;StringBuilder: 线程非安全的. 4. 总结 如果要操作少量的数据用 String; 多线程操作字符串缓冲区下操作大量数据 StringBuffer; 单线程操作字符串缓冲区下操作大量数据 StringBuilder. 5. 参考链接Java基础之String、StringBuffer与StringBuilder的区别及应用场景]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合(三)----HashMap]]></title>
    <url>%2F2018%2F09%2F22%2FJava%E9%9B%86%E5%90%88(%E4%B8%89)----HashMap%2F</url>
    <content type="text"><![CDATA[1. 前言集合是Java基础中非常重要的一部分, 也是日常中用到非常多的类, 这篇博客主要记录集合HashMap相关的知识. 2. HashMap2.1 概述HashMap 是用于映射(键值对)处理的数据类型, 基于哈希表的 Map 接口的非同步实现, 允许插入最多一条key为null的记录, 允许插入多条value为null的记录. 此外, HashMap 不保证元素顺序, 根据需要该容器可能会对元素重新哈希, 元素的顺序也会被重新打散, 因此在不同时间段迭代同一个 HashMap 的顺序可能会不同. HashMap 非线程安全, 即任一时刻有多个线程同时写 HashMap 的话可能会导致数据的不一致. HashMap 实际上是数组+链表+红黑树的结合体, 其底层包含一个数组, 数组中的每一项元素的可能值有四种: null, 单独一个结点, 链表, 红黑树(JDK1.8 开始 HashMap 通过使用红黑树来提高元素查找效率). 当往 HashMap 中 put 元素的时候, 需要先根据 key 的哈希值得到该元素在数组中的位置(即下标), 如果该位置上已经存放有其他元素了, 那么在这个位置上的元素将以链表或者红黑树的形式来存放, 如果该位置上没有元素, 就直接向该位置存放元素.HashMap 要求映射中的 key 是不可变对象，即要求该对象在创建后它的哈希值不会被改变，否则 Map 对象很可能就定位不到映射的位置了. 2.2 类声明12public class HashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable, Serializable 2.3 常量HashMap 中声明的常量有以下几个, 其中需要特别关注的是装载因子 DEFAULT_LOAD_FACTOR 和 TREEIFY_THRESHOLD. 装载因子用于规定数组在自动扩容之前可以数据占有其容量的最高比例, 即当数据量占有数组的容量达到这个比例后, 数组将自动扩容. 装载因子衡量的是一个散列表的空间的使用程度, 装载因子越大表示散列表的装填程度越高, 反之愈小. 因此如果装载因子越大, 则对空间的利用程度更高, 相对应的是查找效率的降低. 如果装载因子太小, 那么数组的数据将过于稀疏, 对空间的利用率低, 官方默认的装载因子为0.75, 是平衡空间利用率和运行效率两者之后的结果. 如果在实际情况中, 内存空间较多而对时间效率要求很高, 可以选择降低装载因子的值; 如果内存空间紧张而对时间效率要求不高, 则可以选择提高装载因子的值. 此外, 即使装载因子和哈希算法设计得再合理, 也不免会出现由于哈希冲突导致链表长度过长的情况, 这将严重影响 HashMap 的性能. 为了优化性能, 从 JDK1.8 开始引入了红黑树, 当链表长度超出 TREEIFY_THRESHOLD 规定的值时, 链表就会被转换为红黑树, 利用红黑树快速增删改查的特点以提高 HashMap 的性能.12345678910111213141516171819202122//序列化IDprivate static final long serialVersionUID = 362498820763181265L;//哈希桶数组的默认容量static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;//网上很多文章都说这个值是哈希桶数组能够达到的最大容量，其实这样说并不准确//从 resize() 方法的扩容机制可以看出来，HashMap 每次扩容都是将数组的现有容量增大一倍//如果现有容量已大于或等于 MAXIMUM_CAPACITY ，则不允许再次扩容//否则即使此次扩容会导致容量超出 MAXIMUM_CAPACITY ，那也是允许的static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//装载因子的默认值//装载因子用于规定数组在自动扩容之前可以数据占有其容量的最高比例，即当数据量占有数组的容量达到这个比例后，数组将自动扩容//装载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小//对于使用链表的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，则对空间的利用程度更高，相对应的是查找效率的降低//如果负载因子太小，那么数组的数据将过于稀疏，对空间的利用率低//官方默认的负载因子为0.75，是平衡空间利用率和运行效率两者之后的结果static final float DEFAULT_LOAD_FACTOR = 0.75f;//为了提高效率，当链表的长度超出这个值时，就将链表转换为红黑树static final int TREEIFY_THRESHOLD = 8; 2.4 成员变量123456789101112131415161718192021222324//哈希桶数组，在第一次使用时才初始化//容量值应是2的整数倍transient Node&lt;K, V&gt;[] table;/** * Holds cached entrySet(). Note that AbstractMap fields are used * for keySet() and values(). */transient Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;//Map的大小transient int size;//每当Map的结构发生变化时，此参数就会递增//当在对Map进行迭代操作时，迭代器会检查此参数值//如果检查到此参数的值发生变化，就说明在迭代的过程中Map的结构发生了变化，因此会直接抛出异常transient int modCount;//数组的扩容临界点，当数组的数据量达到这个值时就会进行扩容操作//计算方法：当前容量 x 装载因子int threshold;//使用的装载因子值final float loadFactor; 2.5 构造函数12345678910111213141516171819202122232425262728//设置Map的初始化大小和装载因子public HashMap(int initialCapacity, float loadFactor) &#123; //检查参数合法性 if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125;//设置Map的初始化大小public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;//都使用默认值public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR;&#125;//传入初始数据public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 2.6 结点类123456789101112131415161718//结点static class Node&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123; //当前结点的 key 的哈希值 final int hash; //键 final K key; //值 V value; //下一个结点 Node&lt;K, V&gt; next; Node(int hash, K key, V value, Node&lt;K, V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; ··· &#125; 2.7 哈希算法在查询, 添加和移除键值对时, 定位到哈希桶数组的指定位置都是很关键的第一步, 只有 HashMap 中的元素尽量分布均匀, 才能在定位键值对时快速地查找到相应位置, 避免频繁地去遍历链表或者红黑树, 这就需要依靠于一个比较好的哈希算法了. 以下是 HashMap 中计算 key 值的哈希值以及根据哈希值获取其在哈希桶数组中位置的算法.12345678910111213141516171819202122//计算哈希值static final int hash(Object key) &#123; int h; //高位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;//根据 key 值获取 Valuepublic V get(Object key) &#123; Node&lt;K, V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;//查找指定结点final Node&lt;K, V&gt; getNode(int hash, Object key) &#123; ··· //只有当 table 不为空且 hash 对应的位置不为 null 才有可获取的元素值 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; ··· &#125; return null;&#125; 确定键值对在哈希桶数组的位置的步骤分为三步: 计算 key 的 hashCode（h = key.hashCode()）, 高位运算（h &gt;&gt;&gt; 16）、取模运算（(n - 1) &amp; hash） 2.8 插入数据在上边说过, HashMap 是数组+链表+红黑树的结合, 数组包含的元素的可能值分为四种类型: null, 单个结点, 链表, 红黑树. 在插入结点时(每一个待存数据都会被包装为结点对象), 会根据待插入 Key 的哈希值来决定结点在数组中的位置, 如果计算得出的位置此时包含的元素为 null , 则直接将结点存入该位置, 如果不为 null , 则说明发生了哈希碰撞, 此时就需要将结点插入到链表或者是红黑树中. 当哈希算法的计算结果越分散均匀, 哈希碰撞的概率就越小, map 的存取效率就会越高. 如果待插入结点的 key 与链表或红黑树中某个已有结点的 key 相等(hash 值相等且两者 equals 成立), 则新添加的结点将覆盖原有数据.插入数据对应的是 put(K key, V value) 方法.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//插入数据public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;//计算哈希值static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent 为 true 表示不会覆盖有相同 key 的非 null value，否则会覆盖原有值 * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; p; int n, i; //如果 table 还未初始化，则调用 resize 方法进行初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //判断要存入的 key 是否存在哈希冲突，等于 null 说明不存在冲突 if ((p = tab[i = (n - 1) &amp; hash]) == null) //直接在索引 i 处构建包含待存入元素的结点 tab[i] = newNode(hash, key, value, null); else &#123; //走入本分支，说明待存入的 key 存在哈希冲突 Node&lt;K, V&gt; e; K k; //p 值已在上一个 if 语句中赋值了，此处就直接来判断 key 值之间的相等性 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //指向冲突的头结点 e = p; //如果头结点的 key 与待插入的 key 不相等，且头结点是 TreeNode 类型，说明该 hash 值是采用红黑树来处理冲突 else if (p instanceof TreeNode) //如果红黑数中包含有相同 key 的结点，则返回该结点，否则返回 null e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(this, tab, hash, key, value); else &#123; //采用链表来处理 hash 值冲突 for (int binCount = 0; ; ++binCount) &#123; //当遍历到链表尾部时 if ((e = p.next) == null) &#123; //构建一个新的结点添加到链表尾部 p.next = newNode(hash, key, value, null); //如果链表的长度已达到允许的最大长度 TREEIFY_THRESHOLD - 1 时，就将链表转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //当 e 指向的结点的 key 值与待插入的 key 相等时则跳出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; //如果 e != null，说明原先已存在相同 key 的键 if (e != null) &#123; V oldValue = e.value; //只有当 onlyIfAbsent 为 true 且 oldValue 不为 null 时才不会覆盖原有值 if (!onlyIfAbsent || oldValue == null) e.value = value; //用于 LinkedHashMap ，在 HashMap 中是空实现 afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //当元素数量达到扩容临界点时，需要进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 2.9 读取数据读取数据对应的是 get(Object key)方法12345678910111213141516171819202122232425262728293031//根据 key 值获取 Valuepublic V get(Object key) &#123; Node&lt;K, V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;//查找指定结点final Node&lt;K, V&gt; getNode(int hash, Object key) &#123; Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; first, e; int n; K k; //只有当 table 不为空且 hash 对应的位置不为 null 才有可获取的元素值 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //如果头结点的 hash 值与 Key 与待插入数据相等的话，则说明找到了对应值 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // first.next != null 说明存在哈希冲突 if ((e = first.next) != null) &#123; //如果是由红黑树来处理哈希冲突，则由此查找相应结点 if (first instanceof TreeNode) return ((TreeNode&lt;K, V&gt;) first).getTreeNode(hash, key); //遍历链表 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 2.10 移除结点从 Map 中移除键值对的操作, 在底层数据结构的体现就是移除对某个结点对象的引用, 可能是从数组中, 也可能是链表或者红黑树.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public V remove(Object key) &#123; Node&lt;K, V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; &#125; /** * Implements Map.remove and related methods * * @param hash key 的哈希值 * @param key the key * @param value key对应的值，只有当 matchValue 为 true 时才需要使用到，否则忽略该值 * @param matchValue 如果为 true ，则只有当 Map 中存在某个键 equals key 且 value 相等时才会移除该元素，否则只要 key 的 hash 值相等就直接移除该元素 * @param movable if false do not move other nodes while removing * @return the node, or null if none */ final Node&lt;K, V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; p; int n, index; //只有当 table 不为空且 hash 对应的索引位置存在值时才有可移除的对象 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K, V&gt; node = null, e; K k; V v; //如果与头结点的 key 相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; //存在哈希冲突 //用红黑树来处理哈希冲突 if (p instanceof TreeNode) //查找对应结点 node = ((TreeNode&lt;K, V&gt;) p).getTreeNode(hash, key); else &#123; //用链表来处理哈希冲突 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; //node != null 说明存在相应结点 //如果 matchValue 为 false ，则通过之前的判断可知查找到的结点的 key 与 参数 key 的哈希值一定相等，此处就可以直接移除结点 node //如果 matchValue 为 true ，则当 value 相等时才需要移除该结点 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) //对应红黑树 ((TreeNode&lt;K, V&gt;) node).removeTreeNode(this, tab, movable); else if (node == p) //对应 key 与头结点相等的情况，此时直接将指针移向下一位即可 tab[index] = node.next; else //对应的是链表的情况 p.next = node.next; ++modCount; --size; //用于 LinkedHashMap ，在 HashMap 中是空实现 afterNodeRemoval(node); return node; &#125; &#125; return null; &#125; 2.11 扩容如果哈希桶数组很大, 即使用的是较差的哈希算法元素也会比较分散, 如果哈希桶数组很小, 即使用的是好的哈希算法也会出现较多哈希碰撞的情况, 所以就需要在空间成本和时间成本之间权衡, 除了设计较好的哈希算法以减少哈希冲突外, 也需要在合适的的时机对哈希桶数组进行必要的扩容. 当 HashMap 中的元素越来越多时, 因为数组的长度是固定的, 所以哈希冲突的几率也就越来越高, 为了提高效率, 此时就需要对 HashMap 中的数组进行扩容, 而扩容操作最消耗性能的地方就在于: 原数组中的数据必须重新计算其在新数组中的位置并存放到新数组中. 那么 HashMap 扩容操作的触发时机是什么时候呢? 当 HashMap 中的元素个数超出 threshold 时(数组容量 与 loadFactor 的乘积), 就会进行数组扩容. 默认情况下, 数组的默认值为 16, loadFactor 的默认值为 0.75, 这是平衡空间利用率和运行效率两者之后的结果. 也就是说, 假设数组当前大小为16, loadFactor 值为0.75, 那么当 HashMap 中的元素个数达到12个时, 就会自动触发扩容操作, 把数组的大小扩充到 2 * 16 = 32, 即扩大一倍, 然后重新计算每个元素在新数组中的位置, 而这是一个非常消耗性能的操作, 所以如果已经预知到待存入 HashMap 的数据量, 那么在初始化 HashMap 时直接指定初始化大小会是一种更为高效的做法. 更改: 那么 HashMap 扩容操作的触发时机是什么时候呢?同时满足下面的两个条件:1. 存放新值的时候当前已有元素的个数必须大于等于阈值2. 存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值换算出来的数组下标位置已经存在值） 扩容操作对应的是 resize()方法 2.11.1 JDK1.8引入的扩容巧妙设计经过rehash之后, 元素的位置要么是在原位置, 要么是在原位置再移动2次幂的位置.图(a)表示扩容前的key1和key2两种key确定索引位置的示例;图(b)表示扩容后key1和key2两种key确定索引位置的示例, 其中hash1是key1对应的哈希与高位运算结果.元素在重新计算hash之后, 因为n变为2倍, 那么n-1的mask范围在高位多1bit(红色), 因此新的index就会发生这样的变化因此, 我们在扩充HashMap的时候, 不需要像JDK1.7的实现那样重新计算hash, 只需要看看原来的hash值新增的那个bit是1还是0就好了, 是0的话索引没变, 是1的话索引变成”原索引+oldCap”, 可以看看下图为16扩充为32的resize示意图:这个设计确实非常的巧妙, 既省去了重新计算hash值的时间, 而且同时, 由于新增的1bit是0还是1可以认为是随机的, 因此resize的过程, 均匀的把之前的冲突的节点分散到新的bucket了. 这一块就是JDK1.8新增的优化点. 有一点注意区别, JDK1.7中rehash的时候, 旧链表迁移新链表的时候, 如果在新表的数组索引位置相同, 则链表元素会倒置, 但是从上图可以看出, JDK1.8不会倒置. 2.11.2 resize源码解读12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879final Node&lt;K, V&gt;[] resize() &#123; Node&lt;K, V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float) newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float) MAXIMUM_CAPACITY ? (int) ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes"，"unchecked"&#125;) Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K, V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K, V&gt;) e).split(this, newTab, j, oldCap); else &#123; // 链表优化重hash的代码块 Node&lt;K, V&gt; loHead = null, loTail = null; Node&lt;K, V&gt; hiHead = null, hiTail = null; Node&lt;K, V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125;// 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 2.12 效率测试这里来测试下不同的初始化大小以及 key 值的 HashCode 值的分布情况的不同对 HashMap 效率的影响首先来定义作为 Key 的类, hashCode() 方法直接返回其包含的属性 value123456789101112131415161718import java.util.Objects;public class Key &#123; private int value; public Key(int value) &#123; this.value = value; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Key key = (Key) o; return value == key.value; &#125; @Override public int hashCode() &#123; return Objects.hash(value); &#125;&#125; 初始化大小从 100 到 100000 之间以 10 倍的倍数递增，向 HashMap 存入同等数据量的数据，观察不同 HashMap 存入数据消耗的总时间12345678910111213141516171819202122232425import java.util.HashMap;import java.util.Map;public class KeyMain &#123; private static final int MAX_KEY = 20000; private static final Key[] KEYS = new Key[MAX_KEY]; static &#123; for (int i = 0; i &lt; MAX_KEY; i++) &#123; KEYS[i] = new Key(i); &#125; &#125; private static void test(int size) &#123; long startTime = System.currentTimeMillis(); Map&lt;Key, Integer&gt; map = new HashMap&lt;&gt;(size); for (int i = 0; i &lt; MAX_KEY; i++) &#123; map.put(KEYS[i], i); &#125; long endTime = System.currentTimeMillis(); System.out.println("初始化大小是：" + size + " , 所用时间：" + (endTime - startTime) + "毫秒"); &#125; public static void main(String[] args) &#123; for (int i = 20; i &lt;= MAX_KEY; i *= 10) &#123; test(i); &#125; &#125;&#125; 运行结果:1234初始化大小是：20 , 所用时间：9毫秒初始化大小是：200 , 所用时间：13毫秒初始化大小是：2000 , 所用时间：5毫秒初始化大小是：20000 , 所用时间：3毫秒 在上述使用的例子中, 各个 Key 对象之间的哈希码值各不相同, 所以键值对在哈希桶数组中的分布可以说是很均匀的了, 此时主要影响性能的就是扩容机制了, 由上图可以看出各个初始化大小对 HashMap 的性能影响还是很大的接下来再看看各个 Key 对象之间频繁发生哈希冲突时 HashMap 的性能令 Key 类的 hashCode() 方法固定返回 100, 则每个键值对在存入 HashMap 时, 一定会发生哈希冲突1234@Overridepublic int hashCode() &#123; return 100;&#125; 运行结果:1234初始化大小是：20 , 所用时间：6192毫秒初始化大小是：200 , 所用时间：6004毫秒初始化大小是：2000 , 所用时间：5633毫秒初始化大小是：20000 , 所用时间：5914毫秒 此时主要影响性能的点就在于对哈希冲突的处理了 2.13 equals()和hashCode()在使用Map存对象的时候, 要记得, 一定要重写此类的 equals() 和 hashCode() 方法哦!!! 3. 参考链接HashMap源码，你知道多少？HashMap的扩容机制—resize()深入理解HashMap的扩容机制]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合(二)----Set]]></title>
    <url>%2F2018%2F09%2F22%2FJava%E9%9B%86%E5%90%88(%E4%BA%8C)----Set%2F</url>
    <content type="text"><![CDATA[1. 前言集合是Java基础中非常重要的一部分, 也是日常中用到非常多的类, 这篇博客主要记录集合Set相关的知识. 特别声明: 大部分内容并非原创, 引用自参考链接. 2. SetSet继承于Collection接口, 是一个不允许出现重复元素, 并且无序的集合, 主要有HashSet和TreeSet两大实现类.在判断重复元素的时候, Set集合会调用hashCode()和equal()方法来实现.HashSet是哈希表结构, 主要利用HashMap的key来存储元素, 计算插入元素的hashCode来获取元素在集合中的位置;TreeSet是红黑树结构, 每一个元素都是树中的一个节点, 插入的元素都会进行排序; 2.1 Set常用操作与List接口一样, Set接口也提供了集合操作的基本方法.但与List不同的是, Set还提供了equals(Object o)和hashCode(), 供其子类重写, 以实现对集合中插入重复元素的处理;12345678910111213141516171819202122232425262728293031public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123; A:添加功能 boolean add(E e); boolean addAll(Collection&lt;? extends E&gt; c); B:删除功能 boolean remove(Object o); boolean removeAll(Collection&lt;?&gt; c); void clear(); C:长度功能 int size(); D:判断功能 boolean isEmpty(); boolean contains(Object o); boolean containsAll(Collection&lt;?&gt; c); boolean retainAll(Collection&lt;?&gt; c); E:获取Set集合的迭代器： Iterator&lt;E&gt; iterator(); F:把集合转换成数组 Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); //判断元素是否重复，为子类提高重写方法 boolean equals(Object o); int hashCode();&#125; 2.2 初识HashSetHashSet实现Set接口, 底层由HashMap(后面讲解)来实现, 为哈希表结构, 新增元素相当于HashMap的key, value默认为一个固定的Object. HashSet相当于一个阉割版的HashMap;当有元素插入的时候, 会计算元素的hashCode值, 将元素插入到哈希表对应的位置中来;它继承于AbstractSet, 实现了Set, Cloneable, Serializable接口.(1)HashSet继承AbstractSet类, 获得了Set接口大部分的实现, 减少了实现此接口所需的工作, 实际上是又继承了AbstractCollection类;(2)HashSet实现了Set接口, 获取Set接口的方法, 可以自定义具体实现, 也可以继承AbstractSet类中的实现;(3)HashSet实现Cloneable, 得到了clone()方法, 可以实现克隆功能;(4)HashSet实现Serializable, 表示可以被序列化, 通过序列化去传输, 典型的应用就是hessian协议.具有如下特点:(1)不允许出现重复因素;(2)允许插入Null值;(3)元素无序(添加顺序和遍历顺序不一致);(4)线程不安全, 若2个线程同时操作HashSet, 必须通过代码实现同步; 2.2.1 HashSet元素添加Set集合不允许添加重复元素, 那么到底是个怎么情况呢?来看一个简单的例子:12345678910111213141516171819202122232425262728293031public class HashSetTest &#123; public static void main(String[] agrs)&#123; //hashCode() 和 equals()测试： hashCodeAndEquals(); &#125; public static void hashCodeAndEquals()&#123; //第一个 Set集合： Set&lt;String&gt; set1 = new HashSet&lt;String&gt;(); String str1 = new String("jiaboyan"); String str2 = new String("jiaboyan"); set1.add(str1); set1.add(str2); System.out.println("长度："+set1.size()+",内容为："+set1); //第二个 Set集合： Set&lt;App&gt; set2 = new HashSet&lt;App&gt;(); App app1 = new App(); app1.setName("jiaboyan"); App app2 = new App(); app2.setName("jiaboyan"); set2.add(app1); set2.add(app2); System.out.println("长度："+set2.size()+",内容为："+set2); //第三个 Set集合： Set&lt;App&gt; set3 = new HashSet&lt;App&gt;(); App app3 = new App(); app3.setName("jiaboyan"); set3.add(app3); set3.add(app3); System.out.println("长度："+set3.size()+",内容为："+set3); &#125;&#125; 测试结果:123长度：1,内容为：[jiaboyan]长度：2,内容为：[App@74a14482, App@4554617c]长度：1,内容为：[App@1540e19d] 可以看到, 第一个Set集合中最终只有一个元素; 第二个Set集合保留了2个元素; 第三个集合也只有1个元素;究竟是什么原因呢?让我们来看看HashSet的add(E e)方法:123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 在底层HashSet调用了HashMap的put(K key, V value)方法:123456789101112131415161718192021public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125; 简单概括如下:在向HashMap中添加元素时, 先判断key的hashCode值是否相同, 如果相同, 则调用==, equals()进行判断, 若相同则覆盖原有元素; 如果不同, 则直接向Map中添加元素;反过来, 我们在看下上面的例子:在第一个Set集合中, 我们new了两个String对象, 赋了相同的值. 当传入到HashMap中时, key均为”jiaboyan”, 所以hash和i的值都相同. 进行if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))判断, 由于String对象重写了equals()方法,所以在((k = e.key) == key || key.equals(k))判断时, 返回了true, 所以第二次的插入并不会增加Set集合的长度;第二个Set集合中, 也是new了两个对象, 但没有重写equals()方法(底层调用的Object的equals()，也就是==判断), 所以会增加2个元素;第三个Set集合中, 只new了一个对象, 调用的两次add方法都添加的这个新new的对象,所以也只是保留了1个元素; 2.3 初识TreeSet从名字上可以看出, 此集合的实现和树结构有关.与HashSet集合类似, TreeSet也是基于Map来实现, 具体实现TreeMap, 其底层结构为红黑树;与HashSet不同的是, TreeSet具有排序功能, 分为自然排序(123456)和自定义排序两类, 默认是自然排序; 在程序中, 我们可以按照任意顺序将元素插入到集合中, 等到遍历时TreeSet会按照一定顺序输出–倒序或者升序;它继承AbstractSet, 实现NavigableSet, Cloneable, Serializable接口.(1)与HashSet同理, TreeSet继承AbstractSet类,获得了Set集合基础实现操作;(2)TreeSet实现NavigableSet接口, 而NavigableSet又扩展了SortedSet接口. 这两个接口主要定义了搜索元素的能力, 例如给定某个元素,查找该集合中比给定元素大于, 小于, 等于的元素集合, 或者比给定元素大于, 小于, 等于的元素个数; 简单地说, 实现NavigableSet接口使得TreeSet具备了元素搜索功能;(3)TreeSet实现Cloneable接口, 意味着它也可以被克隆;(4)TreeSet实现了Serializable接口, 可以被序列化, 可以使用hessian协议来传输;具有如下特点:(1)对插入的元素进行排序, 是一个有序的集合(主要与HashSet的区别);(2)底层使用红黑树结构, 而不是哈希表结构;(3)允许插入Null值;(4)不允许插入重复元素;(5)线程不安全; 2.3.1 TreeSet元素排序在前面的章节, 我们讲到了TreeSet是一个有序集合,可以对集合元素排序,其中分为自然排序和自定义排序,那么这两种方式如何实现呢?首先,我们通过JDK提供的对象来展示, 我们使用String, Integer:1234567891011121314151617181920public class TreeSetTest &#123; public static void main(String[] agrs)&#123; naturalSort(); &#125; //自然排序顺序：升序 public static void naturalSort()&#123; TreeSet&lt;String&gt; treeSetString = new TreeSet&lt;String&gt;(); treeSetString.add("a"); treeSetString.add("z"); treeSetString.add("d"); treeSetString.add("b"); System.out.println("字母顺序：" + treeSetString.toString()); TreeSet&lt;Integer&gt; treeSetInteger = new TreeSet&lt;Integer&gt;(); treeSetInteger.add(1); treeSetInteger.add(24); treeSetInteger.add(23); treeSetInteger.add(6); System.out.println("数字顺序：" + treeSetInteger.toString()); &#125;&#125; 测试结果:12字母顺序：[a, b, d, z]数字顺序：[1, 6, 23, 24] 接下来, 我们自定义对象, 看能否实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.TreeSet;public class Main &#123; public static void main(String[] agrs)&#123; customSort(); &#125; //自定义排序顺序：升序 public static void customSort()&#123; TreeSet&lt;App&gt; treeSet = new TreeSet&lt;App&gt;(); //排序对象： App app1 = new App("hello",10); App app2 = new App("world",20); App app3 = new App("my",15); App app4 = new App("name",25); //添加到集合： treeSet.add(app1); treeSet.add(app2); treeSet.add(app3); treeSet.add(app4); System.out.println("TreeSet集合顺序为："+treeSet); &#125;&#125;class App&#123; private String name; private Integer age; public App()&#123;&#125; public App(String name,Integer age)&#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public static void main(String[] args )&#123; System.out.println( "Hello World!" ); &#125;&#125; 测试结果: 123456Exception in thread "main" java.lang.ClassCastException: App cannot be cast to java.lang.Comparable at java.util.TreeMap.compare(TreeMap.java:1294) at java.util.TreeMap.put(TreeMap.java:538) at java.util.TreeSet.add(TreeSet.java:255) at Main.customSort(Main.java:15) at Main.main(Main.java:4) 为什么会报错呢?12345compare(key, key); // type (and possibly null) checkfinal int compare(Object k1, Object k2) &#123; return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2);&#125; 通过查看源码发现, 在TreeSet调用add方法时, 会调用到底层TreeMap的put方法, 在put方法中会调用到compare(key, key)方法, 进行key大小的比较;在比较的时候, 会将传入的key进行类型强转, 所以当我们自定义的App类进行比较的时候, 自然就会抛出异常, 因为App类并没有实现Comparable接口;将App实现Comparable接口, 再做比较:123456789101112131415161718192021222324252627282930313233343536373839class App implements Comparable&lt;App&gt;&#123; private String name; private Integer age; public App()&#123;&#125; public App(String name,Integer age)&#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public static void main(String[] args )&#123; System.out.println( "Hello World!" ); &#125; @Override //自定义比较：先比较name的长度，在比较age的大小； public int compareTo(App app) &#123; //比较name的长度： int num = this.name.length() - app.name.length(); //如果name长度一样，则比较年龄的大小： return num == 0 ? this.age - app.age : num; &#125; @Override public String toString() &#123; return "App&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 测试结果:1TreeSet集合顺序为：[App&#123;name=&apos;my&apos;, age=15&#125;, App&#123;name=&apos;name&apos;, age=25&#125;, App&#123;name=&apos;hello&apos;, age=10&#125;, App&#123;name=&apos;world&apos;, age=20&#125;] 此外, 还有另一种方式, 那就是实现Comparetor接口, 并重写compare方法;12345678//自定义App类的比较器：public class AppComparator implements Comparator&lt;App&gt; &#123; //比较方法：先比较年龄，年龄若相同在比较名字长度； public int compare(App app1, App app2) &#123; int num = app1.getAge() - app2.getAge(); return num == 0 ? app1.getName().length() - app2.getName().length() : num; &#125;&#125; 此时, App不用在实现Comparerable接口了, 单纯的定义一个类即可;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.Comparator;import java.util.TreeSet;public class Main &#123; public static void main(String[] agrs)&#123; customSort(); &#125; //自定义排序顺序：升序 public static void customSort()&#123; TreeSet&lt;App&gt; treeSet = new TreeSet&lt;App&gt;(new AppComparator()); //排序对象： App app1 = new App("hello",10); App app2 = new App("world",20); App app3 = new App("my",15); App app4 = new App("name",25); //添加到集合： treeSet.add(app1); treeSet.add(app2); treeSet.add(app3); treeSet.add(app4); System.out.println("TreeSet集合顺序为："+treeSet); &#125;&#125;class App&#123; private String name; private Integer age; public App()&#123;&#125; public App(String name,Integer age)&#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public static void main(String[] args )&#123; System.out.println( "Hello World!" ); &#125; @Override public String toString() &#123; return "App&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125;//自定义App类的比较器：class AppComparator implements Comparator&lt;App&gt; &#123; //比较方法：先比较年龄，年龄若相同在比较名字长度； public int compare(App app1, App app2) &#123; int num = app1.getAge() - app2.getAge(); return num == 0 ? app1.getName().length() - app2.getName().length() : num; &#125;&#125; 测试结果:1TreeSet集合顺序为：[App&#123;name=&apos;hello&apos;, age=10&#125;, App&#123;name=&apos;my&apos;, age=15&#125;, App&#123;name=&apos;world&apos;, age=20&#125;, App&#123;name=&apos;name&apos;, age=25&#125;] 最后, 再说下关于compareTo(), compare()方法:123结果返回大于0时，方法前面的值大于方法中的值；结果返回等于0时，方法前面的值等于方法中的值；结果返回小于0时，方法前面的值小于方法中的值； 2.4 HashSet源码分析(基于JDK1.7.0_75)HashSet基于HashMap, 底层方法是通过调用HashMap的API来实现, 因此HashSet源码结构比较简单, 代码较少. 2.4.1 成员变量在HashSet中, 有两个成员变量比较重要–map, PRESENT;其中,map就是存储元素的地方, 实际是一个HashMap. 当有元素插入到HashSet中时, 会被当做HashMap的key保存到map属性中去.对于HashMap来说,光有key还不够, 在HashSet的实现中, 每个key对应的value都默认为PRESENT属性, 也就是new了一个Object对象而已;123456789public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123; static final long serialVersionUID = -5024744406713321676L; //HashSet通过HashMap保存集合元素的： private transient HashMap&lt;E,Object&gt; map; //HashSet底层由HashMap实现，新增的元素为map的key，而value则默认为PRESENT。 private static final Object PRESENT = new Object();&#125; 2.4.2 构造方法HashSet的构造方法很简单, 主要是在方法内部初始化map属性, new了一个HashMap对象;123456789101112131415161718192021222324252627public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; //无参构造方法： public HashSet() &#123; //默认new一个HashMap map = new HashMap&lt;&gt;(); &#125; // 带集合的构造函数 public HashSet(Collection&lt;? extends E&gt; c) &#123; // 进行初始化HashMap容量判断， map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); &#125; // 指定HashSet初始容量和加载因子的构造函数：主要用于Map内部的扩容机制 public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor); &#125; // 指定HashSet初始容量的构造函数 public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity); &#125; //与前4个不同，此构造最终new了一个LinkedHashMap对象： HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125;&#125; 2.4.3 add()HashSet的add(E e)方法, 主要是调用底层HashMap的put(K key, V value)方法.其中key就是HashSet集合插入的元素, 而value则是默认的PRESENT属性(一个new Object());1234//调用HashMap中的put()方法:public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 2.4.4 remove()与add(E e)方法类似, HashSet的remove(Object o)也是调用了底层HashMap的(Object key)方法;主要是计算出要删除元素的hash值, 在HashMap找到对应的对象, 然后从Entry[]数组中删除;1234//调用HashMap中的remove方法：public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125; 2.5 TreeSet源码分析(基于JDK1.7.0_75)与HashSet类似, TreeSet底层也是采用了一个Map来保存集合元素, 这个Map就是NavigableMap.不过, NavigableMap仅仅是一个接口, 具体的实现还是使用了TreeMap类; 2.5.1 成员变量成员变量m是一个NavigableMap类型的Map集合, 常用实现是TreeMap对象;在TreeMap中, key是我们TreeSet插入的元素, 而value则是TreeSet中另一个成员变量PRESENT, 一个普通的不能再普通的Object对象;1234567public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable &#123; //TreeSet中保存元素的map对象： private transient NavigableMap&lt;E,Object&gt; m; //map对象中保存的value: private static final Object PRESENT = new Object();&#125; 2.5.2 构造方法12345678910111213141516171819202122232425public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable &#123; //最底层的构造方法，不对外。传入一个NavigableMap接口的实现类 TreeSet(NavigableMap&lt;E,Object&gt; m) &#123; this.m = m; &#125; //无参构造：向底层构造传入一个TreeMap对象： public TreeSet() &#123; this(new TreeMap&lt;E,Object&gt;()); &#125; //传入比较器的构造：通常传入一个自定义Comparator的实现类； public TreeSet(Comparator&lt;? super E&gt; comparator) &#123; this(new TreeMap&lt;&gt;(comparator)); &#125; //将集合Collection传入TreeSet中： public TreeSet(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; //将集合SortedSet传入TreeSet中： public TreeSet(SortedSet&lt;E&gt; s) &#123; this(s.comparator()); addAll(s); &#125;&#125; 2.5.3 add()向TreeSet中添加元素123public boolean add(E e) &#123; return m.put(e, PRESENT)==null;&#125; 2.5.4 remove()删除TreeSet中元素o123public boolean remove(Object o) &#123; return m.remove(o)==PRESENT;&#125; 2.6 SortedSet和NavigableSet到底是什么在一些关于TreeSet讲解的文章中, 在介绍TreeSet的时候都会提到NavigableSet, 接着会说下NavigableSet是个”导航Set集合”, 提供了一系列”导航”方法. 那么, 什么是”导航”方法?通过接口的定义, 我们可以看到NavigableSet继承了SortedSet接口(后面说), 实现了对其的扩展;而通过下面的方法, 我们得出NavigableSet实际提供了一系列的搜索匹配元素的功能, 能获取到某一区间内的集合元素;123456789101112131415161718192021public interface NavigableSet&lt;E&gt; extends SortedSet&lt;E&gt; &#123; E lower(E e);//返回此set集合中小于e元素的最大元素 E floor(E e);//返回此set集合中小于等于e元素的最大元素 E ceiling(E e);//返回此set集合中大于等于e元素的最小元素 E higher(E e);//返回此set集合中大于e元素的最小元素 E pollFirst(); //获取并移除此set集合中的第一个元素 E pollLast();//获取并移除此set集合中的最后一个元素 Iterator&lt;E&gt; iterator();//返回此set集合的迭代器--升序 NavigableSet&lt;E&gt; descendingSet();//以倒序的顺序返回此set集合 Iterator&lt;E&gt; descendingIterator();//返回此set集合的迭代器--倒序 //返回此set集合的部分元素--从fromElement开始到toElement结束，其中fromInclusive、toInclusive意为返回的集合是否包含头尾元素 NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive); //返回此set集合的部分元素--小于toElement，inclusive意味返回的集合是否包含toElement NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive); //返回此set集合的部分元素--从fromElement开始到toElement结束，包含头不含为尾 SortedSet&lt;E&gt; subSet(E fromElement, E toElement); //返回此set集合的部分元素--小于toElement SortedSet&lt;E&gt; headSet(E toElement); //返回此set集合的部分元素--大于等于toElement SortedSet&lt;E&gt; tailSet(E fromElement);&#125; 说完了NavigableSet, 我们在一起儿看下其父类SortedSet接口:通过名字, 我们可以得出此接口跟排序有关, 会提供跟排序的方法;1234567891011121314public interface SortedSet&lt;E&gt; extends Set&lt;E&gt; &#123; //返回与排序有关的比较器 Comparator&lt;? super E&gt; comparator(); //返回从fromElement到toElement的元素集合： SortedSet&lt;E&gt; subSet(E fromElement, E toElement); //返回从第一个元素到toElement元素的集合： SortedSet&lt;E&gt; headSet(E toElement); //返回从fromElement开始到最后元素的集合： SortedSet&lt;E&gt; tailSet(E fromElement); //返回集合中的第一个元素： E first(); //返回集合中的最后一个元素： E last();&#125; 3. 参考链接Java集合：Set源码详细分析(一)Java集合：Set源码详细分析(二)]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合(一)----List]]></title>
    <url>%2F2018%2F09%2F22%2FJava%E9%9B%86%E5%90%88(%E4%B8%80)----List%2F</url>
    <content type="text"><![CDATA[1. 前言集合是Java基础中非常重要的一部分, 也是日常中用到非常多的类, 这篇博客主要记录集合List相关的知识. 特别声明: 大部分内容并非原创, 引用自参考链接. 2. Java集合相比于数组(Array)来说, 集合类的长度可变, 更加适合于现代开发需求;在程序运行时, Java集合可以动态的进行扩展, 随着元素的增加而扩大.在Java中, 集合类通常存在于java.util包中.Java集合主要由2大体系构成, 分别是Collection体系和Map体系, 其中Collection和Map分别是2大体系中的顶层接口.Collection主要有三个子接口, 分别为List(列表), Set(集), Queue(队列). 其中, List, Queue中的元素有序可重复, 而Set中的元素无序不可重复;List中主要有ArrayList, LinkedList两个实现类; Set中则是有HashSet实现类; 而Queue是在JDK1.5后才出现的新集合, 主要以数组和链表两种形式存在.Map同属于java.util包中, 是集合的一部分,但与Collection是相互独立的, 没有任何关系. Map中都是以key-value的形式存在, 其中key必须唯一, 主要有HashMap, Hashtable, TreeMap三个实现类. 3. List在Collection中, List集合是有序的, Developer可对其中每个元素的插入位置进行精确地控制, 可以通过索引来访问元素, 遍历元素.在List集合中, 我们常用到ArrayList和LinkedList这两个类. 3.1 初识ArrayList其中, ArrayList底层通过数组实现, 随着元素的增加而动态扩容. 而LinkedList底层通过链表来实现, 随着元素的增加不断向链表的后端增加节点.ArrayList是Java集合框架中使用最多的一个类, 是一个数组队列, 线程不安全集合.它继承于AbstractList, 实现了List, RandomAccess, Cloneable, Serializable接口.(1)ArrayList实现List, 得到了List集合框架基础功能;(2)ArrayList实现RandomAccess, 获得了快速随机访问存储元素的功能, RandomAccess是一个标记接口, 没有任何方法;(3)ArrayList实现Cloneable, 得到了clone()方法, 可以实现克隆功能;(4)ArrayList实现Serializable, 表示可以被序列化, 通过序列化去传输, 典型的应用就是hessian协议. 它具有如下特点:(1)容量不固定, 随着容量的增加而动态扩容(阈值基本不会达到)(2)有序集合(插入的顺序==输出的顺序)(3)插入的元素可以为null(4)增删改查效率更高(相对于LinkedList来说)(5)线程不安全. 数据结构: 3.2 初识LinkedListLinkedList是一个双向链表, 每一个节点都拥有指向前后节点的引用. 相比于ArrayList来说, LinkedList的随机访问效率更低.它继承AbstractSequentialList, 实现了List, Deque, Cloneable, Serializable接口.(1)LinkedList实现List, 得到了List集合框架基础功能;(2)LinkedList实现Deque, Deque 是一个双向队列, 也就是既可以先入先出, 又可以先入后出,说 简单些就是既可以在头部添加元素, 也可以在尾部添加元素;(3)LinkedList实现Cloneable, 得到了clone()方法, 可以实现克隆功能;(4)LinkedList实现Serializable, 表示可以被序列化, 通过序列化去传输, 典型的应用就是hessian协议.数据结构: 3.3 List常用方法12345678910111213141516171819202122232425262728A:添加功能boolean add(E e):向集合中添加一个元素void add(int index, E element):在指定位置添加元素boolean addAll(Collection&lt;? extends E&gt; c)：向集合中添加一个集合的元素。B:删除功能void clear()：删除集合中的所有元素E remove(int index)：根据指定索引删除元素，并把删除的元素返回boolean remove(Object o)：从集合中删除指定的元素boolean removeAll(Collection&lt;?&gt; c):从集合中删除一个指定的集合元素。C:修改功能E set(int index, E element):把指定索引位置的元素修改为指定的值，返回修改前的值。D:获取功能E get(int index)：获取指定位置的元素Iterator iterator():就是用来获取集合中每一个元素。E:判断功能boolean isEmpty()：判断集合是否为空。boolean contains(Object o)：判断集合中是否存在指定的元素。boolean containsAll(Collection&lt;?&gt; c)：判断集合中是否存在指定的一个集合中的元素。F:长度功能int size():获取集合中的元素个数。G:把集合转换成数组Object[] toArray():把集合变成数组。 3.4 ArrayList和LinkedList性能比较3.4.1 元素新增从直观上看, 在新增操作时, ArrayList效率不如LinkedList, 因为ArrayList底层是数组实现, 在动态扩容时, 性能有所损耗, 而LinkedList不存在数组扩容机制, 所以LinkedList效率更高.1234567891011121314151617181920212223242526public class ListTest &#123; //迭代次数 public static int ITERATION_NUM = 100000; public static void main(String[] agrs) &#123; insertPerformanceCompare(); &#125; //新增性能比较： public static void insertPerformanceCompare() &#123; System.out.println("LinkedList新增测试开始"); long start = System.nanoTime(); List&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;(); for (int x = 0; x &lt; ITERATION_NUM; x++) &#123; linkedList.add(x); &#125; long end = System.nanoTime(); System.out.println(end - start); System.out.println("ArrayList新增测试开始"); start = System.nanoTime(); List&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); for (int x = 0; x &lt; ITERATION_NUM; x++) &#123; arrayList.add(x); &#125; end = System.nanoTime(); System.out.println(end - start); &#125;&#125; 结果:1234567891011121314151617第一组:LinkedList新增测试开始7609993ArrayList新增测试开始6071437第二组:LinkedList新增测试开始12317919ArrayList新增测试开始5754172第三组:LinkedList新增测试开始8291202ArrayList新增测试开始5320576 结果与预想的有些不太一样, ArrayList的新增性能并不低.究其原因, 可能是经过JDK近几年的更新发展, 对于数组复制的实现进行了优化, 以至于ArrayList的性能也得到了提高. 也可能是由于, LinkedList每次add操作都需要创建一个node对象, 这会产生额外开销, 而ArrayList只有在扩容的时候才需要数组的复制, 不扩容的时候, 没有额外开销. 3.4.2 元素获取由于LinkedList是链表结构, 没有角标的概念, 没有实现RandomAccess接口, 不具备随机元素访问功能, 所以在get方面表现的差强人意, ArrayList再一次完胜.1234567891011121314151617181920212223242526272829303132333435363738public class ListTest &#123; //迭代次数，集合大小： public static int ITERATION_NUM = 100000; public static void main(String[] agrs) &#123; getPerformanceCompare(); &#125; //获取性能比较： public static void getPerformanceCompare() &#123; //填充ArrayList集合： List&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); for (int x = 0; x &lt; ITERATION_NUM; x++) &#123; arrayList.add(x); &#125; //填充LinkedList集合： List&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;(); for (int x = 0; x &lt; ITERATION_NUM; x++) &#123; linkedList.add(x); &#125; //创建随机数对象： Random random = new Random(); System.out.println("LinkedList获取测试开始"); long start = System.nanoTime(); for (int x = 0; x &lt; ITERATION_NUM; x++) &#123; int j = random.nextInt(x + 1); int k = linkedList.get(j); &#125; long end = System.nanoTime(); System.out.println(end - start); System.out.println("ArrayList获取测试开始"); start = System.nanoTime(); for (int x = 0; x &lt; ITERATION_NUM; x++) &#123; int j = random.nextInt(x + 1); int k = arrayList.get(j); &#125; end = System.nanoTime(); System.out.println(end - start); &#125;&#125; 结果: 1234567891011121314151617第一组:LinkedList获取测试开始6193992452ArrayList获取测试开始9773597第二组:LinkedList获取测试开始6920119875ArrayList获取测试开始4026352第三组:LinkedList获取测试开始5559676521ArrayList获取测试开始10468298 从结果中可以看到, ArrayList在随机访问方面表现的十分优秀, 比LinkedList强了很多, 基本上保持在500-1000倍.LinkedList为什么这么慢呢?这主要是LinkedList的代码实现所致, 每一次获取都是从头开始遍历, 一个个节点去查找, 每查找一次就遍历一次, 所以性能自然得不到提升. 3.5 ArrayList源码分析(基于JDK1.7.0_45)接下来, 我们几对ArrayList的源码进行一个解析, 主要从以下几个问题出发.(1)ArrayList构造(2)增删改查实现(3)迭代器-modCount(4)为什么数组对象要使用transient修饰符(5)System.arraycopy()参数含义 和 Arrays.copyOf()参数含义我们通过这这几个问题, 来一步步的学习ArrayList. 3.5.1 ArrayList构造器在JDK1.7版本中, ArrayList的无参构造方法并没有生成容量为10的数组;elementData对象是ArrayList集合底层保存元素的实现;size属性记录了ArrayList集合中实际元素的个数;123456789101112131415161718192021222324252627282930313233343536373839public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; //实现Serializable接口，生成的序列版本号： private static final long serialVersionUID = 8683452581122892189L; //ArrayList初始容量大小：在无参构造中不使用了 private static final int DEFAULT_CAPACITY = 10; //空数组对象：初始化中默认赋值给elementData private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //ArrayList中实际存储元素的数组： private transient Object[] elementData; //集合实际存储元素长度： private int size; //ArrayList有参构造：容量大小 public ArrayList(int initialCapacity) &#123; //即父类构造：protected AbstractList() &#123;&#125;空方法 super(); //如果传递的初始容量小于0 ，抛出异常 if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); //初始化数据：创建Object数组 this.elementData = new Object[initialCapacity]; &#125; //ArrayList无参构造： public ArrayList() &#123; //即父类构造：protected AbstractList() &#123;&#125;空方法 super(); //初始化数组：空数组，容量为0 this.elementData = EMPTY_ELEMENTDATA; &#125; //ArrayList有参构造：Java集合 public ArrayList(Collection&lt;? extends E&gt; c) &#123; //将集合转换为数组： elementData = c.toArray(); //设置数组的长度： size = elementData.length; if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125;&#125; 3.5.2 add()ArrayList增加元素的方法事关重要, 我们都知道ArrayList底层是由数组, 可以随着元素的增加而扩容, 那么具体是如何实现的呢?在JDK1.7当中, 当第一个元素添加时, ensureCapacityInternal()方法会计算ArrayList的扩容大小, 默认为10;其中grow()方法最为重要, 如果需要扩容, 那么扩容后的大小是原来的1.5倍, 实际上最终调用了Arrays.copyOf()方法得以实现;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//添加元素epublic boolean add(E e) &#123; ensureCapacityInternal(size + 1); //将对应角标下的元素赋值为e： elementData[size++] = e; return true;&#125;//得到最小扩容量private void ensureCapacityInternal(int minCapacity) &#123; //如果此时ArrayList是空数组,则将最小扩容大小设置为10： if (elementData == EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //判断是否需要扩容： ensureExplicitCapacity(minCapacity);&#125;//判断是否需要扩容private void ensureExplicitCapacity(int minCapacity) &#123; //操作数+1 modCount++; //判断最小扩容容量-数组大小是否大于0： if (minCapacity - elementData.length &gt; 0) //扩容： grow(minCapacity);&#125;//ArrayList动态扩容的核心方法:private void grow(int minCapacity) &#123; //获取现有数组大小： int oldCapacity = elementData.length; //位运算，得到新的数组容量大小，为原有的1.5倍： int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //如果新扩容的大小依旧小于传入的容量值，那么将传入的值设为新容器大小： if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //如果新容器大小，大于ArrayList最大长度： if (newCapacity - MAX_ARRAY_SIZE &gt; 0) //计算出最大容量值： newCapacity = hugeCapacity(minCapacity); //数组复制： elementData = Arrays.copyOf(elementData, newCapacity);&#125;//计算ArrayList最大容量：private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) throw new OutOfMemoryError(); //如果新的容量大于MAX_ARRAY_SIZE。将会调用hugeCapacity将int的最大值赋给newCapacity: return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 3.5.3 remove()remove(int index)是针对于角标来进行删除, 不需要去遍历整个集合, 效率更高;而remove(Object o)是针对于对象来进行删除, 需要遍历整个集合进行equals()方法比对, 所以效率较低;不过, 无论是哪种形式的删除, 最终都会调用System.arraycopy()方法进行数组复制操作, 所以效率都会受到影响;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//在ArrayList的移除index位置的元素public E remove(int index) &#123; //检查角标是否合法：不合法抛异常 rangeCheck(index); //操作数+1： modCount++; //获取当前角标的value: E oldValue = elementData(index); //获取需要删除元素 到最后一个元素的长度，也就是删除元素后，后续元素移动的个数； int numMoved = size - index - 1; //如果移动元素个数大于0 ，也就是说删除的不是最后一个元素： if (numMoved &gt; 0) // 将elementData数组index+1位置开始拷贝到elementData从index开始的空间 System.arraycopy(elementData, index+1, elementData, index, numMoved); //size减1，并将最后一个元素置为null elementData[--size] = null; //返回被删除的元素： return oldValue;&#125;//在ArrayList的移除对象为O的元素，不返回被删除的元素：public boolean remove(Object o) &#123; //如果o==null，则遍历集合，判断哪个元素为null： if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; //快速删除，和前面的remove（index）一样的逻辑 fastRemove(index); return true; &#125; &#125; else &#123; //同理： for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;//快速删除：private void fastRemove(int index) &#123; //操作数+1 modCount++; //获取需要删除元素 到最后一个元素的长度，也就是删除元素后，后续元素移动的个数； int numMoved = size - index - 1; //如果移动元素个数大于0 ，也就是说删除的不是最后一个元素： if (numMoved &gt; 0) // 将elementData数组index+1位置开始拷贝到elementData从index开始的空间 System.arraycopy(elementData, index+1, elementData, index, numMoved); //size减1，并将最后一个元素置为null elementData[--size] = null;&#125; 3.5.4 set()由于ArrayList实现了RandomAccess, 所以具备了随机访问特性, 调用elementData()可以获取到对应元素的值；1234567891011//设置index位置的元素值了element，返回该位置的之前的值public E set(int index, E element) &#123; //检查index是否合法：判断index是否大于size rangeCheck(index); //获取该index原来的元素： E oldValue = elementData(index); //替换成新的元素： elementData[index] = element; //返回旧的元素： return oldValue;&#125; 3.5.5 get()通过elementData()方法获取对应角标元素, 在返回时候进行类型转换;1234567891011//获取index位置的元素public E get(int index) &#123; //检查index是否合法： rangeCheck(index); //获取元素： return elementData(index);&#125;//获取数组index位置的元素：返回时类型转换E elementData(int index) &#123; return (E) elementData[index];&#125; 3.5.6 modCount含义在Itr迭代器初始化时,将ArrayList的modCount属性的值赋值给了expectedModCount.通过上面的例子中, 我们可以知道当进行增删改时, modCount会随着每一次的操作而+1, modCount记录了ArrayList内发生改变的次数.当迭代器在迭代时, 会判断expectedModCount的值是否还与modCount的值保持一致, 如果不一致则抛出异常.AbstractList类当中定义的变量:1protected transient int modCount = 0; ArrayList获取迭代器对象:1234//返回一个Iterator对象，Itr为ArrayList的一个内部类，其实现了Iterator&lt;E&gt;接口public Iterator&lt;E&gt; iterator() &#123; return new java.util.ArrayList.Itr();&#125; 迭代器实现:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//Itr实现了Iterator接口，是ArrayList集合的迭代器对象private class Itr implements Iterator&lt;E&gt; &#123; //类似游标，指向迭代器下一个值的位置 int cursor; //迭代器最后一次取出的元素的位置。 int lastRet = -1; //Itr初始化时候ArrayList的modCount的值。 int expectedModCount = modCount; //利用游标，与size之前的比较，判断迭代器是否还有下一个元素 public boolean hasNext() &#123; return cursor != size; &#125; //迭代器获取下一个元素： public E next() &#123; //检查modCount是否改变： checkForComodification(); int i = cursor; //游标不会大于等于集合的长度： if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = java.util.ArrayList.this.elementData; //游标不会大于集合中数组的长度： if (i &gt;= elementData.length) throw new ConcurrentModificationException(); //游标+1 cursor = i + 1; //取出元素： return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); //检查modCount是否改变：防止并发操作集合 checkForComodification(); try &#123; //删除这个元素： java.util.ArrayList.this.remove(lastRet); //删除后，重置游标，和当前指向元素的角标 lastRet cursor = lastRet; lastRet = -1; //重置expectedModCount： expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; //并发检查： final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 3.5.7 transienttransient修饰符是什么含义?当我们序列化对象时, 如果对象中某个属性不进行序列化操作, 那么在该属性前添加transient修饰符即可实现; 例如:1private transient Object[] elementData; 那么, 为什么ArrayList不想对elementData属性进行序列化呢? elementData可是集合中保存元素的数组啊, 如果不序列化elementData属性, 那么在反序列化时候, 岂不是丢失了原先的元素?ArrayList在添加元素时, 可能会对elementData数组进行扩容操作, 而扩容后的数组可能并没有全部保存元素.例如: 我们创建了new Object[10]数组对象, 但是我们只向其中添加了1个元素, 而剩余的9个位置并没有添加元素. 当我们进行序列化时, 并不会只序列化其中一个元素, 而是将整个数组进行序列化操作, 那些没有被元素填充的位置也进行了序列化操作, 间接的浪费了磁盘的空间, 以及程序的性能.所以, ArrayList才会在elementData属性前加上transient修饰符.接下来, 我们来看下ArrayList的writeObject(), readObject():12345678910111213141516171819202122232425//序列化写入：private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; int expectedModCount = modCount; s.defaultWriteObject(); s.writeInt(size); for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;// 序列化读取：private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; s.defaultReadObject(); s.readInt(); if (size &gt; 0) &#123; ensureCapacityInternal(size); Object[] a = elementData; for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; ArrayList在序列化时会调用writeObject(), 直接将elementData写入ObjectOutputStream;而反序列化时则调用readObject(), 从ObjectInputStream获取elementData; 3.5.8 Arrays.copyOf()该方法在内部创建了一个新数组, 底层实现是调用System.arraycopy();12345678public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; original - 要复制的数组newLength - 要返回的副本的长度newType - 要返回的副本的类型 3.5.9 System.arraycopy()该方法是用了native关键字, 调用的为C++编写的底层函数.123public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); src - 源数组srcPos - 源数组中的起始位置dest - 目标数组destPos - 目标数据中的起始位置length - 要复制的数组元素的数量 3.6 LinkedList源码分析(基于JDK1.7.0_45)发现很多文章在介绍的时候, 都说LinkedList是一个环形链表结构, 头尾相连. 但, 当我开始看源码的时候, 发现并不是环形链表, 是一个直线型链表结构. 这是因为JDK1.7之前的版本是环形链表, 而到了JDK1.7以后进行了优化, 变成了直线型链表结构; 3.6.1 LinkedList基础结构在LinkedList中, 内部类Node对象最为重要, 它组成了LinkedList集合的整个链表, 分别指向上一个点, 下一个结点, 存储着集合中的元素;成员变量中, first表明是头结点, last表明是尾结点;1234567891011121314151617181920212223242526272829303132public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123; //LinkedList的元素个数： transient int size = 0; //LinkedList的头结点：Node内部类 transient java.util.LinkedList.Node&lt;E&gt; first; //LinkedList尾结点：Node内部类 transient java.util.LinkedList.Node&lt;E&gt; last; //空实现：头尾结点均为null，链表不存在 public LinkedList() &#123; &#125; //调用添加方法： public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; //节点的数据结构，包含前后节点的引用和当前节点 private static class Node&lt;E&gt; &#123; //结点元素： E item; //结点后指针 java.util.LinkedList.Node&lt;E&gt; next; //结点前指针 java.util.LinkedList.Node&lt;E&gt; prev; Node(java.util.LinkedList.Node&lt;E&gt; prev, E element, java.util.LinkedList.Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125;&#125; 3.6.2 add()LinkedList的添加方法, 主要分为2种, 一是直接添加一个元素, 二是在指定角标下添加一个元素;add(E e)底层调用linkLast(E e)方法, 就是在链表的最后面插入一个元素;add(int index, E element), 插入的角标如果==size, 则插入到链表最后; 否则, 按照角标大小插入到对应位置;.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//添加元素：添加到最后一个结点；public boolean add(E e) &#123; linkLast(e); return true;&#125;//last节点插入新元素：void linkLast(E e) &#123; //将尾结点赋值个体L: final java.util.LinkedList.Node&lt;E&gt; l = last; //创建新的结点，将新节点的前指针指向l: final java.util.LinkedList.Node&lt;E&gt; newNode = new java.util.LinkedList.Node&lt;&gt;(l, e, null); //新节点置为尾结点： last = newNode; //如果尾结点l为null：则是空集合新插入 if (l == null) //头结点也置为 新节点： first = newNode; else //l节点的后指针指向新节点： l.next = newNode; //长度+1 size++; //操作数+1 modCount++;&#125;//向对应角标添加元素：public void add(int index, E element) &#123; //检查传入的角标 是否正确： checkPositionIndex(index); //如果插入角标==集合长度，则插入到集合的最后面： if (index == size) linkLast(element); else //插入到对应角标的位置：获取此角标下的元素先 linkBefore(element, node(index));&#125;//在succ前插入 新元素e：void linkBefore(E e, java.util.LinkedList.Node&lt;E&gt; succ) &#123; //获取被插入元素succ的前指针元素： final java.util.LinkedList.Node&lt;E&gt; pred = succ.prev; //创建新增元素节点，前指针 和 后指针分别指向对应元素： final java.util.LinkedList.Node&lt;E&gt; newNode = new java.util.LinkedList.Node&lt;&gt;(pred, e, succ); succ.prev = newNode; //succ的前指针元素可能为null，为null的话说明succ是头结点，则把新建立的结点置为头结点： if (pred == null) first = newNode; else //succ前指针不为null，则将前指针的结点的后指针指向新节点： pred.next = newNode; //长度+1 size++; //操作数+1 modCount++;&#125; 对于LinkedList集合增加元素来说, 可以简单的概括为以下几点:将添加的元素转换为LinkedList的Node对象节点;增加该Node节点的前后引用, 即该Node节点的prev, next属性, 让其分别指向哪一个节点);修改该Node节点的前后Node节点中pre/next属性, 使其指向该节点. 3.6.3 remove()LinkedList的删除也提供了2种形式, 其一是通过角标删除元素, 其二就是通过对象删除元素; 不过, 无论哪种删除, 最终调用的都是unlink来实现的;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//删除对应角标的元素：public E remove(int index) &#123; checkElementIndex(index); //node()方法通过角标获取对应的元素，在后面介绍 return unlink(node(index));&#125;//删除LinkedList中的元素，可以删除为null的元素，逐个遍历LinkedList的元素，重复元素只删除第一个：public boolean remove(Object o) &#123; //如果删除元素为null： if (o == null) &#123; for (java.util.LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; //如果删除元素不为null： for (java.util.LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125;//移除LinkedList结点：remove()方法中调用E unlink(java.util.LinkedList.Node&lt;E&gt; x) &#123; //获取被删除结点的元素E： final E element = x.item; //获取被删除元素的后指针结点： final java.util.LinkedList.Node&lt;E&gt; next = x.next; //获取被删除元素的前指针结点： final java.util.LinkedList.Node&lt;E&gt; prev = x.prev; //被删除结点的 前结点为null的话： if (prev == null) &#123; //将后指针指向的结点置为头结点 first = next; &#125; else &#123; //前置结点的 尾结点指向被删除的next结点； prev.next = next; //被删除结点前指针置为null: x.prev = null; &#125; //对尾结点同样处理： if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 3.6.4 set()LinkedList的set(int index, E element)方法与add(int index,E element)的设计思路基本一致, 都是创建新Node节点, 插入到对应的角标下, 修改前后节点的prev, next属性;其中, node(int index)方法至关重要, 通过对应角标获取到对应的集合元素.可以看到, node()中是根据角标的大小是选择从前遍历还是从后遍历整个集合. 也可以间接的说明, LinkedList在随机获取元素时性能很低, 每次的获取都得从头或者从尾遍历半个集合.123456789101112131415161718192021222324252627//设置对应角标的元素：public E set(int index, E element) &#123; checkElementIndex(index); //通过node()方法，获取到对应角标的元素： java.util.LinkedList.Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125;//获取对应角标所属于的结点：java.util.LinkedList.Node&lt;E&gt; node(int index) &#123; //位运算：如果位置索引小于列表长度的一半，则从头开始遍历；否则，从后开始遍历； if (index &lt; (size &gt;&gt; 1)) &#123; java.util.LinkedList.Node&lt;E&gt; x = first; //从头结点开始遍历：遍历的长度就是index的长度，获取对应的index的元素 for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; //从集合尾结点遍历： java.util.LinkedList.Node&lt;E&gt; x = last; //同样道理： for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 3.6.5 get()1get(int index) 终于到了最后一个方法, 也是开发中最常用的方法. 其中, 核心方法node(int index)在上面已经介绍过.在通过node(int index)获取到对应节点后, 返回节点中的item属性, 该属性就是我们所保存的元素.1234567//获取相应角标的元素：public E get(int index) &#123; //检查角标是否正确： checkElementIndex(index); //获取角标所属结点的 元素值： return node(index).item;&#125; 4. 参考链接Java集合：ListJava集合：List源码详细分析]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人收藏]]></title>
    <url>%2F2018%2F09%2F22%2F%E4%B8%AA%E4%BA%BA%E6%94%B6%E8%97%8F%2F</url>
    <content type="text"><![CDATA[一、日常使用二、在线工具 markdown表格在线生成工具http://www.tablesgenerator.com/markdown_tables 16进制转文本字符串http://www.bejson.com/convert/ox2str/ 密码生成器https://suijimimashengcheng.51240.com/ 三、客户端工具 Sublime Text(可以以十六进制的形式显示文本文件)https://www.sublimetext.com/]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>收藏夹</tag>
      </tags>
  </entry>
</search>
