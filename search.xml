<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一致性Hash算法]]></title>
    <url>%2F2018%2F09%2F24%2F%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 前言后台开发过程中, 一致性Hash算法也是基础, 不做过多特殊说明, 这篇文章记录一致性Hash算法相关知识. 2. 历史演进2.1 Redis集群的使用我们在使用Redis的时候, 为了保证Redis的高可用, 提高Redis的读写性能, 最简单的方式我们会做主从复制, 组成Master-Master或者Master-Slave的形式, 或者搭建Redis集群, 进行数据的读写分离, 类似于数据库的主从复制和读写分离. 如下所示:同样类似于数据库, 当单表数据大于500W的时候需要对其进行分库分表, 当数据量很大的时候(标准可能不一样, 要看Redis服务器容量)我们同样可以对Redis进行类似的操作, 就是分库分表.假设, 我们有一个社交网站, 需要使用Redis存储图片资源, 存储的格式为键值对, key值为图片名称, value为该图片所在文件服务器的路径, 我们需要根据文件名查找该文件所在文件服务器上的路径, 数据量大概有2000W左右, 按照我们约定的规则进行分库, 规则就是随机分配, 我们可以部署8台缓存服务器, 每台服务器大概含有500W条数据, 并且进行主从复制, 示意图如下:由于规则是随机的, 所有我们的一条数据都有可能存储在任何一组Redis中, 例如上图我们用户查找一张名称为”a.png”的图片, 由于规则是随机的, 我们不确定具体是在哪一个Redis服务器上的, 因此我们需要进行1, 2, 3, 4, 4次查询才能够查询到(也就是遍历了所有的Redis服务器), 这显然不是我们想要的结果, 有了解过的小伙伴可能会想到, 随机的规则不行, 可以使用类似于数据库中的分库分表规则: 按照Hash值, 取模, 按照类别, 按照某一个字段值等等常见的规则就可以出来了, 好, 按照我们的主题, 我们就使用Hash的方式. 2.2 为Redis集群使用Hash可想而知, 如果我们使用Hash的方式, 每一张图片在进行分库的时候都可以定位到特定的服务器, 示意图如下:上图中, 假设我们查找的是”a.png”, 由于有4台服务器(排除从库), 因此公式为hash(a.png) % 4 = 2 , 可知定位到了第2号服务器, 这样的话就不会遍历所有的服务器, 大大提升了性能. 2.3 使用Hash的问题上述的方式虽然提升了性能, 我们不再需要对整个Redis服务器进行遍历, 但是, 使用上述Hash算法进行缓存时, 会出现一些缺陷, 主要体现在服务器数量变动的时候, 所有缓存的位置都要发生改变.试想一下, 如果4台缓存服务器已经不能满足我们的缓存需求, 那么我们应该怎么做呢?很简单, 多增加几台缓存服务器不就行了. 假设: 我们增加了一台缓存服务器, 那么缓存服务器的数量就由4台变成了5台. 那么原本hash(a.png) % 4 = 2 的公式就变成了hash(a.png) % 5 = ? , 可想而知这个结果肯定不是2的, 这种情况带来的结果就是当服务器数量变动时, 所有缓存的位置都要发生改变. 换句话说, 当服务器数量发生改变时, 所有缓存在一定时间内是失效的, 当应用无法从缓存中获取数据时, 则会向后端数据库请求数据.同样的, 假设4台缓存中突然有一台缓存服务器出现了故障, 无法进行缓存, 那么我们则需要将故障机器移除, 但是如果移除了一台缓存服务器, 那么缓存服务器数量从4台变为3台, 也是会出现上述的问题.所以, 我们应该想办法不让这种情况发生, 但是由于上述Hash算法本身的缘故, 使用取模法进行缓存时, 这种情况是无法避免的, 为了解决这些问题, Hash一致性算法(一致性Hash算法)诞生了. 3. 一致性Hash算法3.1 一致性Hash算法的神秘面纱一致性Hash算法也是使用取模的方法, 只是, 刚才描述的取模法是对服务器的数量进行取模, 而一致性Hash算法是对2^32取模, 什么意思呢? 简单来说, 一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环, 如假设某哈希函数H的值空间为0-2^32-1(即哈希值是一个32位无符号整形), 整个哈希环如下:整个空间按顺时针方向组织, 圆环的正上方的点代表0, 0点右侧的第一个点代表1, 以此类推, 2, 3, 4, 5, 6……直到2^32-1, 也就是说0点左侧的第一个点代表2^32-1, 0和2^32-1在零点中方向重合, 我们把这个由2^32个点组成的圆环称为Hash环.下一步将各个服务器使用Hash进行一个哈希, 具体可以选择服务器的IP或主机名作为关键字进行哈希, 这样每台机器就能确定其在哈希环上的位置, 这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下:接下来使用如下算法定位数据访问到相应服务器: 将数据key使用相同的函数Hash计算出哈希值, 并确定此数据在环上的位置, 从此位置沿环顺时针”行走”, 第一台遇到的服务器就是其应该定位到的服务器.例如我们有Object A, Object B, Object C, Object D四个数据对象, 经过哈希计算后, 在环空间上的位置如下:根据一致性Hash算法, 数据A会被定为到Node A上, B被定为到Node B上, C被定为到Node C上, D被定为到Node D上. 3.2 一致性Hash算法的容错性和可扩展性现假设Node C不幸宕机, 可以看到此时对象A, B, D不会受到影响, 只有C对象被重定位到Node D. 一般的, 在一致性Hash算法中, 如果一台服务器不可用, 则受影响的数据仅仅是此服务器到其环空间中前一台服务器(即沿着逆时针方向行走遇到的第一台服务器)之间数据, 其它不会受到影响, 如下所示:下面考虑另外一种情况, 如果在系统中增加一台服务器Node X, 如下图所示:此时对象Object A, B, D不受影响, 只有对象C需要重定位到新的Node X. 一般的, 在一致性Hash算法中, 如果增加一台服务器, 则受影响的数据仅仅是新服务器到其环空间中前一台服务器(即沿着逆时针方向行走遇到的第一台服务器)之间数据, 其它数据也不会受到影响.综上所述, 一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据, 具有较好的容错性和可扩展性. 3.3 Hash环的数据倾斜问题一致性Hash算法在服务节点太少时, 容易因为节点分部不均匀而造成数据倾斜(被缓存的对象大部分集中缓存在某一台服务器上)问题, 例如系统中只有两台服务器, 其环分布如下: 此时必然造成大量数据集中到Node A上, 而只有极少量会定位到Node B上. 为了解决这种数据倾斜问题, 一致性Hash算法引入了虚拟节点机制, 即对每一个服务节点计算多个哈希, 每个计算结果位置都放置一个此服务节点, 称为虚拟节点. 具体做法可以在服务器IP或主机名的后面增加编号来实现.例如上面的情况, 可以为每台服务器计算三个虚拟节点, 于是可以分别计算”Node A#1”, “Node A#2”, “Node A#3”, “Node B#1”, “Node B#2”, “Node B#3”的哈希值, 于是形成六个虚拟节点:同时数据定位算法不变, 只是多了一步虚拟节点到实际节点的映射, 例如定位到”Node A#1”, “Node A#2”, “Node A#3”三个虚拟节点的数据均定位到Node A上. 这样就解决了服务节点少时数据倾斜的问题. 在实际应用中, 通常将虚拟节点数设置为32甚至更大, 因此即使很少的服务节点也能做到相对均匀的数据分布. 4. 参考链接面试必备：什么是一致性Hash算法？]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2018%2F09%2F24%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. 前言后台开发过程中, Linux的熟练使用有助于提高开发效率, 自动化部署等. 这篇文章主要是记录工作中会遇到的一些有用的命令, 持续更新. 2. 常用命令2.1 网络流量监控1dstat -nf 2.2 查看端口被占用1lsof -i:8080 2.3 生成指定大小的文件12// 生成100M的文件dd if=/dev/zero of=filename bs=1M count=100]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java字符串小数点处理]]></title>
    <url>%2F2018%2F09%2F24%2FJava%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B0%8F%E6%95%B0%E7%82%B9%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 前言今天帮同学做题的时候涉及到利用小数点切分字符串, 感觉以后在后台开发中可能会遇到这个问题, 所以记录一下. 2. 概述错误的处理方式, 编译能通过, 运行时且不会报错, 但是输出结果是0, 123String input = "hello.java";String[] outputs = input.split(".");System.out.println(outputs.length); 正确的处理方式 123String input = "hello.java";String[] outputs = input.split("\\.");System.out.println(outputs.length); 3. 解释首先抛出来2个问题:问题1: 小数点不是转义字符, 为什么不能直接用split(.)?问题2: 为什么非要加2个反斜杠, 只加1个不行吗? 下面给出解释解答问题1: split里面的参数是正则表达式, 在正则表达式中, 小数点表示可以匹配任意字符, 所以不能直接用小数点.解答问题2: 由于问题1已经解决, 很自然的想法就是加上反斜杠来进行转义, 而且这个转义语法其实只有正则表达式能够识别, Java语言中并不支持这种转义, 所以只加一个反斜杠是不行的, 再通俗点说就是, 我要告诉正则表达式2个字符, 一个是反斜杠, 一个是小数点, 反斜杠由于是特殊字符, 所以我要通过转义了告诉正则表达式, 而小数点不是特殊字符, 所以我可以直接告诉正则表达式, 最后的结果就是两个反斜杠+小数点.]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java本地方法]]></title>
    <url>%2F2018%2F09%2F24%2FJava%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 前言之前在公司开发的时候, 需要用到内部的组件, 尽管提供了jar包, 但是jar包底层是通过Java本地方法实现的, 所以仅仅导入jar包并不能正常使用, 还需要安装内部组件的环境. 所以写这篇文章记录Java本地方法的使用, 帮助自己熟悉这块的使用. 2. 基础使用基于Linux环境, 这个章节简单介绍如何实现一个Java本地方法. 第一步: 建立一个普通的java类, 添加一个方法, 在方法返回值前加 native 1234public class ClassMethod &#123; //本地方法可以是静态的也可以是非静态的； public static native void greeting();&#125; 第二步: 编译这个java类, 得到ClassMethod.class文件 1javac ClassMethod.java 第三步: 找到当前类编译的.class文件, 使用命令行生成.h文件 1javah ClassMethod 第四步: 查看ClassMethod.h 123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class ClassMethod */#ifndef _Included_ClassMethod#define _Included_ClassMethod#ifdef __cplusplusextern "C" &#123;#endif/* * Class: ClassMethod * Method: greeting * Signature: ()V */JNIEXPORT void JNICALL Java_ClassMethod_greeting (JNIEnv *, jclass);#ifdef __cplusplus&#125;#endif#endif 第五步: 新建cpp文件, 并写逻辑代码(我这边命名为main.cpp,其实是可以随意命名的) 12345#include "ClassMethod.h"#include &lt;stdio.h&gt;JNIEXPORT void JNICALL Java_ClassMethod_greeting(JNIEnv *, jclass)&#123; printf("hello world!");&#125; 第六步: 将main.cpp文件和ClassMethod.h放到一个目录下, 并执行指令生成动态链接库.so文件 1gcc -fPIC -I /home/ganlu/java/jdk1.8.0_144/include/ -I /home/ganlu/java/jdk1.8.0_144/include/linux/ -shared -o libHello.so main.cpp 第七步: 将动态链接库复制到java项目中 123456789101112public class ClassMethod &#123; static &#123; System.load("/home/ganlu/java/workplace/libHello.so"); &#125; //本地方法可以是静态的也可以是非静态的； public static native void greeting(); public static void main(String args[])&#123; greeting(); &#125;&#125; 第八步: 重新编译ClassMethod.java并执行 12javac ClassMethod.javajava ClassMethod 运行结果: 1hello world! 3. 几个问题3.1 动态链接库我这边动态链接库的加载是通过绝对路径的指定来实现的, 而实际中, 这种绝对路径的指定肯定是不好的. 1System.load("/home/ganlu/java/workplace/libHello.so"); 网上流传比较多的一种做法是如下(这里要注意, .so文件的命名一定要规范, 以lib开头, 以.so结尾): 1System.loadLibrary("Hello"); 但是用这种方法直接运行, 会报错. 12345Exception in thread "main" java.lang.UnsatisfiedLinkError: no Hello in java.library.path at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1867) at java.lang.Runtime.loadLibrary0(Runtime.java:870) at java.lang.System.loadLibrary(System.java:1122) at ClassMethod.&lt;clinit&gt;(ClassMethod.java:4) 3.1.1 解决方法一:通过Java运行参数指定java.library.path1java -Djava.library.path=. ClassMethod 3.1.2 解决方法二:通过配置 LD_LIBRARY_PATH 环境变量123sudo gedit /etc/profileexport LD_LIBRARY_PATH=/home/ganlu/java/workplace 3.2 工作流程图 3.3 常见异常如果出现以下异常, 则说明.so文件不对, 是因为java 程序在调用.so时候, 不能找到native method 方法的实现.主要是因为在.so中, 可能xxx.h头文件中的接口名和xxx.cpp源文件中的实现函数名不一致导致的. 123Exception in thread "main" java.lang.UnsatisfiedLinkError: test.ClassMethod.greeting()V at test.ClassMethod.greeting(Native Method) at test.ClassMethod.main(ClassMethod.java:11) 4. 参考链接Java native 本地方法调用java 本地方法（JNI）Exception in thread “main” java.lang.UnsatisfiedLinkError: xxx()V]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java程序启动时指定外部依赖jar包]]></title>
    <url>%2F2018%2F09%2F24%2FJava%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%97%B6%E6%8C%87%E5%AE%9A%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96jar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[1. 前言Java程序启动, 经常会遇到需要指定外部依赖jar包的情况, 在学校开发的时候, 不需要考虑那么多, 一般是通过修改配置文件实现的, 但是这种做法是可能会对服务器上运行的其他程序造成影响的, 所以写这篇博客, 记录一下常用做法. 2. 常用做法2.1 方法一: 使用Bootstrap Classloader来加载我们可以在运行时使用如下参数： -Xbootclasspath:完全取代系统Java classpath.最好不用.-Xbootclasspath/a: 在系统class加载后加载. 一般用这个.-Xbootclasspath/p: 在系统class加载前加载,注意使用, 和系统类冲突就不好了. 1java -Xbootclasspath/a: some.jar:some2.jar: -jar test.jar 我个人并不推荐这个做法, 因为当jar包很多的时候, 这个得一个个指定, 并不好用. 2.2 方法二: 使用Extension Classloader来加载首先介绍下java.ext.dirs参数的使用和环境变量:java中系统属性java.ext.dirs指定的目录由ExtClassLoader加载器加载如果您的程序没有指定该系统属性(-Djava.ext.dirs=sss/lib), 那么该加载器默认加载\$JAVA_HOME/lib/ext目录下的所有jar文件但如果你手动指定系统属性且忘了把\$JAVA_HOME/lib/ext路径给加上, 那么ExtClassLoader不会去加载\$JAVA_HOME/lib/ext下面的jar文件, 这意味着你将失去一些功能, 例如java自带的加解密算法实现. 一般命令行如下: 1java -Djava.ext.dirs=$JAVA_HOME/jre/lib/ext:/home/ganlu/dir -jar test.jar 我一般用这种方式. 并且一定要记得加上\$JAVA_HOME/jre/lib/ext 3. 说明网上流传的还有诸如把jar包放到环境变量下, 或者修改环境变量, 个人并不倾向于使用, 因为会对其他应用程序造成影响. 4. 参考链接java -jar命令运行jar包时指定外部依赖jar包]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST服务与RESTful风格]]></title>
    <url>%2F2018%2F09%2F24%2FREST%E6%9C%8D%E5%8A%A1%E4%B8%8ERESTful%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[1. 前言进行后台开发的时候, 我们经常说, 我们的接口是Restful的风格, 那Restful到底是什么呢?Restful风格有哪些特点呢?REST又跟Restful有什么关系?这篇文章主要是记录Restful API风格及其相关的一些知识点. 2. 什么是RESTREST: representational state transfer 表述性状态转移, 是一种架构风格.它是轻量级,跨平台,跨语言的架构设计; 它是一种设计风格,不是一种标准, 是一种思想. 3. REST原则 网络上的所有事物都被抽象为资源 每个资源都有一个唯一的资源标识符 同一个资源具有多种表现形式(xml,json等) 对资源的各种操作不会改变资源标识符 所有的操作都是无状态的 4. 关于RESTfulRESTful: 遵守了REST原则的web服务理解: REST与RESTful相比, 多了一个ful, 就英语层面来说是一个形容词, RESTful翻译为中文为: “REST式的”.是REST式的是什么意思呢?意思是 是REST式的应用, REST风格的web服务也是REST式的应用, REST式的web服务是一种ROA(The Resource-Oriented Architecture)(面向资源的架构). 5. 为什么会出现RESTful 在RESTful之前的操作:http://127.0.0.1/user/query/1 GET 根据用户id查询用户数据http://127.0.0.1/user/save POST 新增用户http://127.0.0.1/user/update POST 修改用户信息http://127.0.0.1/user/delete GET/POST 删除用户信息RESTful用法:http://127.0.0.1/user/1 GET 根据用户id查询用户数据http://127.0.0.1/user POST 新增用户http://127.0.0.1/user PUT 修改用户信息http://127.0.0.1/user DELETE 删除用户信息 之前的操作是没有问题的,大神认为是有问题的,有什么问题呢?你每次请求的接口或者地址,都在做描述,例如查询的时候用了query,新增的时候用了save,其实完全没有这个必要,我使用了get请求,就是查询.使用post请求,就是新增的请求,我的意图很明显,完全没有必要做描述,这就是为什么有了RESTful. 6. 如何设计Restful风格的API6.1 路径设计在RESTdul架构中, 每个网址代表一种资源(resource), 所以网址中不能有动词, 只能有名词, 而且所用的名词往往与数据库的表名对应, 一般来说, 数据库中的表都是同种记录的”集合”(collection), 所以API中的名词也应该使用复数.举例来说, 有一个API提供动物园(zoo)的信息, 还包括各种动物和雇员的信息, 则它的路径应该设计成下面这样. 123https://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/employees 6.2 HTTP动词设计对于资源的具体操作类型, 由HTTP动词表示, 常用的HTTP动词如下: 请求方式 含义 GET 获取资源（一项或多项） POST 新建资源 PUT 更新资源（客户端提供改变后的完整资源） DELETE 删除资源 如何通过路径和http动词获悉要调用的功能: 请求方式 含义 GET /zoos 列出所有动物园 POST /zoos 新建一个动物园 GET /zoos/ID 获取某个指定动物园的信息 PUT /zoos/ID 更新某个指定动物园的信息（提供该动物园的全部信息） DELETE /zoos/ID 删除某个动物园 GET /zoos/ID/animals 列出某个指定动物园的所有动物 DELETE /zoos/ID/animals/ID 删除某个指定动物园的指定动物 6.3 常用状态码200 OK - [GET]: 服务器成功返回用户请求的数据, 该操作是幂等的.201 CREATED - [POST/PUT/PATCH]: 用户新建或修改数据成功.202 Accepted - []:表示一个请求已经进入后台排队(异步任务)204 NO CONTENT - [DELETE]: 用户删除数据成功.400 INVALID REQUEST - [POST/PUT/PATCH]: 用户发出的请求有错误, 服务器没有进行新建或修改数据的操作.401 Unauthorized - []: 表示用户没有权限(令牌, 用户名, 密码错误).403 Forbidden - []: 表示用户得到授权(与401错误相对), 但是访问是被禁止的.404 NOT FOUND - []: 用户发出的请求针对的是不存在的记录, 服务器没有进行操作, 该操作是幂等的.406 Not Acceptable - [GET]: 用户请求的格式不可得(比如用户请求JSON格式, 但是只有XML格式).410 Gone -[GET]: 用户请求的资源被永久删除, 且不会再得到的.422 Unprocesable entity - [POST/PUT/PATCH]: 当创建一个对象时, 发生一个验证错误.500 INTERNAL SERVER ERROR - [*]: 服务器发生错误, 用户将无法判断发出的请求是否成功. 6.4 版本号应该将API的版本号放入URL 1如: https://api.example.com/v1/ 另一种做法是, 将版本号放在HTTP头信息中, 但不如放入URL方便和直观. Github采用这种做法. 6.5 其他服务器返回的数据格式, 应该尽量使用JSON, 避免使用XML. 7. 参考链接什么是rest？什么是restful？它们之间是什么关系【Restful】三分钟彻底了解Restful最佳实践理解并设计rest/restful风格接口]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字面量, 符号引用与直接引用]]></title>
    <url>%2F2018%2F09%2F24%2F%E5%AD%97%E9%9D%A2%E9%87%8F%2C%20%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E4%B8%8E%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 前言学习JVM的时候, 总碰到字面量, 符号引用与直接引用这几个词, 理解的迷迷糊糊的. 这里总结一下. 2. 字面量百度百科解释: 在计算机科学中, 字面量(literal)是用于表达源代码中一个固定值的表示法(notation). 几乎所有计算机编程语言都具有对基本值的字面量表示, 诸如: 整数, 浮点数以及字符串; 而有很多也对布尔类型和字符类型的值也支持字面量表示; 还有一些甚至对枚举类型的元素以及像数组, 记录和对象等复合类型的值也支持字面量表示法.很抽象, 举个例子就明白了. 12int i = 1;把整数1赋值给int型变量i，整数1就是Java字面量，String s = "abc";中的abc也是字面量。 3. 符号引用符号引用以一组符号来描述所引用的目标, 符号可以是任何形式的字面量, 只要使用时能够无歧义的定位到目标即可. 例如, 在Java中, 一个Java类将会编译成一个class文件. 在编译时, Java类并不知道所引用的类的实际地址, 因此只能使用符号引用来代替. 比如org.simple.People类引用了org.simple.Language类, 在编译时People类并不知道Language类的实际内存地址, 因此只能使用符号org.simple.Language来表示Language类的地址. 4. 直接引用直接引用可以是: 直接指向目标的指针.(个人理解为: 指向方法区中类对象, 类变量和类方法的指针) 相对偏移量. (指向实例的变量, 方法的指针) 一个间接定位到对象的句柄. 我觉得直接引用说白了, 就是程序运行时可以定位到引用的东西(类, 对象, 变量或者方法等)的地址. 5. 参考链接java – JVM的符号引用和直接引用Java字面量（Java直接量）和符号引用走进java_符号引用与直接引用]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS]]></title>
    <url>%2F2018%2F09%2F24%2FHTTPS%2F</url>
    <content type="text"><![CDATA[1. 前言超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息, HTTP协议以明文方式发送内容, 不提供任何方式的数据加密, 如果攻击者截取了Web浏览器和网站服务器之间的传输报文, 就可以直接读懂其中的信息, 因此, HTTP协议不适合传输一些敏感信息, 比如: 信用卡号, 密码等支付信息.为了解决HTTP协议的这一缺陷, 需要使用另一种协议: 安全套接字层超文本传输协议HTTPS, 为了数据传输的安全, HTTPS在HTTP的基础上加入了SSL协议, SSL依靠证书来验证服务器的身份, 并为浏览器和服务器之间的通信加密. 2. 基本概念HTTP: 是互联网上应用最为广泛的一种网络协议, 是一个客户端和服务器端请求和应答的标准(TCP), 用于从WWW服务器传输超文本到本地浏览器的传输协议, 它可以使浏览器更加高效, 使网络传输减少.HTTPS: 是以安全为目标的HTTP通道, 简单讲是HTTP的安全版, 即HTTP下加入SSL层, HTTPS的安全基础是SSL, 因此加密的详细内容就需要SSL.HTTPS协议的主要作用可以分为两种: 一种是建立一个信息安全通道, 来保证数据传输的安全; 另一种就是确认网站的真实性. 3. HTTP与HTTPS的区别HTTP协议传输的数据都是未加密的, 也就是明文的, 因此使用HTTP协议传输隐私信息非常不安全, 为了保证这些隐私数据能加密传输, 于是网景公司设计了SSL(Secure Sockets Layer)协议用于对HTTP协议传输的数据进行加密, 从而就诞生了HTTPS. 简单来说, HTTPS协议是由SSL+HTTP协议构建的可进行加密传输, 身份认证的网络协议, 要比http协议安全.HTTPS和HTTP的区别主要如下: https协议需要到ca申请证书, 一般免费证书较少, 因而需要一定费用. http是超文本传输协议, 信息是明文传输, https则是具有安全性的ssl加密传输协议. http和https使用的是完全不同的连接方式, 用的端口也不一样, 前者是80, 后者是443. http的连接很简单, 是无状态的; HTTPS协议是由SSL+HTTP协议构建的可进行加密传输, 身份认证的网络协议, 比http协议安全. 4. HTTPS的工作原理我们都知道HTTPS能够加密信息, 以免敏感信息被第三方获取, 所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议.客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤, 如图所示. 客户使用https的URL访问Web服务器, 要求与Web服务器建立SSL连接. Web服务器收到客户端请求后, 会将网站的证书信息(证书中包含公钥)传送一份给客户端. 客户端的浏览器与Web服务器开始协商SSL连接的安全等级, 也就是信息加密的等级. 客户端的浏览器根据双方同意的安全等级, 创建会话密钥, 然后利用网站的公钥将会话密钥加密, 并传送给网站. Web服务器利用自己的私钥解密出会话密钥. Web服务器利用会话密钥加密与客户端之间的通信. 5. HTTPS的优点尽管HTTPS并非绝对安全, 掌握根证书的机构, 掌握加密算法的组织同样可以进行中间人形式的攻击, 但HTTPS仍是现行架构下最安全的解决方案, 主要有以下几个好处: 使用HTTPS协议可认证用户和服务器, 确保数据发送到正确的客户机和服务器; HTTPS协议是由SSL+HTTP协议构建的可进行加密传输, 身份认证的网络协议, 要比http协议安全, 可防止数据在传输过程中不被窃取, 改变, 确保数据的完整性. HTTPS是现行架构下最安全的解决方案, 虽然不是绝对安全, 但它大幅增加了中间人攻击的成本. 谷歌曾在2014年8月份调整搜索引擎算法, 并称”比起同等HTTP网站, 采用HTTPS加密的网站在搜索结果中的排名将会更高”. 6. HTTPS的缺点虽然说HTTPS有很大的优势, 但其相对来说, 还是存在不足之处的: HTTPS协议握手阶段比较费时, 会使页面的加载时间延长近50%, 增加10%到20%的耗电; HTTPS连接缓存不如HTTP高效, 会增加数据开销和功耗, 甚至已有的安全措施也会因此而受到影响; SSL证书需要钱, 功能越强大的证书费用越高, 个人网站, 小网站没有必要一般不会用. SSL证书通常需要绑定IP, 不能在同一IP上绑定多个域名, IPv4资源不可能支撑这个消耗. HTTPS协议的加密范围也比较有限, 在黑客攻击, 拒绝服务攻击, 服务器劫持等方面几乎起不到什么作用. 最关键的, SSL证书的信用链体系并不安全, 特别是在某些国家可以控制CA根证书的情况下, 中间人攻击一样可行. 7. 参考链接HTTP与HTTPS的区别【HTTP】HTTPS 原理详解]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVCC多版本并发控制]]></title>
    <url>%2F2018%2F09%2F24%2FMVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1. 前言学习数据库事务的时候, 提到MVCC, 通过MVCC可以在无锁的情况下, 避免不可重复读, 这篇文章主要是介绍MVCC的原理. 2. MVCC简介MVCC(Multiversion Concurrency Control),即多版本并发控制技术,它使得大部分支持行锁的事务引擎,不再单纯的使用行锁来进行数据库的并发控制,取而代之的是,把数据库的行锁与行的多个版本结合起来,只需要很小的开销,就可以实现非锁定读,从而大大提高数据库系统的并发性能. 3. 实现原理MVCC可以提供基于某个时间点的快照,使得对于事务看来,总是可以提供与事务开始时刻相一致的数据,而不管这个事务执行的时间有多长.所以在不同的事务看来,同一时刻看到的相同行的数据可能是不一样的,即一个行可能有多个版本.是否听起来不可思议呢?原来,为了实现MVCC, innodb对每一行都加上了两个隐含的列,其中一列存储行被更新的”时间”,另外一列存储行被删除的”时间”. 但是innodb存储的并不是绝对的时间,而是与时间对应的数据库系统的版本号,每当一个事务开始的时候,innodb都会给这个事务分配一个递增的版本号,所以版本号也可以被认为是事务号.对于每一个”查询”语句,innodb都会把这个查询语句的版本号同这个查询语句遇到的行的版本号进行对比,然后结合不同的事务隔离等级,来决定是否返回该行.下面分别以select, delete, insert, update语句来说明: SELECT对于select语句, 只有同时满足了下面两个条件的行, 才能被返回:a. 行的被修改版本号小于或者等于该事务号b. 行的被删除版本号要么没有被定义,要么大于事务的版本号:行的删除版本号如果没有被定义,说明该行没有被删除过;如果删除版本号大于当前事务的事务号,说明该行是被该事务后面启动的事务删除的,由于是repeatable read隔离等级,后开始的事务对数据的影响不应该被先开始的事务看见,所以该行应该被返回. INSERT对新插入的行,行的更新版本被修改为该事务的事务号 DELETE对于删除,innodb直接把该行的被删除版本号设置为当前的事务号,相当于标记为删除,而不是实际删除 UPDATE在更新行的时候,innodb会把原来的行复制一份到回滚段中,并把当前的事务号作为该行的更新版本 4. MVCC的优缺点上述策略的结果就是,在读取数据的时候,innodb几乎不用获得任何锁, 每个查询都通过版本检查,只获得自己需要的数据版本,从而大大提高了系统的并发度.这种策略的缺点是,为了实现多版本,innodb必须对每行增加相应的字段来存储版本信息,同时需要维护每一行的版本信息,而且在检索行的时候,需要进行版本的比较,因而降低了查询的效率;innodb还必须定期清理不再需要的行版本,及时回收空间,这也增加了一些开销. 5. 参考链接深入理解MVCC多版本并发控制]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库事务]]></title>
    <url>%2F2018%2F09%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[1. 前言后台开发过程中, 与数据库打交道是日常操作, 为了提高代码质量和程序性能, 数据库事务是必须理解深刻的, 这篇文章主要是记录数据库事务相关的概念和知识. 2. 事务2.1 什么是事务事务就是DBMS当中用户程序的任何一次执行, 事务是DBMS能看到的基本修改单元.事务是指对系统进行的一组操作, 为了保证系统的完整性, 事务需要具有ACID特性. 2.2 为什么要有事务事务的产生,其实是为了当应用程序访问数据库的时候,事务能够简化我们的编程模型,不需要我们去考虑各种各样的潜在错误和并发问题.可以想一下当我们使用事务时,要么提交,要么回滚,我们不会去考虑网络异常了,服务器宕机了,同时更改一个数据怎么办对吧?因此事务本质上是为了应用层服务的.而不是伴随着数据库系统天生就有的. 2.3 ACID特性2.3.1 原子性(Atomic)事务是一个完整的操作. 事务的各步操作是不可分的(原子的); 要么都执行,要么都不执行. 2.3.2 一致性(Consistency)当事务完成时, 数据必须处于一致状态. 即应用系统从一个正确的状态到另一个正确的状态. 2.3.3 隔离性(Isolation)对数据进行修改的所有并发事务是彼此隔离的, 这表明事务必须是独立的, 它不应以任何方式依赖于或影响其他事务. 2.3.4 持久性(Durability)事务完成后, 它对数据库的修改被永久保持, 事务日志能够保持事务的永久性. 2.4 隔离性详解2.4.1 隔离级别事务的隔离级别从低到高有:Read Uncommitted: 最低的隔离级别, 什么都不需要做, 一个事务可以读到另一个事务未提交的结果. 所有的并发事务问题都会发生.Read Committed: 只有在事务提交后, 其更新结果才会被其他事务看见. 可以解决脏读问题.Repeated Read: 在一个事务中, 对于同一份数据的读取结果总是相同的, 无论是否有其他事务对这份数据进行操作, 以及这个事务是否提交. 可以解决脏读, 不可重复读.Serialization: 事务串行化执行, 隔离级别最高, 牺牲了系统的并发性. 可以解决并发事务的所有问题.通常, 在工程实践中, 为了性能的考虑会对隔离性进行折中.其中只有serialization实现隔离性所有要求, 真正实现事务的隔离性.但考虑到实践, 为了性能, 数据库厂商做出了这方面的妥协, 让使用者可以选择隔离的级别.不同的隔离级别可以解决不同阶段的问题, 是层层递进, 逐渐增强的关系. 2.4.2 隔离性要解决的问题隔离性为了解决的问题主要有三个(将事务的隔离级别和问题联系在一起理解): 脏读(Drity Read): 事务A修改了一个数据, 但未提交, 事务B读到了事务A未提交的更新结果, 如果事务A提交失败, 事务B读到的就是脏数据. Read Committed可以解决脏读问题, 但仍存在以下两种问题. 不可重复读(Non-repeatable read): 在同一个事务中, 对于同一份数据读取到的结果不一致. 比如, 事务B在事务A提交前读到的结果, 和提交后读到的结果可能不同. 不可重复读出现的原因就是事务并发修改记录, 要避免这种情况, 最简单的方法就是对要修改的记录加锁, 这导致锁竞争加剧, 影响性能.(另一种方法是通过MVCC可以在无锁的情况下, 避免不可重复读.) Repeated Read可以解决不可重复读问题和脏读问题, 但仍无法解决下面的问题. 幻读(Phantom Read): 在同一个事务中, 同一个查询多次返回的结果不一致. 事务A新增了一条记录, 事务B在事务A提交前后各执行了一次查询操作, 发现后一次比前一次多了一条记录. 幻读仅指由于并发事务增加记录导致的问题, 这个不能像不可重复读通过记录加锁解决, 因为对于新增的记录根本无法加锁. 需要将事务串行化, 才能避免幻读. Serialization解决了以上所有问题, 但是性能效率较低. 通常来说, 事务隔离级别越低, 所需持有锁的时间也就越短, 并发性能也就越好. 3.参考链接如何理解数据库事务中的一致性的概念？事务的特性：事务必须具备以下四个属性，简称ACID事务的隔离性理解]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并行和并发的区别]]></title>
    <url>%2F2018%2F09%2F24%2F%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1. 前言并行和并发的区别, 一张图足以说明问题.concurrent: 并发parallel: 并行 2. 并行和并发的区别什么是并发?并发:指应用能够交替执行不同的任务,例:吃完饭-&gt;喝水 喝完水-&gt;睡觉 一觉醒来-&gt;吃饭……什么是并行?并行:指应用能够同时执行不同的任务,例:吃饭的时候可以边吃饭边打电话,这两件事情可以同时执行两者区别:一个是交替执行,一个是同时执行. 3. 参考链接什么是并行、并发,两者区别]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2018%2F09%2F24%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[1. 前言作为一名后台开发人员, 提供服务给用户或者作为用户去请求服务是日常操作, 而其中用的最多的协议也是HTTP协议. 这篇文章主要是记录HTTP协议相关的内容. 2. HTTP协议2.1 什么是HTTP协议?协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则, 超文本传输协议(HTTP)是一种通信协议, 它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器目前我们使用的是HTTP/1.1 版本 2.2 URLURL(Uniform Resource Locator) 地址用于描述一个网络上的资源, 基本格式如下: 1234567schema://host[:port#]/path/.../[?query-string][#anchor]scheme 指定低层使用的协议(例如：http, https, ftp)host HTTP服务器的IP地址或者域名port# HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如http://www.cnblogs.com:8080/path 访问资源的路径query-string 发送给http服务器的数据anchor 锚 实例 123456http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuffSchema: httphost: www.mywebsite.compath: /sj/test/test.aspxQuery String: name=sviergn&amp;x=trueAnchor: stuff 2.3 HTTP协议是无状态的HTTP协议是无状态的, 同一个客户端的这次请求和上次请求是没有对应关系, 对http服务器来说, 它并不知道这两个请求来自同一个客户端. 为了解决这个问题, Web程序引入了Cookie机制来维护状态. 2.4 打开一个网页需要浏览器发送很多次Request 当你在浏览器输入URL http://www.cnblogs.com 的时候, 浏览器发送一个Request去获取 http://www.cnblogs.com 的html. 服务器把Response发送回给浏览器. 浏览器分析Response中的 HTML, 发现其中引用了很多其他文件, 比如图片, CSS文件, JS文件. 浏览器会自动再次发送Request去获取图片, CSS文件, 或者JS文件. 等所有的文件都下载成功后. 网页就被显示出来了. 2.5 HTTP消息的结构2.5.1 Request 消息的结构先看Request 消息的结构, Request 消息分为3部分, 第一部分叫Request line, 第二部分叫Request header, 第三部分是body. header和body之间有个空行, 结构如下图.第一行中的Method表示请求方法,比如”POST”,”GET”, Path-to-resoure表示请求的资源, Http/version-number 表示HTTP协议的版本号当使用的是”GET” 方法的时候, body是为空的比如我们打开博客园首页的request 如下 12GET http://www.cnblogs.com/ HTTP/1.1Host: www.cnblogs.com 2.5.2 Response 消息的结构再看Response消息的结构, 和Request消息的结构基本一样. 同样也分为三部分, 第一部分叫Response line, 第二部分叫Response header, 第三部分是body. header和body之间也有个空行, 结构如下图.HTTP/version-number表示HTTP协议的版本号 2.5.3 GET和POST方法的区别Http协议定义了很多与服务器交互的方法, 最基本的有4种, 分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源, 而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查, 改, 增, 删4个操作. 我们最常见的就是GET和POST了. GET一般用于获取/查询资源信息, 而POST一般用于更新资源信息.我们看看GET和POST的区别: GET提交的数据会放在URL之后, 以?分割URL和传输数据, 参数之间以&amp;相连, 如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中. GET提交的数据大小有限制(因为浏览器对URL的长度有限制), 而POST方法提交的数据没有限制. GET方式需要使用Request.QueryString来取得变量的值, 而POST方式通过Request.Form来获取变量的值. GET方式提交数据, 会带来安全问题, 比如一个登录页面, 通过GET方式提交数据时, 用户名和密码将出现在URL上, 如果页面可以被缓存或者其他人可以访问这台机器, 就可以从历史记录获得该用户的账号和密码. 2.5.4 状态码Response 消息中的第一行叫做状态行, 由HTTP协议版本号, 状态码, 状态消息 三部分组成.状态码用来告诉HTTP客户端, HTTP服务器是否产生了预期的Response.HTTP/1.1中定义了5类状态码, 状态码由三位数字组成, 第一个数字定义了响应的类别1XX 提示信息 - 表示请求已被成功接收, 继续处理2XX 成功 - 表示请求已被成功接收, 理解, 接受3XX 重定向 - 要完成请求必须进行更进一步的处理4XX 客户端错误 - 请求有语法错误或请求无法实现5XX 服务器端错误 - 服务器未能实现合法的请求 2.6 HTTP Request header2.6.1 Cache 头域If-Modified-Since作用: 把浏览器端缓存页面的最后修改时间发送到服务器去, 服务器会把这个时间与服务器上实际文件的最后修改时间进行对比. 如果时间一致, 那么返回304, 客户端就直接使用本地缓存文件. 如果时间不一致, 就会返回200和新的文件内容. 客户端接到之后, 会丢弃旧文件, 把新文件缓存起来, 并显示在浏览器中.例如：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMTIf-None-Match作用: If-None-Match和ETag一起工作, 工作原理是在HTTP Response中添加ETag信息. 当用户再次请求该资源时, 将在HTTP Request 中加入If-None-Match信息(ETag的值). 如果服务器验证资源的ETag没有改变(该资源没有更新), 将返回一个304状态告诉客户端使用本地缓存文件. 否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能例如: If-None-Match: “03f2b33c0bfcc1:0”Pragma作用: 防止页面被缓存, 在HTTP/1.1版本中, 它和Cache-Control:no-cache作用一模一样Pargma只有一个用法, 例如: Pragma: no-cache注意: 在HTTP/1.0版本中, 只实现了Pragema:no-cache, 没有实现Cache-ControlCache-Control作用: 这个是非常重要的规则. 这个用来指定Response-Request遵循的缓存机制. 各个指令含义如下:Cache-Control:Public 可以被任何缓存所缓存Cache-Control:Private 内容只缓存到私有缓存中Cache-Control:no-cache 所有内容都不会被缓存 2.6.2 Client 头域Accept作用: 浏览器端可以接受的媒体类型例如: Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档如果服务器无法返回text/html类型的数据,服务器应该返回一个406错误(non acceptable)通配符 代表任意类型例如 Accept: /* 代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个Accept-Encoding作用: 浏览器申明自己接收的编码方法, 通常指定压缩方法, 是否支持压缩, 支持什么压缩方法(gzip，deflate), (注意: 这不是只字符编码);例如: Accept-Encoding: gzip, deflateAccept-Language作用: 浏览器申明自己接收的语言.语言跟字符集的区别:中文是语言, 中文有多种字符集, 比如big5, gb2312, gbk等等;例如: Accept-Language: en-usUser-Agent作用: 告诉HTTP服务器, 客户端使用的操作系统和浏览器的名称和版本.我们上网登陆论坛的时候, 往往会看到一些欢迎信息, 其中列出了你的操作系统的名称和版本, 你所使用的浏览器的名称和版本, 这往往让很多人感到很神奇, 实际上, 服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统, 浏览器和其它属性告诉服务器.例如: User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E)Accept-Charset作用: 浏览器申明自己接收的字符集, 这就是本文前面介绍的各种字符集和字符编码, 如gb2312, utf-8(通常我们说Charset包括了相应的字符编码方案); 2.6.3 Cookie/Login 头域Cookie作用: 最重要的header, 将cookie的值发送给HTTP 服务器 2.6.4 Entity头域Content-Length作用: 发送给HTTP服务器数据的长度.例如: Content-Length: 38Content-Type例如：Content-Type: application/x-www-form-urlencoded 2.6.5 Miscellaneous 头域Referer作用: 提供了Request的上下文信息的服务器, 告诉服务器我是从哪个链接过来的, 比如从我主页上链接到一个朋友那里, 他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站.例如: Referer:http://translate.google.cn/?hl=zh-cn&amp;tab=wT 2.6.6 Transport 头域Connection例如: Connection: keep-alive当一个网页打开完成后, 客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭, 如果客户端再次访问这个服务器上的网页, 会继续使用这一条已经建立的连接例如: Connection: close代表一个Request完成后, 客户端和服务器之间用于传输HTTP数据的TCP连接会关闭, 当客户端再次发送Request, 需要重新建立TCP连接.Host(发送请求时，该报头域是必需的)作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号, 它通常从HTTP URL中提取出来的例如: 我们在浏览器中输入: http://www.guet.edu.cn/index.html浏览器发送的请求消息中, 就会包含Host请求报头域, 如下:Host: http://www.guet.edu.cn此处使用缺省端口号80, 若指定了端口号, 则变成: Host: 指定端口号 2.7 HTTP Response header2.7.1 Cache 头域Date作用: 生成消息的具体时间和日期例如: Date: Sat, 11 Feb 2012 11:35:14 GMTExpires作用: 浏览器会在指定过期时间内使用本地缓存例如: Expires: Tue, 08 Feb 2022 11:35:14 GMTVary例如: Vary: Accept-Encoding 2.7.2 Cookie/Login 头域P3P作用: 用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题例如: P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP CORSet-Cookie作用: 非常重要的header, 用于把cookie 发送到客户端浏览器, 每一个写入cookie都会生成一个Set-Cookie.例如: Set-Cookie: sc=4c31523a; path=/; domain=.acookie.taobao.com 2.7.3 Entity头域ETag作用: 和If-None-Match 配合使用例如: ETag: “03f2b33c0bfcc1:0”Last-Modified作用: 用于指示资源的最后修改日期和时间.例如: Last-Modified: Wed, 21 Dec 2011 09:09:10 GMTContent-Type作用:WEB服务器告诉浏览器自己响应的对象的类型和字符集,例如:Content-Type: text/html; charset=utf-8Content-Type:text/html;charset=GB2312Content-Type: image/jpegContent-Length指明实体正文的长度, 以字节方式存储的十进制数字来表示. 在数据下行的过程中, Content-Length的方式要预先在服务器中缓存所有数据, 然后所有数据再一股脑儿地发给客户端.例如: Content-Length: 19847Content-EncodingWEB服务器表明自己使用了什么压缩方法(gzip，deflate)压缩响应中的对象.例如: Content-Encoding: gzipContent-Language作用: WEB服务器告诉浏览器自己响应的对象的语言者例如: Content-Language:da 2.7.4 Miscellaneous 头域Server作用: 指明HTTP服务器的软件信息例如:Server: Microsoft-IIS/7.5X-AspNet-Version作用: 如果网站是用ASP.NET开发的, 这个header用来表示ASP.NET的版本例如: X-AspNet-Version: 4.0.30319X-Powered-By作用: 表示网站是用什么技术开发的例如: X-Powered-By: ASP.NET 2.7.5 Transport头域Connection例如: Connection: keep-alive 当一个网页打开完成后, 客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭, 如果客户端再次访问这个服务器上的网页, 会继续使用这一条已经建立的连接例如: Connection: close 代表一个Request完成后, 客户端和服务器之间用于传输HTTP数据的TCP连接会关闭, 当客户端再次发送Request, 需要重新建立TCP连接 2.7.6 Location头域Location作用: 用于重定向一个新的位置, 包含新的URL地址 2.8 HTTP协议是无状态的和Connection: keep-alive的区别无状态是指协议对于事务处理没有记忆能力, 服务器不知道客户端是什么状态.从另一方面讲, 打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系HTTP是一个无状态的面向连接的协议, 无状态不代表HTTP不能保持TCP连接, 更不能代表HTTP使用的是UDP协议(无连接)从HTTP/1.1起, 默认都开启了Keep-Alive, 保持连接特性, 简单地说, 当一个网页打开完成后, 客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭, 如果客户端再次访问这个服务器上的网页,会继续使用这一条已经建立的连接Keep-Alive不会永久保持连接, 它有一个保持时间, 可以在不同的服务器软件(如Apache)中设定这个时间 3. 参考链接HTTP协议详解]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理服务器]]></title>
    <url>%2F2018%2F09%2F24%2F%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. 前言在公司里开发, 一般是在内网环境中, 所以经常会遇到一些网络相关的问题以及代理服务器的配置, 这篇文章主要是记录代理服务器及其相关的知识. 2. 代理服务器2.1 什么是代理服务器?代理服务器(Proxy Server)是互联网上提供转接功能的服务器, 在一般情况下, 我们使用网络浏览器直接去连接其他Internet站点取得网络信息时, 是直接联系到目的站点服务器, 然后由目的站点服务器把信息传送回来. 代理服务器是介于客户端和Web服务器之间的另一台服务器, 有了它之后, 浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求, 信号会先送到代理服务器, 由代理服务器来取回浏览器所需要的信息并传送给你的浏览器.比如你想访问的目的网站是A, 由于某种原因你不能访问到网站A或者你不想直接访问网站A(这样通过代理服务器网站A, 对网站A而言可以隐藏你自己的身份, 也就是不知道是谁访问的网站, 而认为是代理服务器访问的), 此时你就可以使用代理服务器, 在实际访问网站的时候, 你在浏览器的地址栏内和你以前一样输入你要访问的网站, 浏览器会自动先访问代理服务器, 然后代理服务器会自动给你转接到你的目标网站. 2.2 代理服务器的工作原理当用户在浏览器中设置好Proxy Server后, 你使用浏览器访问所有WWW站点的请求都不会直接发给目的主机, 而是先发给代理服务器, 代理服务器接受了客户的请求以后, 由代理服务器向目的主机发出请求, 并接受目的主机的数据, 存于代理服务器的硬盘中, 然后再由代理服务器将客户要求的数据发给客户. 2.3 代理服务器的角色和工作过程代理服务器是为了减少长距离的传送而诞生的. 它不仅可以代理客户端向服务器端提出请求, 也可以代理服务器传给客户端所需要的数据。当客户端对服务器端提出请求时, 此请求会被送到代理服务器, 然后代理服务器会检查本身是否有客户端所需要的数据. 如果有, 代理服务器便代替服务器将数据传给客户端. 而代理服务器一般都是设置距自己传输距离较近的某台代理服务器, 所以它传数据给客户端的速度会比从远程服务器传数据要快.如果代理服务器没有客户端所请求的数据, 它会去服务器获取所需的数据. 在代理服务器从服务器端取得数据传给客户端时, 自己保存一份, 待下次如果有用户提出相同的请求时, 便可以将数据直接传过去, 而不需要再去服务器端获取了. 2.4 代理分类(基于用途)代理的分类有很多, 说白了就是基于不同的协议和具体实现, 有不同类型的代理, 但是从本质上看, 原理和工作过程是类似的.Http代理: 代理客户机的http访问, 主要代理浏览器访问网页, 它的端口一般为80, 8080, 3128等.SSL代理: 支持最高128位加密强度的http代理, 可以作为访问加密网站的代理. 加密网站是指以https://开始的网站. ssl的标准端口为443.HTTP CONNECT代理: 允许用户建立TCP连接到任何端口的代理服务器, 这种代理不仅可用于HTTP, 还包括FTP, IRC, RM流服务等.FTP代理: 代理客户机上的ftp软件访问ftp服务器, 其端口一般为21, 2121.POP3代理: 代理客户机上的邮件软件用pop3方式收邮件, 其端口一般为110.Telnet代理: 能够代理通信机的telnet, 用于远程控制, 入侵时经常使用. 其端口一般为23.Socks代理: 是全能代理, 就像有很多跳线的转接板, 它只是简单地将一端的系统连接到另外一端. 支持多种协议, 包括http, ftp请求及其它类型的请求. 它分socks 4和socks 5两种类型, socks 4只支持TCP协议而socks 5支持TCP/UDP协议, 还支持各种身份验证机制等协议. 其标准端口为1080.TUNNEL代理: 经HTTPTunnet程序转换的数据包封装成http请求(Request)来穿透防火墙, 允许利用HTTP服务器做任何TCP可以做的事情, 功能相当于Socks5.文献代理: 可以用来查询数据库的代理, 通过这些代理, 可以获得互联网的相关科研学术的数据库资源, 例如查询Sciencedirect网站(简称SD), Academic Press, IEEE, SPRINGER等数据库.教育网代理: 指学术教育机构局域网通过特定的代理服务器可使无出国权限或无访问某IP段权限的计算机访问相关资源.跳板代理: 应用于跳板程序, 可以看作一种具有动态加密的特殊socks5代理, 也可直接用于PSD软件. 其端口一般为1813.Ssso代理: 代理客户机上的ssso程序访问远程网站, 具有SSL加密强度的超级代理, 支持socks.Flat代理: 代理客户机上的flatsurfer程序访问远程网站, 具有高强度加密数据流的特殊代理, 支持socks, 最大可设置三次级联, 可以设置穿越代理. 其端口一般为6700.SoftE代理: 代理客户机上的SoftEther程序访问远程网站, 应用虚拟集线器HUB和虚拟网卡技术, 具备VPN功能及多种认证方式的代理, 符合https协议. 2.5 网络代理种类包括透明代理, 匿名代理, 混淆代理, 高匿代理.这4种代理, 主要是在代理服务器端的配置不同, 导致其向目标地址发送请求时, REMOTE_ADDR, HTTP_VIA, HTTP_X_FORWARDED_FOR三个变量不同. 2.5.1 透明代理(Transparent Proxy)123REMOTE_ADDR = Proxy IPHTTP_VIA = Proxy IPHTTP_X_FORWARDED_FOR = Your IP 透明代理虽然可以直接“隐藏”你的IP地址, 但是还是可以从HTTP_X_FORWARDED_FOR来查到你是谁. 2.5.2 匿名代理(Anonymous Proxy)123REMOTE_ADDR = proxy IPHTTP_VIA = proxy IPHTTP_X_FORWARDED_FOR = proxy IP 匿名代理比透明代理进步了一点: 别人只能知道你用了代理, 无法知道你是谁. 2.5.3 混淆代理(Distorting Proxies)123REMOTE_ADDR = Proxy IPHTTP_VIA = Proxy IPHTTP_X_FORWARDED_FOR = Random IP address 如果使用了混淆代理, 别人还是能知道你在用代理, 但是会得到一个假的IP地址, 伪装的更逼真. 2.5.4 高匿代理(Elite proxy或High Anonymity Proxy)123REMOTE_ADDR = Proxy IPHTTP_VIA = not determinedHTTP_X_FORWARDED_FOR = not determined 可以看出来, 高匿代理让别人根本无法发现你是在用代理, 所以是最好的选择. 3. NATNAT: network address translation(网络地址转换)通过在专用网连接到互联网的路由器上安装NAT软件, 这种NAT路由器至少保证一个有效的全球IP地址, 这样子一来, 只需要将本地地址转化为全球IP地址即可和因特网通信. 4. 参考链接什么是代理服务器及作用？如何使用其上网？代理服务器的工作原理代理服务器的分类透明代理、匿名代理、混淆代理、高匿代理有什么区别？了解VPN, NAT, 代理服务器的原理]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM垃圾回收]]></title>
    <url>%2F2018%2F09%2F24%2FJVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[1. 前言垃圾回收是JVM里面非常重要的一块, 这部分主要记录垃圾回收相关的知识. 2. 垃圾回收概述JVM的内存结构包括五大区域: 程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆区和方法区则不一样! 这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。 垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法！ 3. 堆区如何判断是否需要回收3.1 引用计数算法在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。 3.1.1 优缺点优点：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。缺点：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0。 3.1.2 举例123456789101112public class ReferenceFindTest &#123; public static void main(String[] args) &#123; MyObject object1 = new MyObject(); MyObject object2 = new MyObject(); object1.object = object2; object2.object = object1; object1 = null; object2 = null; &#125;&#125; 这段代码是用来验证引用计数算法不能检测出循环引用。最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为0，那么垃圾收集器就永远不会回收它们。 3.2 可达性分析算法可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。 在Java语言中，可作为GC Roots的对象包括下面几种: a) 虚拟机栈中引用的对象（栈帧中的本地变量表）；b) 方法区中类静态属性引用的对象；c) 方法区中常量引用的对象；d) 本地方法栈中JNI（Native方法）引用的对象。 3.3 Java中的引用无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在Java语言中，将引用又分为强引用、软引用、弱引用、虚引用4种，这四种引用强度依次逐渐减弱。 3.3.1 强引用在程序代码中普遍存在的，类似 Object obj = new Object() 这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 1Object obj = new Object() 3.3.2 软引用用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。 1234Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null;sf.get();//有时候会返回null 3.3.3 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 12345Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null;wf.get();//有时候会返回nullwf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾 3.3.4 虚引用也叫幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的作用是能在这个对象被收集器回收时收到一个系统通知。 12345Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj);obj=null;pf.get();//永远返回nullpf.isEnQueued();//返回是否从内存中已经删除 3.4 对象死亡(被回收)前的最后一次挣扎即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。 第一次标记：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记；第二次标记：第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。在finalize()方法中没有重新与引用链建立关联关系的，将被进行第二次标记。 第二次标记成功的对象将真的会被回收，如果对象在finalize()方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。 4. 方法区如何判断是否需要回收方法区存储内容是否需要回收的判断可就不一样咯。方法区主要回收的内容有：废弃常量(其实就是运行时常量池, 现在已经迁移到堆区了)和无用的类。 对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件： 1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；2. 加载该类的ClassLoader已经被回收；3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 5. 常用的垃圾收集算法5.1 标记-清除算法标记-清除算法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如下图所示。标记-清除算法不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。 5.2 复制算法复制算法的提出是为了克服句柄的开销和解决内存碎片的问题。它开始时把堆分成 一个对象 面和 多个空闲 面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾收集器就从根集合（GC Roots）中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。 5.3 标记-整理算法标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。具体流程见下图： 5.4 分代收集算法分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。新生代一般使用复制算法, 而老年代一般使用 标记-整理 或 标记-清除 算法. 5.4.1 年轻代的回收算法 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。 新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。 5.4.2 年老代的回收算法 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 内存比新生代也大很多(大概比例是2:1)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。 5.4.3 持久代的回收算法用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代也称方法区，具体的回收可参见上面 4. 方法区如何判断是否需要回收. 6. HotSpot算法实现6.1 枚举根节点6.1.1 GC停顿在进行对象的可达性分析时，必须在一个能确保一致性的快照中进行(一致性即在整个分析期间，整个执行系统不可以出现分析过程中，对象引用关系还在不断变化的过程)，该点不满足的话分析结果准确性就无法得到保证。所以GC进行时必须停顿所有Java线程。所以枚举根节点时必须要停顿。这件事件就是Stop The World(STW). 6.1.2 HotSpot枚举的实现在HotSpot的实现中，是使用一组称为OopMap（Ordinary Object Pointer：普通对象指针）的数据结构来实现的。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。所以GC扫描时就可以直接得知这些信息。 6.2 安全点6.2.1 安全点的位置的作用及选取安全点即何时生成OopMap的位置。程序执行时并非在所有地方都停顿下来开始GC，只有在到达安全点时才能停顿。安全点的选定基本是以程序“是否具有让程序长时间执行的特征”为标准进行选定的–因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以这些功能的指令才会产生Safepoint。 6.2.2 如何让所有的线程在最近的安全点停顿下来抢先式中断（Preemptive Suspension）：不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让他跑到安全点上。现在已不采用此中方式。 主动式中断（Voluntary Suspension）：当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。 6.3 安全区域6.3.1 问题提出安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的安全点。但是程序不执行的时候，没有分配CPU时间，典型的例子就是线程处于sleep状态或者blocked状态，这时候线程无法响应JVM的中断请求，走到安全的地方去中断挂起。所以这就需要安全区域来解决。 6.3.2 概念安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。可以把安全区域看做是扩展了的安全点。在线程执行到安全区域中的代码时，首先表示自己已经进入安全区域，在这段时间里JVM要发起GC时，就不用管标识自己为安全区域状态的线程了。在线程要离开安全区域时，要检查系统是否已经完成了根节点枚举或者是整个GC过程，如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开安全区域的信号为止。 7. 垃圾回收器GC实现目标: 准确、高效、低停顿、空闲内存规整. 7.1 新生代垃圾收集器7.1.1 Serial收集器Serial收集器是Hotspot运行在Client模式下的默认新生代收集器, 它的特点是 只用一个CPU/一条收集线程去完成GC工作, 且在进行垃圾收集时必须暂停其他所有的工作线程(“Stop The World” -后面简称STW).虽然是单线程收集, 但它却简单而高效, 在VM管理内存不大的情况下(收集几十M~一两百M的新生代), 停顿时间完全可以控制在几十毫秒~一百多毫秒内. 7.1.2 ParNew收集器ParNew收集器其实是前面Serial的多线程版本, 除使用多条线程进行GC外, 包括Serial可用的所有控制参数、收集算法、STW、对象分配规则、回收策略等都与Serial完全一样(也是VM启用CMS收集器-XX: +UseConcMarkSweepGC的默认新生代收集器).由于存在线程切换的开销, ParNew在单CPU的环境中比不上Serial, 且在通过超线程技术实现的两个CPU的环境中也不能100%保证能超越Serial. 但随着可用的CPU数量的增加, 收集效率肯定也会大大增加(ParNew收集线程数与CPU的数量相同, 因此在CPU数量过大的环境中, 可用-XX:ParallelGCThreads参数控制GC线程数). 7.1.3 Parallel Scavenge收集器与ParNew类似, Parallel Scavenge也是使用复制算法, 也是并行多线程收集器. 但与其他收集器关注尽可能缩短垃圾收集时间不同, Parallel Scavenge更关注系统吞吐量: 系统吞吐量=运行用户代码时间 / (运行用户代码时间+垃圾收集时间) 停顿时间越短就越适用于用户交互的程序-良好的响应速度能提升用户的体验;而高吞吐量则适用于后台运算而不需要太多交互的任务-可以最高效率地利用CPU时间,尽快地完成程序的运算任务. Parallel Scavenge提供了如下参数设置系统吞吐量: Parallel Scavenge参数 描述 MaxGCPauseMillis (毫秒数) 收集器将尽力保证内存回收花费的时间不超过设定值, 但如果太小将会导致GC的频率增加. GCTimeRatio (整数:0 &lt; GCTimeRatio &lt; 100) 是垃圾收集时间占总时间的比率 -XX:+UseAdaptiveSizePolicy 启用GC自适应的调节策略: 不再需要手工指定-Xmn、-XX:SurvivorRatio、-XX:PretenureSizeThreshold等细节参数, VM会根据当前系统的运行情况收集性能监控信息, 动态调整这些参数以提供最合适的停顿时间或最大的吞吐量 7.2 老年代7.2.1 Serial Old收集器Serial Old是Serial收集器的老年代版本, 同样是单线程收集器,使用“标记-整理”算法:Serial Old应用场景如下:JDK 1.5之前与Parallel Scavenge收集器搭配使用;作为CMS收集器的后备预案, 在并发收集发生Concurrent Mode Failure时启用(见下:CMS收集器). 7.2.2 Parallel Old收集器Parallel Old是Parallel Scavenge收老年代版本, 使用多线程和“标记－整理”算法, 吞吐量优先, 主要与Parallel Scavenge配合在 注重吞吐量 及 CPU资源敏感 系统内使用: 7.2.3 CMS收集器CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器，它非常符合那些集中在互联网站或者B/S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。从名字上（“Mark Sweep”）就可以看出它是基于“标记-清除”算法实现的。 CMS收集器工作的整个流程分为以下4个步骤： 初始标记（CMS initial mark）：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。并发标记（CMS concurrent mark）：进行GC Roots Tracing的过程，在整个过程中耗时最长。重新标记（CMS remark）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。并发清除（CMS concurrent sweep）由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。通过下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间： 7.2.3.1 优点CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿，因此CMS收集器也被称为并发低停顿收集器（Concurrent Low Pause Collector）。 7.2.3.2 缺点 对CPU资源非常敏感. 其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。 无法处理浮动垃圾（Floating Garbage）. 可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就被称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。 标记-清除算法导致的空间碎片. CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象。 7.3 G1收集器G1（Garbage-First）收集器是当今收集器技术发展最前沿的成果之一，它是一款面向服务端应用的垃圾收集器，HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。 7.3.1 G1的特点与其他GC收集器相比，G1具备如下特点： 并行与并发 G1 能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。 分代收集 与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。 空间整合 G1从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。这意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。 可预测的停顿 这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。 7.3.2 横跨整个堆内存在G1之前的其他收集器进行收集的范围都是整个新生代或者老生代，而G1不再是这样。G1在使用时，Java堆的内存布局与其他收集器有很大区别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合。 7.3.3 建立可预测的时间模型G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。 7.3.4 避免全堆扫描——Remembered SetG1把Java堆分为多个Region，就是“化整为零”。但是Region不可能是孤立的，一个对象分配在某个Region中，可以与整个Java堆任意的对象发生引用关系。在做可达性分析确定对象是否存活的时候，需要扫描整个Java堆才能保证准确性，这显然是对GC效率的极大伤害。 为了避免全堆扫描的发生，虚拟机为G1中每个Region维护了一个与之对应的Remembered Set。虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。 7.3.5 G1收集器的运作步骤如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤： 初始标记（Initial Marking） 仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程，但耗时很短。 并发标记（Concurrent Marking） 从GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。 最终标记（Final Marking） 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。 筛选回收（Live Data Counting and Evacuation） 首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 通过下图可以比较清楚地看到G1收集器的运作步骤中并发和需要停顿的阶段（Safepoint处）： 8. 内存分配策略Java的自动内存管理最终可以归结为自动化地解决了两个问题： 给对象分配内存 回收分配给对象的内存 对象的内存分配通常是在堆上分配（除此以外还有可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是固定的，实际取决于垃圾收集器的具体组合以及虚拟机中与内存相关的参数的设置。至于内存回收策略，在上文已经描述得很详尽了。 8.1 对象优先在Eden区分配大多数情况下，对象在新生代的Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。 8.2 大对象直接进入老年代所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是很长的字符串以及数组。大对象对虚拟机的内存分配来说是一个坏消息（尤其是遇到朝生夕灭的“短命大对象”，写程序时应避免），经常出现大对象容易导致内存还有不少空间时就提前触发GC以获取足够的连续空间来安置它们。 虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用复制算法回收内存）。 8.3 长期存活的对象将进入老年代既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。 8.4 动态对象年龄判定为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。 8.5 空间分配担保在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。 前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。 取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。 8.6 Full GC的触发条件对于Minor GC，其触发条件非常简单，当Eden区空间满时，就将触发一次Minor GC。而Full GC则相对复杂，因此本节我们主要介绍Full GC的触发条件。 8.6.1 调用System.gc()此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存，可通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc()。 8.6.2 老年代空间不足老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行Full GC后空间仍然不足，则抛出如下错误： Java.lang.OutOfMemoryError: Java heap space 为避免以上两种状况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。 8.6.3 空间分配担保失败前文介绍过，使用复制算法的Minor GC需要老年代的内存空间作担保，如果出现了HandlePromotionFailure担保失败，则会触发Full GC。 8.6.4 JDK 1.7及以前的永久代空间不足在JDK 1.7及以前，HotSpot虚拟机中的方法区是用永久代实现的，永久代中存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息： java.lang.OutOfMemoryError: PermGen space 为避免PermGen占满造成Full GC现象，可采用的方法为增大PermGen空间或转为使用CMS GC。 在JDK 1.8中用元空间替换了永久代作为方法区的实现，元空间是本地内存，因此减少了一种Full GC触发的可能性。 8.6.5 Concurrent Mode Failure执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是CMS GC时当前的浮动垃圾过多导致暂时性的空间不足触发Full GC），便会报Concurrent Mode Failure错误，并触发Full GC。 9. 参考链接&lt;&lt;深入理解Java虚拟机—-JVM高级特性与最佳实践&gt;&gt;(第二版, 周志明)扒一扒JVM的垃圾回收机制，下次面试你准备好了吗Java四种引用包括强引用，软引用，弱引用，虚引用。HotSpot算法实现JVM初探：内存分配、GC原理与垃圾收集器深入理解JVM(3)——7种垃圾收集器深入理解JVM(2)——GC算法与内存分配策略]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程安全和锁优化]]></title>
    <url>%2F2018%2F09%2F24%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1. 前言在公司开发, 高并发是不可避免需要考虑的. 这部分记录JVM中的线程安全和锁优化技术. 2. 线程安全2.1 线程安全定义当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的； 2.2 线程安全种类分为以下5类: 不可变, 绝对线程安全, 相对线程安全, 线程兼容, 线程对立; 2.2.1 不可变对象该对象一定是线程安全的, 无论是对象的方法实现还是方法的调用者, 都不需要采取任何的线程安全保障措施; 如果共享数据是一个基本数据类型, 那么只要在定义时使用 final 关键字修饰它就可以保证它是不可变的; 不妨想想java.lang.String类的对象: 它是一个典型的不可变对象, 调用它的substring(), replace(), concat() 这些方法都不会影响它原来的值, 只会返回一个新构造的字符串对象; 2.2.2 绝对线程安全绝对安全的线程的类, 完全符合线程安全定义的定义, 但在Java API中标注自己是线程安全的类, 大多数都不是绝对的线程安全. 2.2.3 相对线程安全是通常意义上的线程安全, 它需要保证对这个对象单独的操作是线程安全的, 在调用的时候不需要做额外的保证措施. 但是对于一些特定顺序的连续调用, 就可能需要在调用端使用额外的同步手段来保证调用的正确性.在Java语言中, 大部分线程安全类都属于这种类型.如Vector, Hashtable, Collections的synchronizedCollection()方法包装的集合等. 2.2.4 线程兼容线程兼容是指对象本身不是线程安全的, 但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中是可以安全使用的. Java API中的大部分的类都是属于线程兼容的.如ArrayList和HashMap等. 2.2.5 线程对立线程对立是指无论调用端是否采取了同步措施, 都无法在多线程环境中使用的代码. 线程对立这种排斥多线程的代码是很少出现的, 通常都是有害的, 应当避免.如Thread类的suspend()和resume()方法. 如果两个线程同时持有一个线程对象, 两个线程并发对该线程对象执行suspend()和resume()方法, 无论是否采用了同步, 都存在死锁风险. 2.3 线程安全的实现方法2.3.1 互斥同步 互斥同步: 是常见的并发正确性保障手段; 同步: 是指在多个线程并发访问共享数据时, 保证共享数据在同一个时刻被一个线程使用. 互斥: 互斥是实现同步的一种手段; 临界区, 互斥量和信号量都是主要的互斥实现方式. 因此, 在这4个字里面, 互斥是因, 同步是果; 互斥是方法, 同步是目的; 最基本的互斥同步手段就是 synchronized关键字: synchronized关键字经过 编译之后, 会在同步块的前后分别形成 monitorenter 和 monitorexit 这个两个字节码指令, 这两个字节码都需要一个 reference类型的参数来指明要锁定和解锁的对象; 如果java程序中的synchronized明确指定了对象参数, 那就是这个对象的reference; 如果没有明确指定, 那就根据 synchronized修饰的实例方法还是类方法, 去取对应的对象实例或Class 对象来作为锁对象; 根据虚拟机规范的要求: 在执行monitorenter指令时, 如果这个对象没有锁定或当前线程已经拥有了那个对象的锁, 锁的计数器加1, 相应的, 在执行 monitorexit 指令时会将锁计数器减1; 当计数器为0时, 锁就被释放了; 对于monitorenter 和 monitorexit 的行为描述中, 有两点需要注意:a. synchronized同步块对同一条线程来说是可重入的, 不会出现自己把自己锁死的问题;b. 同步块在已进入的线程执行完之前, 会阻塞后面其他线程 的进入; 除了synchronized之外, 还可以使用 java.util.concurrent 包中的重入锁(ReentrantLock)来实现同步; 2.3.1.1 Synchronized与ReentrantLock比较2.3.1.1.1 相似点这两种同步方式有很多相似之处, 它们都是加锁方式同步, 而且都是阻塞式的同步, 也就是说当如果一个线程获得了对象锁, 进入了同步块, 其他访问该同步块的线程都必须阻塞在同步块外面等待, 而进行线程阻塞和唤醒的代价是比较高的 2.3.1.1.2 区别这两种方式最大区别就是对于Synchronized来说, 它是java语言的关键字, 是原生语法层面的互斥, 需要jvm实现.而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁, 需要lock()和unlock()方法配合try/finally语句块来完成. 2.3.1.1.3 Synchronized的基本使用Synchronized进过编译, 会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令. 在执行monitorenter指令时, 首先要尝试获取对象锁. 如果这个对象没被锁定, 或者当前线程已经拥有了那个对象锁, 把锁的计算器加1, 相应的, 在执行monitorexit指令时会将锁计算器就减1, 当计算器为0时, 锁就被释放了. 如果获取对象锁失败, 那当前线程就要阻塞, 直到对象锁被另一个线程释放为止. 123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; Runnable runnable = new MyThread(); new Thread(runnable, "t1").start(); new Thread(runnable, "t2").start(); &#125;&#125;class MyThread implements Runnable &#123; @Override public void run() &#123; synchronized (this) &#123; for(int i=0;i&lt;10;i++) System.out.println(Thread.currentThread().getName()+":"+i); &#125; &#125;&#125; 运行结果: 1234567891011121314151617181920t1:0t1:1t1:2t1:3t1:4t1:5t1:6t1:7t1:8t1:9t2:0t2:1t2:2t2:3t2:4t2:5t2:6t2:7t2:8t2:9 2.3.1.1.4 ReentrantLock的基本使用由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁, 相比Synchronized, ReentrantLock类提供了一些高级功能, 主要有以下3项: 等待可中断, 持有锁的线程长期不释放的时候, 正在等待的线程可以选择放弃等待, 这相对于Synchronized来说可以避免出现死锁的情况。 公平锁, 多个线程等待同一个锁时, 必须按照申请锁的时间顺序获得锁, Synchronized锁非公平锁, ReentrantLock默认的构造函数是创建的非公平锁, 可以通过参数true设为公平锁, 但公平锁表现的性能不是很好. 锁绑定多个条件, 一个ReentrantLock对象可以同时绑定对个对象. 1234567891011121314151617181920212223import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Main &#123; public static void main(String[] args) &#123; Runnable runnable = new MyThread(); new Thread(runnable, "t1").start(); new Thread(runnable, "t2").start(); &#125;&#125;class MyThread implements Runnable &#123; private Lock lock=new ReentrantLock(); @Override public void run() &#123; lock.lock(); try&#123; for(int i=0;i&lt;5;i++) System.out.println(Thread.currentThread().getName()+":"+i); &#125;finally&#123; lock.unlock(); &#125; &#125;&#125; 运行结果: 12345678910t1:0t1:1t1:2t1:3t1:4t2:0t2:1t2:2t2:3t2:4 关于synchronized 和 ReentrantLock 性能的分析: 多线程环境下 synchronized的吞吐量下降得非常严重, 而 ReentrantLock 则能基本保持在同一个比较稳定的水平上; 与其说ReentrantLock性能好, 还不如说 synchronized还有非常大的优化余地; 虚拟机在未来的性能改进中肯定也会更加偏向于原生的 synchronized, 所以还是提倡在 synchronized能实现需求的情况下, 优先考虑使用 synchronized 来进行同步; 2.3.2 互斥同步非阻塞同步 阻塞同步(互斥同步)的问题: 就是进行线程阻塞和唤醒所带来的性能问题, 互斥同步属于一种悲观的并发策略, 无论共享数据是否真的会出现竞争, 它都要进行加锁, 用户态核心态转换, 维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作; 非阻塞同步定义: 基于冲突检测的乐观并发策略, 通俗的说, 就是先进行操作, 如果没有其他线程争用共享数据, 那操作就成功了; 如果共享数据有争用, 产生了冲突, 那就再采用其他的补偿措施, 这种乐观的并发策略的许多实现都不需要把线程挂起, 因此这种同步操作称为 非阻塞同步; 为什么作者要说使用乐观并发策略需要“硬件指令集的发展”才能进行呢? 因为 我们需要 操作 和 冲突检测 这两个步骤具备原子性, 靠什么来保证呢?a. 硬件: 保证一个从语义上看起来需要多次操作的行为只通过一次处理器指令就能完成 2.3.2.1 CAS(Compare-and-Swap)操作的使用1234567891011121314151617181920212223242526272829303132333435363738394041// Atomic 变量自增运算测试(incrementAndGet 方法的原子性)public class AtomicTest &#123; public static AtomicInteger race = new AtomicInteger(0); public static void increase() &#123; // 输出正确结果，一切都要归功于 incrementAndGet 方法的原子性 race.incrementAndGet(); &#125; public static final int THREADS_COUNT = 20; public static void main(String[] args) throws Exception &#123; Thread[] threads = new Thread[THREADS_COUNT]; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 10000; j++) &#123; increase(); &#125; &#125; &#125;); threads[i].start(); &#125; while(Thread.activeCount() &gt; 1) &#123; Thread.yield(); &#125; System.out.println(race); &#125; /** * incrementAndGet() 方法的JDK 源码 * Atomically increment by one the current value. * @return the updated value */ public final int incrementAndGet() &#123; for(;;) &#123; int current = get(); int next = current + 1; if(compareAndSet(current,next)) &#123; return next; &#125; &#125; &#125;&#125; 2.3.2.2 CAS操作的ABA问题和解决方法 问题描述:如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就说它的值没有被其他线程改变过了吗? 如果在这段期间它的值曾经被改为了B, 之后又改回了A, 那CAS操作就会误认为它从来没有被改变过, 这个漏洞称为 CAS操作的 ABA问题; 解决方法:J.U.C 包为了解决这个问题, 提供了一个带有标记的原子引用类“AtomicStampedReference”, 它可以通过控制变量值的version 来保证CAS的正确性. 不过目前来说这个类比较鸡肋, 大部分cases 下 ABA问题 不会影响程序并发的正确性, 如果需要解决ABA问题, 改用传统的互斥同步可能会比原子类更高效; 2.3.3 无同步方案如果一个方法本来就不涉及共享数据, 那它自然就无须任何同步措施去保证正确性, 因此会有一些代码天生就是线程安全的; 下面介绍两类线程安全代码: 第一类线程安全代码——可重入代码：也叫作纯代码，可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误;a. 所有的可重入代码都是线程安全的；b. 如何判断代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同 第二类线程安全代码——线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能够保证在同一线程中执行？ 如果能保证，我们就可以把共享数据的可见范围限制在同一个线程内，这样，无需同步也可以保证线程间不出现数据争用问题； 3. 锁优化锁优化技术(HotSpot虚拟机而言)包括适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等。这些技术都是为了在线程之间更高效地共享数据以及解决竞争问题，从而提高程序效率。 3.1 自旋锁与自适应自旋3.1.1 问题前文中我们提到，互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程很不值得； 3.1.2 自旋锁定义针对上面的问题, 提出的解决方法:为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁； jdk1.6中 自旋锁是默认开启的，可以使用 -XX:+UseSpinning 参数来开启； 自旋等待的时间必须要有一定的限度： 如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10，用户可以用参数 -XX:PreBlockSpin 来更改； 3.1.3 自适应自旋定义 自适应自旋锁：jdk1.6 中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定: 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个cycle； 如果对于某个锁，自旋很少成功获得过， 那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源； 3.2 锁消除3.2.1 定义锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检查到不可能存在共享数据竞争的锁进行消除； 3.2.2 判定依据来源于逃逸分析的数据支持；如果判定在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行了； 3.3 锁粗化3.3.1 问题描述如果一系列的连续操作都对同一个对象反复加锁和解锁, 甚至加锁操作是出现在循环体中的, 那即使没有线程竞争, 频繁地进行互斥同步操作也会导致不必要的性能损耗; 3.3.2 锁粗化的定义如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁, 将会把加锁同步的范围扩展(粗化)到整个操作序列的外部; 3.4 轻量级锁3.4.1 重量级锁定义使用操作系统互斥量来实现的传统锁； 3.4.2 轻量级锁的作用是在没有多线程竞争的前提下, 减少传统的重量级锁使用操作系统互斥量产生的性能消耗; 3.4.3 对象头Mark WordHotSpot虚拟机的对象头分为两部分信息:第一部分:用于存储对象自身的运行时数据, 如哈希码, GC分代年龄等; 这部分数据的长度在32位和64位的虚拟机中分别为 32bit 和 64bit, 官方称它为 Mark Word, 它是实现轻量级锁和偏向锁的关键;第二部分:用于存储指向方法区对象类型数据的指针, 如果是数组对象的话, 还会有一个额外的部分用于存储数组长度; 对象头信息是与对象自身定义的数据无关的额外存储成本, 考虑到虚拟机的空间效率, Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息, 它会工具对象的状态复用自己的存储空间; HotSpot 虚拟机对象头Mark Word 如下图所示: 3.4.4 实现逻辑在代码进入同步块的时候: 轻量级锁的加锁过程:step1. 如果此同步对象没有被锁定(锁标志位为01状态): 虚拟机首先将在当前线程的栈帧中建立一个名为 锁记录(Lock Record) 的空间, 用于存储对象目前的Mark Word 的拷贝;step2. 然后, 虚拟机将使用CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record的指针; 并将线程栈帧中的Lock Record里的owner指针指向Object的 Mark Word.step3. 如果这个更新工作成功了, 那么这个线程就拥有了该对象的锁, 并且对象Mark Word的锁标志位将转变为 00, 即表示 此对象处于轻量级锁定状态;step4. 如果这个更新失败了, 虚拟机首先会检查对象的Mark Word 是否指向当前线程的栈帧, 如果指向, 则说明当前线程已经拥有了这个对象的锁, 那就可以直接进入同步块继续执行, 否则说明这个锁对象以及被其他线程抢占了. 如果有两条以上的线程争用同一个锁, 那轻量级锁就不再有效, 要膨胀为重量级锁, 锁标志的状态值变为 10, Mark Word中存储的就是指向重量级(互斥量)的指针, 后面等待锁的线程也要进入阻塞状态; 轻量级锁的解锁过程:step1. 如果对象的Mark Word仍然指向着线程的锁记录, 那就用CAS 操作把对象当前的Mark Word 和 线程中复制的 Dispatched Mard Word替换回来;step2. 如果替换成功, 整个同步过程就over了;step3. 如果替换失败, 说明有其他线程尝试过获取该锁, 那就要在释放锁的同时, 唤醒被挂起的线程; 3.4.5 结论 轻量级锁能提升程序同步性能的依据是: 对于绝大部分的锁，在整个同步周期内都是不存在竞争的； 如果没有竞争，轻量级锁使用CAS 操作避免了使用互斥量的开销；但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS 操作，因此在有竞争的case下， 轻量级锁会比传统的重量级锁更慢； 3.5 偏向锁3.5.1 偏向锁的目的消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能； 如果说轻量级锁是在无竞争的情况使用CAS 操作去消除同步使用的互斥量：那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS 操作都不做了； 它的意思是这个锁会偏向于 第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步； 3.5.2 偏向锁的原理若当前虚拟机启用了偏向锁，那么，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为01， 即偏向模式；同时使用CAS 操作把获取到这个锁的线程的ID 记录在对象的 Mark Word之中，如果 CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作； 当有另一个线程去尝试获取这个锁时，偏向模式就结束了：根据锁对象目前是否处于被锁定的状态， 撤销偏向后恢复到未锁定（标志位为01）或轻量级锁定（标志位为00）的状态，后续的同步操作就如上面介绍的轻量级锁那样执行； 3.5.3 结论 偏向锁可以提高带有同步但无竞争的程序性能； 如果程序中大多数的锁总是被多个不同的线程访问：那偏向模式是多余的； 3.5.4 偏向锁流程偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会尝试消除它身上的偏向锁，将锁恢复到标准的轻量级锁。因此 流程是这样的 偏向锁-&gt;轻量级锁-&gt;重量级锁 简单的讲，就是在锁对象的对象头中有个ThreadId字段，这个字段如果是空的，第一次获取锁的时候，就将自身的ThreadId写入到锁的ThreadId字段内，将锁头内的是否偏向锁的状态位置1.这样下次获取锁的时候，直接检查ThreadId是否和自身线程Id一致，如果一致，则认为当前线程已经获取了锁，因此不需再次获取锁，略过了轻量级锁和重量级锁的加锁阶段。提高了效率。 4. synchronized原理图附上一张synchronized原理图, 帮助理解整个过程. 5. 参考链接&lt;&lt;深入理解Java虚拟机—-JVM高级特性与最佳实践&gt;&gt;(第二版, 周志明)【JVM】线程安全与锁优化java的两种同步方式， Synchronized与ReentrantLock的区别jvm(13)-线程安全与锁优化浅谈偏向锁、轻量级锁、重量级锁]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM类加载机制]]></title>
    <url>%2F2018%2F09%2F24%2FJVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1. 前言作为一名Java后台开发的程序员, 深入理解JVM, 重要性不言而喻, 这篇文章主要是记录JVM类加载机制相关知识. 2. 类加载的时机2.1 初始化情况JVM类加载分为5个过程: 加载, 验证, 准备, 解析, 初始化, 使用, 卸载, 如下图所示:那么, 什么情况下虚拟机需要开始初始化一个类呢? 这在虚拟机规范中是有严格规定的, 虚拟机规范指明, 有且只有 五种情况必须立即对类进行初始化(而这一过程自然发生在加载, 验证, 准备之后): 遇到new, getstatic, putstatic或invokestatic这四条字节码指令, 如果类没有进行过初始化, 则需要先触发其初始化. 使用java.lang.reflect包的方法对类进行反射调用的时候, 如果类没有进行过初始化, 则需要先触发其初始化. 当初始化一个类的时候, 如果发现其父类还没有进行过初始化, 则需要先触发其父类的初始化. 当虚拟机启动时, 户需要指定一个要执行的主类(包含main()方法的那个类), 虚拟机会先初始化这个主类. 当使用jdk1.7动态语言支持时, 如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄, 并且这个方法句柄所对应的类没有进行初始化, 则需要先出触发其初始化. 2.2 主动引用与被动引用注意, 对于这五种会触发类进行初始化的场景, 虚拟机规范中使用了一个很强烈的限定语: “有且只有”, 这五种场景中的行为称为对一个类进行 主动引用. 除此之外, 所有引用类的方式, 都不会触发初始化, 称为 被动引用.特别需要指出的是, 类的实例化与类的初始化是两个完全不同的概念: 类的实例化是指创建一个类的实例(对象)的过程; 类的初始化是指为类中各个类成员(被static修饰的成员变量)赋初始值的过程, 是类生命周期中的一个阶段. 2.3 被动引用经典示例1.通过子类引用父类的静态字段, 不会导致子类初始化 12345678public class Father &#123; static &#123; System.out.println("父类初试化"); &#125; public static void work()&#123; System.out.println("父类开始工作"); &#125;&#125; 12345public class Son extends Father &#123; static &#123; System.out.println("子类初试化"); &#125;&#125; 12345public class Main &#123; public static void main(String[] args) &#123; Son.work(); &#125;&#125; 运行结果: 12父类初试化父类开始工作 2.通过数组定义来引用类, 不会触发此类的初始化 12345public class Main &#123; public static void main(String[] args) &#123; Son[] sons = new Son[10]; &#125;&#125; 运行结果: 12 3.常量在编译阶段会存入调用类的常量池中, 本质上并没有直接引用到定义常量的类, 因此不会触发定义常量的类的初始化 123456public class Son&#123; static &#123; System.out.println("子类初试化"); &#125; public static final String message = "Hello World!";&#125; 12345public class Main &#123; public static void main(String[] args) &#123; System.out.println(Son.message); &#125;&#125; 运行结果: 1Hello World! 3. 类加载的过程3.1 加载 通过一个类的全限定名来获取定义此类的二进制字节流. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构. 在内存中生成一个代表这个类的java.lang.Class对象, 作为方法区这个类的各种数据的访问入口. 注意: JVM中的ClassLoader类加载器加载Class发生在此阶段. 3.2 验证 文件格式的验证 元数据验证 字节码验证 符号引用验证 3.3 准备准备阶段是正式为类变量(static 成员变量)分配内存并设置类变量初始值(零值)的阶段, 这些变量所使用的内存都将在方法区中进行分配. 这时候进行内存分配的仅包括类变量 , 而不包括实例变量, 实例变量将会在对象实例化时随着对象一起分配在堆中. 其次, 这里所说的初始值“通常情况”下是数据类型的零值, 假设一个类变量的定义为: 1public static int value = 123; 那么, 变量value在准备阶段过后的值为0而不是123.因为这时候尚未开始执行任何java方法, 而把value赋值为123的putstatic指令是程序被编译后, 存放于类构造器方法&lt; clinit &gt;()之中, 所以把value赋值为123的动作将在初始化阶段才会执行.至于“特殊情况”是指: 当类字段的字段属性是ConstantValue时, 会在准备阶段初始化为指定的值, 所以标注为final之后, value的值在准备阶段初始化为123而非0. 1public static final int value = 123; 注意:只设置类中的静态变量(方法区中), 不包括实例变量(堆内存中), 实例变量是在对象实例化的时候初始化分配值的. 3.4 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程. 符号引用: 简单的理解就是字符串, 比如引用一个类, java.util.ArrayList 这就是一个符号引用, 字符串引用的对象不一定被加载.直接引用: 指针或者地址偏移量. 引用对象一定在内存(已经加载). 3.5 初始化 执行类构造器&lt; clinit &gt; 初始化静态变量, 静态块中的数据等(一个类加载器只会初始化一次) 子类的&lt; clinit &gt;调用前保证父类的&lt; clinit &gt;被调用 注意:&lt; clinit &gt;是线程安全的, 执行&lt; clinit &gt;的线程需要先获取锁才能进行初始化操作, 保证只有一个线程能执行&lt; clinit &gt; 4. 类加载器java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称, 找到或者生成其对应的字节代码, 然后从这些字节代码中定义出一个Java 类, 即 java.lang.Class类的一个实例.ClassLoader提供了一系列的方法, 比较重要的方法如: 4.1 类加载器的树状层次结构Java 中的类加载器大致可以分成两类, 一类是系统提供的, 另外一类则是由 Java 应用开发人员编写的. 4.1.1 引导类加载器(Bootstrap ClassLoader)它用来加载 Java 的核心库(jre/lib/rt.jar), 是用原生C++代码来实现的, 并不继承自java.lang.ClassLoader. 4.1.2 扩展类加载器(Extensions ClassLoader)它用来加载 Java 的扩展库(jre/ext/*.jar). Java 虚拟机的实现会提供一个扩展库目录. 该类加载器在此目录里面查找并加载 Java 类. 4.1.3 系统类加载器(System ClassLoader)它根据 Java 应用的类路径(CLASSPATH)来加载 Java 类. 一般来说, Java 应用的类都是由它来完成加载的. 可以通过 ClassLoader.getSystemClassLoader()来获取它. 4.1.4 自定义类加载器(Custom ClassLoader)除了系统提供的类加载器以外, 开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器, 以满足一些特殊的需求. 4.1.5 测试12345678910public class Main &#123; public static void main(String[] args) &#123; //application class loader System.out.println(ClassLoader.getSystemClassLoader()); //extensions class loader System.out.println(ClassLoader.getSystemClassLoader().getParent()); //bootstrap class loader System.out.println(ClassLoader.getSystemClassLoader().getParent().getParent()); &#125;&#125; 结果: 123sun.misc.Launcher$AppClassLoader@18b4aac2sun.misc.Launcher$ExtClassLoader@4554617cnull 可以看出ClassLoader类是由AppClassLoader加载的. 他的父类是ExtClassLoader, ExtClassLoader的父亲无法获取是因为它是用C++实现的. 4.2 双亲委派机制某个特定的类加载器在接到加载类的请求时, 首先将加载任务委托交给父类加载器, 父类加载器又将加载任务向上委托, 直到最父类加载器, 如果最父类加载器可以完成类加载任务, 就成功返回, 如果不行就向下传递委托任务, 由其子类加载器进行加载. 4.2.1 双亲委派机制的好处保证java核心库的安全性(例如: 如果用户自己写了一个java.lang.String类就会因为双亲委派机制不能被加载, 不会破坏原生的String类的加载) 4.2.2 代理模式与双亲委派机制相反, 代理模式是先自己尝试加载, 如果无法加载则向上传递. Tomcat就是代理模式. 4.3 双亲委派模型的破坏者-线程上下文类加载器在Java应用中存在着很多服务提供者接口(Service Provider Interface, SPI), 这些接口允许第三方为它们提供实现, 如常见的 SPI 有 JDBC, JNDI等, 这些 SPI 的接口属于 Java 核心库, 一般存在rt.jar包中, 由Bootstrap类加载器加载, 而 SPI 的第三方实现代码则是作为Java应用所依赖的 jar 包被存放在classpath路径下, 由于SPI接口中的代码经常需要加载具体的第三方实现类并调用其相关方法, 但SPI的核心接口类是由引导类加载器来加载的, 而Bootstrap类加载器无法直接加载SPI的实现类, 同时由于双亲委派模式的存在, Bootstrap类加载器也无法反向委托AppClassLoader加载器SPI的实现类. 在这种情况下, 我们就需要一种特殊的类加载器来加载第三方的类库, 而线程上下文类加载器就是很好的选择.线程上下文类加载器(contextClassLoader)是从 JDK 1.2 开始引入的, 我们可以通过java.lang.Thread类中的getContextClassLoader()和 setContextClassLoader(ClassLoader cl)方法来获取和设置线程的上下文类加载器. 如果没有手动设置上下文类加载器, 线程将继承其父线程的上下文类加载器, 初始线程的上下文类加载器是AppClassLoader, 在线程中运行的代码可以通过此类加载器来加载类和资源, 如下图所示, 以jdbc.jar加载为例.从图可知rt.jar核心包是由Bootstrap类加载器加载的, 其内包含SPI核心接口类, 由于SPI中的类经常需要调用外部实现类的方法, 而jdbc.jar包含外部实现类(jdbc.jar存在于classpath路径)无法通过Bootstrap类加载器加载, 因此只能委派线程上下文类加载器把jdbc.jar中的实现类加载到内存以便SPI相关类使用. 显然这种线程上下文类加载器的加载方式破坏了“双亲委派模型”, 它在执行过程中抛弃双亲委派加载链模式, 使程序可以逆向使用类加载器, 当然这也使得Java类加载器变得更加灵活. 为了进一步证实这种场景, 不妨看看DriverManager类的源码, DriverManager是Java核心rt.jar包中的类, 该类用来管理不同数据库的实现驱动即Driver, 它们都实现了Java核心包中的java.sql.Driver接口, 如mysql驱动包中的com.mysql.jdbc.Driver, 这里主要看看如何加载外部实现类,在 DriverManager初始化时会执行如下代码 12345678910111213141516171819//DriverManager是Java核心包rt.jar的类public class DriverManager &#123; //省略不必要的代码 static &#123; loadInitialDrivers();//执行该方法 println("JDBC DriverManager initialized"); &#125;//loadInitialDrivers方法 private static void loadInitialDrivers() &#123; sun.misc.Providers() AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; //加载外部的Driver的实现类 ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); //省略不必要的代码...... &#125; &#125;); &#125; 12345public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123; //通过线程上下文类加载器加载 ClassLoader cl = Thread.currentThread().getContextClassLoader(); return ServiceLoader.load(service, cl); &#125; 很明显了确实通过线程上下文类加载器加载的, 实际上核心包的SPI类对外部实现类的加载都是基于线程上下文类加载器执行的, 通过这种方式实现了Java核心代码内部去调用外部实现类. 我们知道线程上下文类加载器默认情况下就是AppClassLoader, 那为什么不直接通过getSystemClassLoader()获取类加载器来加载classpath路径下的类的呢?其实是可行的, 但这种直接使用getSystemClassLoader()方法获取AppClassLoader加载类有一个缺点, 那就是代码部署到不同服务时会出现问题, 如把代码部署到Java Web应用服务或者EJB之类的服务将会出问题, 因为这些服务使用的线程上下文类加载器并非AppClassLoader, 而是Java Web应用服自家的类加载器, 类加载器不同. 所以我们应用该少用getSystemClassLoader(). 总之不同的服务使用的可能默认ClassLoader是不同的, 但使用线程上下文类加载器总能获取到与当前程序执行相同的ClassLoader, 从而避免不必要的问题. 4.4 自定义类加载器4.4.1 普通类加载器通常情况下, 我们都是直接使用系统类加载器. 但是, 有的时候, 我们也需要自定义类加载器. 比如应用是通过网络来传输 Java 类的字节码, 为保证安全性, 这些字节码经过了加密处理, 这时系统类加载器就无法对其进行加载, 这样则需要自定义类加载器来实现. 自定义类加载器一般都是继承自 ClassLoader类, 我们只需要重写findClass方法即可. 下面我们通过一个示例来演示自定义类加载器的流程: 123456789101112131415161718192021222324252627282930313233import java.io.*;public class MyClassLoader extends ClassLoader &#123; private String root; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] classData = loadClassData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, classData, 0, classData.length); &#125; &#125; private byte[] loadClassData(String className) &#123; String fileName = root + File.separatorChar + className.replace('.', File.separatorChar) + ".class"; try &#123; InputStream ins = new FileInputStream(fileName); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 1024; byte[] buffer = new byte[bufferSize]; int length = 0; while ((length = ins.read(buffer)) != -1) &#123; baos.write(buffer, 0, length); &#125; return baos.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; public void setRoot(String root) &#123; this.root = root; &#125;&#125; 12345public class Te &#123; static &#123; System.out.println("hello world"); &#125;&#125; 123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; MyClassLoader classLoader = new MyClassLoader(); classLoader.setRoot("C:\\Users\\ganlu\\IdeaProjects\\untitled3\\out\\production\\untitled3"); Class&lt;?&gt; testClass = null; try &#123; testClass = classLoader.loadClass("Te"); Object object = testClass.newInstance(); System.out.println(object.getClass().getClassLoader()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果: 12hello worldsun.misc.Launcher$AppClassLoader@18b4aac2 4.4.2 热部署类加载器所谓的热部署就是利用同一个class文件不同的类加载器在内存创建出两个不同的class对象(即利用不同的类加载实例), 由于JVM在加载类之前会检测请求的类是否已加载过(即在loadClass()方法中调用findLoadedClass()方法), 如果被加载过, 则直接从缓存获取, 不会重新加载. 注意同一个类加载器的实例和同一个class文件只能被加载器一次, 多次加载将报错, 因此我们实现的热部署必须让同一个class文件可以根据不同的类加载器重复加载, 以实现所谓的热部署. 通过直接调用findClass()方法, 而不是调用loadClass()方法即可实现, 因为ClassLoader中loadClass()方法体中调用findLoadedClass()方法进行了检测是否已被加载，因此我们直接调用findClass()方法就可以绕过这个问题, 当然也可以重写loadClass方法, 但强烈不建议这么干. 1MyClassLoader.java 和 Te.java 都用上面的定义. 12345678910111213141516171819202122232425262728public class Main &#123; public static void main(String[] args) &#123; MyClassLoader classLoader1 = new MyClassLoader(); MyClassLoader classLoader2 = new MyClassLoader(); classLoader1.setRoot("C:\\Users\\ganlu\\IdeaProjects\\untitled3\\out\\production\\untitled3"); classLoader2.setRoot("C:\\Users\\ganlu\\IdeaProjects\\untitled3\\out\\production\\untitled3"); try &#123; Class&lt;?&gt; testClass1 = classLoader1.loadClass("Te"); Class&lt;?&gt; testClass2 = classLoader2.loadClass("Te"); System.out.println(testClass1.hashCode()); System.out.println(testClass1.getClassLoader()); System.out.println(testClass2.hashCode()); System.out.println(testClass2.getClassLoader()); Class&lt;?&gt; testClass3 = classLoader1.findClass("Te"); Class&lt;?&gt; testClass4 = classLoader2.findClass("Te"); System.out.println(testClass3.hashCode()); System.out.println(testClass3.getClassLoader()); System.out.println(testClass4.hashCode()); System.out.println(testClass4.getClassLoader()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果: 123456781956725890sun.misc.Launcher$AppClassLoader@18b4aac21956725890sun.misc.Launcher$AppClassLoader@18b4aac21836019240MyClassLoader@1540e19d325040804MyClassLoader@14ae5a5 5. 参考链接&lt;&lt;深入理解Java虚拟机—-JVM高级特性与最佳实践&gt;&gt;(第二版, 周志明)JVM类生命周期概述：加载时机与加载过程JVM 类加载机制深入浅出JVM(四)—一道面试题搞懂JVM类加载机制深入探讨 Java 类加载器Java 类加载机制详解全面解析Java类加载器深入理解Java类加载器(ClassLoader)JVM 类加载机制详解]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存区域和对象]]></title>
    <url>%2F2018%2F09%2F24%2FJVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[1. 前言作为一名Java后台开发的程序员, 深入理解JVM, 重要性不言而喻, 这篇文章主要是记录JVM内存区域相关知识. 2. 运行时数据区Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域, 如下图所示: 2.1 程序计数器当前线程所执行的字节码的行号指示器. 如果线程正在执行的是一个Java方法, 这个计数器记录的是正在执行的虚拟机字节码指令的地址; 如果正在执行的是Native方法, 这个计数器值则为空(Undefined). 2.1.1 程序计数器的作用 生活中的案例比如老王正在看电影, 他看到三十五分钟的时候, 突然他的QQ好友给他开视频聊天, 这时候肯定打断他看电影了, 假设他qq好友和他视频完了, 他肯定要接着他那35分钟的进度去继续看, 这时候他怎么知道我看到35分钟了? 这时候程序计数器就起了作用, 他负责管理进度. 代码层面的案例A线程正在执行HelloWorld.class的第三十五行. 这时候CPU时间片被B线程抢走了, 当A线程重新被分配到时间片时, 他怎么知道我的class运行到哪了? 这时候他可以看程序计数器在哪个位置. 2.2 Java虚拟机栈描述Java方法执行的内存模型: 每个方法被执行的时候都会同时创建一个栈帧, 用于存储局部变量表, 操作数栈, 动态链接, 方法出口等信息. 每一个方法从调用直至执行完成的过程, 就对应着一个栈帧在虚拟机中入栈到出栈的过程. 2.2.1 局部变量表存放了编译期可知的各种基本数据类型(boolean, byte, char, short, int, float, long, double), 对象引用(不等同于对象本身), returnAddress类型(指向了一条字节码指令的地址).long 和 double 类型的数据会占用2个局部变量空间, 其余的数据类型只占用1个.局部变量表所需的内存空间在编译期间完成分配. 2.2.2 两种异常状况 如果线程请求的栈深度大于虚拟机所允许的深度, 将抛出StackOverflowError异常; 如果虚拟机栈可以动态扩展, 并且扩展时无法申请到足够的内存, 就会抛出OutOfMemoryError异常. 2.3 本地方法栈与虚拟机栈所发挥的作用是非常相似的, Java虚拟机栈为虚拟机执行Java方法服务, 而本地方法栈为虚拟机使用的Native方法服务. 2.4 Java堆Java堆是被所有线程共享的一块内存区域, 在虚拟机启动时创建. 所有的对象实例以及数组都要在堆上分配. 这里是垃圾收集器管理的主要区域.Java堆可以处于物理上不连续的内存空间中. 2.4.1 异常如果在堆中没有内存完成实例分配, 并且堆也无法再扩展时, 将会抛出OutOfMemoryError异常. 2.5 方法区线程共享的内存区域, 存储已被虚拟机加载的类信息, 常量, 静态变量, 即时编译器编译后的代码数据等(这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载). 2.5.1 异常当方法区无法满足内存分配需求时, 将会抛出OutOfMemoryError异常. 2.5.2 运行时常量池在方法区中有一个非常重要的部分就是运行时常量池(JDK7之后, 已经挪到堆区里面了), 它是每一个类或接口的常量池的运行时表示形式, 在类和接口被加载到JVM后, 对应的运行时常量池就被创建出来. 当然并非Class文件常量池中的内容才能进入运行时常量池, 在运行期间也可将新的常量放入运行时常量池中, 比如String的intern方法.当运行时常量池无法申请到内存时, 将会抛出OutOfMemoryError异常. 2.6 直接内存直接内存不是虚拟机运行时数据区的一部分, 也不是java虚拟机规范中定义的内存区域. 但是这部分内存也被频繁使用, 可能抛出OutOfMemoryError异常. NIO类引入了一种基于通道与缓冲区(Buffer)的I/O方式, 它可以使用Native函数库直接分配堆外内存, 然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作, 这样能在一些场景中显著提高性能, 因此避免了在java堆和Native堆中来回复制数据. 服务器管理员容易忽略直接内存, 使得内存区域总和大于物理内存限制, 从而导致动态抛出OutOfMemoryError异常. 3. 对象3.1 创建过程下面我们详细了解Java程序中new一个普通对象时, 虚拟机是怎么样创建这个对象的, 包括5个步骤: 相应类加载检查过程、在Java堆中为对象分配内存、分配后内存初始化为零、对对象进行必要的设置、以及执行对象实例方法&lt; init &gt;. 3.1.1 相应类加载检查JVM遇到new指令时, 先检查指令参数是否能在常量池中定位到一个类的符号引用: 如果能定位到，检查这个符号引用代表的类是否已被加载、解析和初始化过； 如果不能定位到，或没有检查到，就先执行相应的类加载过程； 3.1.2 为对象分配内存对象所需内存的大小在类加载完成后便完全确定(JVM可以通过普通Java对象的类元数据信息确定对象大小)；为对象分配内存相当于把一块确定大小的内存从Java堆里划分出来； (A). 分配方式 (1). 指针碰撞如果Java堆是绝对规整的: 一边是用过的内存. 一边是空闲的内存. 中间一个指针作为边界指示器;分配内存只需向空闲那边移动指针, 这种分配方式称为“指针碰撞”(Bump the Pointer); (2). 空闲列表如果Java堆不是规整的: 用过的和空闲的内存相互交错;需要维护一个列表, 记录哪些内存可用;分配内存时查表找到一个足够大的内存, 并更新列表, 这种分配方式称为“空闲列表”(Free List); Java堆是否规整由JVM采用的垃圾收集器是否带有压缩功能决定的；所以，使用Serial、ParNew等带Compact过程的收集器时，JVM采用指针碰撞方式分配内存；而使用CMS这种基于标记-清除（Mark-Sweep）算法的收集器时，采用空闲列表方式； (B). 线程安全问题并发时, 上面两种方式分配内存的操作都不是线程安全的, 有两种解决方案: (1). 同步处理对分配内存的动作进行同步处理:JVM采用CAS(Compare and Swap)机制加上失败重试的方式, 保证更新操作的原子性;CAS: 有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做； (2). 本地线程分配缓冲区把分配内存的动作按照线程划分在不同的空间中进行:在每个线程在Java堆预先分配一小块内存, 称为本地线程分配缓冲区(Thread Local Allocation Buffer,TLAB);哪个线程需要分配内存就从哪个线程的TLAB上分配；只有TLAB用完需要分配新的TLAB时, 才需要同步处理；JVM通过”-XX：+/-UseTLAB”指定是否使用TLAB； 3.1.3 分配后内存初始化为零内存分配完成后, 虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头), 如果使用TLAB, 提前至分配TLAB时;这保证了程序中对象(及实例变量)不显式初始赋零值, 程序也能访问到零值. 3.1.4 对对象进行必要的设置主要设置对象头信息，包括类元数据引用、对象的哈希码、对象的GC分代年龄等; 3.1.5 执行对象实例方法&lt; init &gt;该方法把对象(实例变量)按照程序中定义的初始赋值进行初始化; 3.2 内存布局下面我们详细了解Java普通对象创建后, 在虚拟机Java堆中的内存布局是怎样的, 可以分为3个区域: 对象头(Header), 实例数据(Instance)和对齐填充(Padding). 3.2.1 对象头可以主要分为两部分: (A). 存储对象自身运行时数据称为”Mark Word”, 包括哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；这部分长度为32bit（32位JVM）或64bit（64位JVM）；被设计成一个非固定的数据结构，会根据对象的状态复用自己的存储空间，以便在极小的空间内存储尽量多信息；例如，32bit的Mark Word在未被锁定状态下，前25bit存储对象哈希码，4bit存储对象分代年龄，2bit存储锁标志位，1bit固定为0，如图所示 (B). 存储指向对象类型数据的指针通过这个指针确定这个对象是哪个类的实例;不是必须的, 看对象的访问定位方式:对HotSpot虚拟机来说, 由于JVM栈本地变量表中对象的reference类型引用使用直接指针, 该指针指向堆内存中的对象, 所以对象头中是需要存储它的类元数据指针, 该指针指向方法区中对象类型数据. (C). 如果是Java数组, 对象头还需要存储数组长度因为数组对象类型数据中没有数组长度信息;而JVM可以通过普通Java对象的类元数据信息确定对象大小; 3.2.2 实例数据它是对象真正存储的有效信息, 程序代码所定义的各种类型字段内容, 以及包括父类继承或子类定义的;存储顺序:受到JVM分配策略参数(FiedAllocationStyle)和字段在Java源码中定义顺序影响;JVM默认分配策略为: longs/doubles. ints. shorts/chars. booleans. oops(Ordiary Object Pointers);JVM默认分配策略使得, 相同宽度的字段总被分配到一起;这个前提下, 父类定义的变量出现在子类之前;如果虚拟机的”CompactFields”参数为true, 子类中较窄的变量可能插入到父类变量空隙中, 以压缩节省空间; 3.2.3 对齐填充不是必然存在的;只起占位符作用, 没有其他含义;HotSpot虚拟机要求对象大小必须是8字节的整数倍;对象头是8字节整数倍, 所以填充是对实例数据没有对齐的情况来说的. 3.3 访问定位下面我们详细了解在Java堆中的Java对象是如何访问定位的: 先来了解reference类型数据是什么, 再来了解两种访问方式: 使用句柄或者使用直接指针(HotSpot虚拟机使用了直接指针的方式访问对象). 3.3.1 referenceJava程序通过reference类型数据操作堆上的具体对象;reference类型是引用类型(Reference Types)的一种;JVM规范规定reference类型来表示对某个对象的引用, 可以想象成类似于一个指向对象的指针;对象的操作、传递和检查都通过引用它的reference类型的数据进行操作; 3.3.2 对象访问方式 虽然定义的reference类型数据来作为对象内存数据的引用, 但JVM规范没有定义这个引用应该通过何种方式定位, 访问堆上的对象, 也没有不强制规定对象的内部结构应当如何表示;这些都取决于JVM的实现, 目前主流的对象访问方式有两种:句柄访问 和 直接指针访问 3.3.2.1 句柄访问Java堆划分一块内存作为句柄池, reference中存储就是对象的句柄地址;对象句柄包含两个地址: 在堆中分配的对象实例数据的地址; 这个对象类型数据地址; 如图所示优点: 对象移动时(垃圾回收时常见的动作), reference不需要修改, 只改变句柄中实例数据指针; 3.3.2.2 直接指针访问reference中存储就是在堆中分配的对象实例数据的地址;而对象实例数据中需要有这个对象类型数据的相关信息(前面章节讨论了HotSpot使用对象头来存储对象类型数据地址);如图所示 优点: 对象访问时节省了一次指针定位的时间开销, 速度更快;由于对象访问非常频繁进行, 所以能较好提升性能;HotSpot虚拟机使用了直接指针的方式访问对象; 4. 参考链接&lt;&lt;深入理解Java虚拟机—-JVM高级特性与最佳实践&gt;&gt;(第二版, 周志明)JVM程序计数器Java中的常量池(字符串常量池、class常量池和运行时常量池)Java对象与JVM（一） Java对象在Java虚拟机中的创建过程Java对象与JVM（二） Java对象在Java虚拟机中的内存布局Java对象与JVM（三） Java对象在Java虚拟机中的引用访问方式]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中String.intern()]]></title>
    <url>%2F2018%2F09%2F24%2FJava%E4%B8%ADString.intern()%2F</url>
    <content type="text"><![CDATA[1. 前言学习JVM的时候, 看到了String.intern()这个方法, 以前没用过, 所以记录一下这个方法, 也帮助自己更好的理解运行时常量池. 2. 概述2.1 Java代码123456789101112131415161718192021222324/** * Returns a canonical representation for the string object. * &lt;p&gt; * A pool of strings, initially empty, is maintained privately by the * class &#123;@code String&#125;. * &lt;p&gt; * When the intern method is invoked, if the pool already contains a * string equal to this &#123;@code String&#125; object as determined by * the &#123;@link #equals(Object)&#125; method, then the string from the pool is * returned. Otherwise, this &#123;@code String&#125; object is added to the * pool and a reference to this &#123;@code String&#125; object is returned. * &lt;p&gt; * It follows that for any two strings &#123;@code s&#125; and &#123;@code t&#125;, * &#123;@code s.intern() == t.intern()&#125; is &#123;@code true&#125; * if and only if &#123;@code s.equals(t)&#125; is &#123;@code true&#125;. * &lt;p&gt; * All literal strings and string-valued constant expressions are * interned. String literals are defined in section 3.10.5 of the * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;. * * @return a string that has the same contents as this string, but is * guaranteed to be from a pool of unique strings. */public native String intern(); String.intern方法中看到, 这个方法是一个 native 的方法, 但注释写的非常明了. “如果运行时常量池中存在当前字符串, 就会直接返回当前字符串(不做额外操作);如果运行时常量池中没有此字符串, 会将此字符串放入运行时常量池中后, 再返回(JDK7中, 会将String的值也变为该字符串的直接引用)”. 2.2 实现思路它的大体实现思路就是:JAVA 使用 jni 调用c++实现的StringTable的intern方法, StringTable的intern方法跟Java中的HashMap的实现是差不多的, 只是不能自动扩容. 默认大小是1009, 要注意的是, String的String Pool是一个固定大小的Hashtable, 默认值大小长度是1009, 如果放进String Pool的String非常多, 就会造成Hash冲突严重, 从而导致链表会很长, 而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降. 在 jdk6中StringTable是固定的, 就是1009的长度, 所以如果常量池中的字符串过多就会导致效率下降很快. 在jdk7中, StringTable的长度可以通过一个参数指定: 1-XX:StringTableSize=99991 2.3 JDK6 和 JDK7 下 intern 的区别2.3.1 示例相信很多 Java 程序员都做做类似 String s = new String(“abc”)这个语句创建了几个对象的题目. 这种题目主要就是为了考察程序员对字符串对象的常量池掌握与否. 上述的语句中是创建了2个对象, 第一个对象是”abc”字符串存储在常量池中, 第二个对象在Java 堆中的 String 对象.示例1: 1234567891011public static void main(String[] args) &#123; String s = new String("1"); s.intern(); String s2 = "1"; System.out.println(s == s2); String s3 = new String("1") + new String("1"); s3.intern(); String s4 = "11"; System.out.println(s3 == s4);&#125; 运行结果: 12jdk6 下false falsejdk7 下false true 示例2: 1234567891011public static void main(String[] args) &#123; String s = new String("1"); String s2 = "1"; s.intern(); System.out.println(s == s2); String s3 = new String("1") + new String("1"); String s4 = "11"; s3.intern(); System.out.println(s3 == s4);&#125; 运行结果: 12jdk6 下false falsejdk7 下false false 2.3.2 JDK6中的解释注: 图中绿色线条代表 string 对象的内容指向. 黑色线条代表地址指向.如上图所示. 首先说一下 jdk6中的情况. 在 jdk6中上述的所有打印都是 false 的, 因为 jdk6中的常量池是放在 Perm 区中的, Perm区和正常的 JAVA Heap 区域是完全分开的. 上面说过如果是使用引号声明的字符串都是会直接在字符串常量池中生成, 而 new 出来的 String 对象是放在 JAVA Heap 区域. 所以拿一个 JAVA Heap 区域的对象地址和字符串常量池的对象地址进行比较肯定是不相同的, 即使调用String.intern方法也是没有任何关系的. 2.3.3 JDK7中的解释在 Jdk6 以及以前的版本中, 字符串的常量池是放在堆的Perm区的, Perm区是一个类静态的区域, 主要存储一些加载类的信息, 常量池, 方法片段等内容, 默认大小只有4m, 一旦常量池中大量使用 intern 是会直接产生java.lang.OutOfMemoryError:PermGen space错误的.在 jdk7 的版本中, 字符串常量池已经从Perm区移到正常的Java Heap区域了. 为什么要移动, Perm 区域太小是一个主要原因.正是因为字符串常量池移动到JAVA Heap区域后, 再来解释为什么会有上述的打印结果.在第一段代码中, 先看 s3和s4字符串. String s3 = new String(“1”) + new String(“1”);, 这句代码中现在生成了2最终个对象, 是字符串常量池中的“1” 和 JAVA Heap中的 s3引用指向的对象. 中间还有2个匿名的new String(“1”)我们不去讨论它们. 此时s3引用对象内容是”11″, 但此时常量池中是没有 “11”对象的. 接下来s3.intern();这一句代码, 是将 s3中的”11”字符串放入String 常量池中, 因为此时常量池中不存在”11”字符串, 因此常规做法是跟 jdk6 图中表示的那样, 在常量池中生成一个”11”的对象, 关键点是 jdk7 中常量池不在Perm区域了, 这块做了调整. 常量池中不需要再存储一份对象了, 可以直接存储堆中的引用. 这份引用指向s3引用的对象. 也就是说引用地址是相同的. 最后String s4 = “11”; 这句代码中”11″是显示声明的, 因此会直接去常量池中创建, 创建的时候发现已经有这个对象了, 此时也就是指向s3引用对象的一个引用. 所以s4引用就指向和s3一样了. 因此最后的比较 s3 == s4 是 true. 再看s和 s2 对象. String s = new String(“1”); 第一句代码, 生成了2个对象. 常量池中的“1” 和 JAVA Heap 中的字符串对象. s.intern(); 这一句是 s 对象去常量池中寻找后发现 “1” 已经在常量池里了. 接下来String s2 = “1”; 这句代码是生成一个 s2的引用指向常量池中的“1”对象. 结果就是 s 和 s2 的引用地址明显不同. 图中画的很清晰.来看第二段代码, 从上边第二幅图中观察. 第一段代码和第二段代码的改变就是 s3.intern(); 的顺序是放在String s4 = “11”;后了. 这样, 首先执行String s4 = “11”;声明 s4 的时候常量池中是不存在“11”对象的, 执行完毕后, “11“对象是 s4 声明产生的新对象. 然后再执行s3.intern();时, 常量池中“11”对象已经存在了, 因此 s3 和 s4 的引用是不同的.第二段代码中的 s 和 s2 代码中, s.intern();，这一句往后放也不会有什么影响了, 因为对象池中在执行第一句代码String s = new String(“1”);的时候已经生成“1”对象了. 下边的s2声明都是直接从常量池中取地址引用的. s 和 s2 的引用地址是不会相等的. 3. 小结写这篇博客想表达以下几个重点: JDK7之后,运行时常量池已经从方法区挪到了堆区. String.intern 方法时, 如果存在堆中的对象, 会直接保存以前对对象的引用, 而不会重新创建对象. 4. 参考链接String的Intern方法详解]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM类文件结构]]></title>
    <url>%2F2018%2F09%2F24%2FJVM%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1. 前言作为一名Java后台开发的程序员, 深入理解JVM, 重要性不言而喻, 这篇文章主要是记录JVM类文件结构相关知识. 2. 实例这部分比较抽象, 所以以实例的形式来学习. 这部分作为资料, 以便后面的章节用来翻阅. 2.1 实例代码12345public class Main &#123; public static void main(String[] args) &#123; System.out.println("Hello World!"); &#125;&#125; 2.2 实例二进制123456789101112131415161718192021222324252627282930313233cafe babe 0000 0034 0022 0a00 0600 14090015 0016 0800 170a 0018 0019 0700 1a07001b 0100 063c 696e 6974 3e01 0003 28295601 0004 436f 6465 0100 0f4c 696e 654e756d 6265 7254 6162 6c65 0100 124c 6f63616c 5661 7269 6162 6c65 5461 626c 65010004 7468 6973 0100 064c 4d61 696e 3b010004 6d61 696e 0100 1628 5b4c 6a61 76612f6c 616e 672f 5374 7269 6e67 3b29 56010004 6172 6773 0100 135b 4c6a 6176 612f6c61 6e67 2f53 7472 696e 673b 0100 0a536f75 7263 6546 696c 6501 0009 4d61 696e2e6a 6176 610c 0007 0008 0700 1c0c 001d001e 0100 0c48 656c 6c6f 2057 6f72 6c642107 001f 0c00 2000 2101 0004 4d61 696e0100 106a 6176 612f 6c61 6e67 2f4f 626a6563 7401 0010 6a61 7661 2f6c 616e 672f5379 7374 656d 0100 036f 7574 0100 154c6a61 7661 2f69 6f2f 5072 696e 7453 74726561 6d3b 0100 136a 6176 612f 696f 2f507269 6e74 5374 7265 616d 0100 0770 72696e74 6c6e 0100 1528 4c6a 6176 612f 6c616e67 2f53 7472 696e 673b 2956 0021 00050006 0000 0000 0002 0001 0007 0008 00010009 0000 002f 0001 0001 0000 0005 2ab70001 b100 0000 0200 0a00 0000 0600 01000000 0100 0b00 0000 0c00 0100 0000 05000c00 0d00 0000 0900 0e00 0f00 0100 09000000 3700 0200 0100 0000 09b2 0002 1203b600 04b1 0000 0002 000a 0000 000a 00020000 0003 0008 0004 000b 0000 000c 00010000 0009 0010 0011 0000 0001 0012 00000002 0013 2.3 javap分析javap -verbose Main.class 2.4 手工分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960cafe babe // 魔数0000 0034 // Class文件版本0022 // 常量池-容量计数器(34-1=33)0a 0006 0014 // 第1个常量09 0015 0016 // 第2个常量08 0017 // 第3个常量0a 0018 0019 // 第4个常量07 001a // 第5个常量07 001b // 第6个常量01 0006 3c 69 6e 69 74 3e // 第7个常量 &lt;init&gt;01 0003 28 29 56 // 第8个常量 ()V01 0004 43 6f 64 65 // 第9个常量 Code01 000f 4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 // 第10个常量 LineNumberTable01 0012 4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 // 第11个常量 LocalVariableTable01 0004 74 68 69 73 // 第12个常量 this01 0006 4c 4d 61 69 6e 3b // 第13个常量 LMain;01 0004 6d 61 69 6e // 第14个常量 main01 0016 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 29 56 // 第15个常量 ([Ljava/lang/String;)V01 0004 61 72 67 73 // 第16个常量 args01 0013 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b // 第17个常量 [Ljava/lang/String;01 000a 53 6f 75 72 63 65 46 69 6c 65 // 第18个常量 SourceFile01 0009 4d 61 69 6e 2e 6a 61 76 61 // 第19个常量 Main.java0c 0007 0008 // 第20个常量07 001c // 第21个常量0c 001d 001e // 第22个常量01 000c 48 65 6c 6c 6f 20 57 6f 72 6c 64 21 // 第23个常量 Hello World!07 001f // 第24个常量0c 0020 0021 // 第25个常量01 0004 4d 61 69 6e // 第26个常量 Main01 0010 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74 // 第27个常量 java/lang/Object01 0010 6a 61 76 61 2f 6c 61 6e 67 2f 53 79 73 74 65 6d // 第28个常量 java/lang/System01 0003 6f 75 74 // 第29个常量 out01 0015 4c 6a 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 3b // 第30个常量 Ljava/io/PrintStream;01 0013 6a 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d // 第31个常量 java/io/PrintStream01 0007 70 72 69 6e 74 6c 6e // 第32个常量 println01 0015 28 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 29 56 // 第33个常量 (Ljava/lang/String;)V0021 // 访问标志0005 // 类索引0006 // 父类索引0000 // 接口索引集合0000 // 字段表集合0002 // 方法表集合.计数器(2)0001 // 第1个方法:方法访问标识符0007 // 第1个方法:方法名称索引项0008 // 第1个方法:方法描述符索引项0001 // 第1个方法:属性表计数器(1)0009 // 第1个方法:属性名字0000 002f // 第1个方法:属性长度(47)00 01 00 01 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 00 00 06 00 01 00 00 00 01 00 0b 00 00 00 0c 00 01 00 00 00 05 00 0c 00 0d 00 00 // 第1个方法:属性info0009 // 第2个方法:方法访问标识符000e // 第2个方法:方法名称索引项000f // 第2个方法:方法描述符索引项0001 // 第2个方法:属性表计数器(1)0009 // 第2个方法:属性名字0000 0037 // 第2个方法:属性长度(55)00 02 00 01 00 00 00 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a 00 00 00 0a 00 02 00 00 00 03 00 08 00 04 00 0b 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 // 第2个方法:属性info0001 // Class文件属性表计数器(1)0012 // 属性名字0000 0002 // 属性长度(2)00 13 // 属性info 3. Class类文件结构Java 虚拟机规范中定义了许多规范, 其中有一部分定义了字节码的结构和规范. Java 虚拟机规范定义了两种数据类型来表示 Class 文件格式, 分别是: 无符号数和表.无符号数属于最基本的数据类型, 以 u1, u2, u4, u8分别代表 1 个字节, 2 个字节, 4 个字节, 8 个字节的无符号数, 无符号数可以用来描述数字, 索引引用, 数量值或者按照 UTF-8 编码构成的字符串值.表是由多个无符号数或者其他表作为数据项构成的复合数据类型, 所有表都习惯性地以”_info”结尾. 表用于描述由层次关系的复合结构的数据, 整个Class文件本质上就是一张表.整个 Class 文件本质上就是一张表, 它由表下表所示的数据项构成. 3.1 魔数Class 文件的第 1 - 4 个字节代表了该文件的魔数()Magic Number). 它唯一的作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件, 其值固定是: 0xCAFEBABE(咖啡宝贝). 如果一个 Class 文件的魔数不是 0xCAFEBABE, 那么虚拟机将拒绝运行这个文件. 3.1.1 实例对照我们看看实例部分, 其前 4 个字节分别是：cafe babe 3.2 Class文件版本Class 文件的第 5 - 6 个字节代表了 Class 文件的次版本号(Minor Version), 即编译该 Class 文件的 JDK 次版本号。Class 文件的第 7 - 8 个字节代表了 Class 文件的主版本号(Major Version), 即编译该 Class 文件的 JDK 主版本号。高版本的 JDK 能向下兼容以前的 Class 文件, 但不能运行新版本的 Class 文件.例如一个 Class 文件是使用 JDK 1.5 编译的, 那么我们可以用 JDK 1.7 虚拟机运行它, 但不能用 JDK 1.4 虚拟机运行它.下表列出了各个版本 JDK 的十六进制版本号信息: 3.2.1 实例对照我们看看实例部分, 其 5 - 8 个字节分别是：0000 0034, 那么我们可以知道, 这个 Class 文件是由 JDK1.8 编译的. 3.3 常量池紧接着主次版本号之后是常量池入口, 由于常量池中常量的数量是不固定的, 所以在常量池的入口需要放置一个常量池容量计数值(constant_pool_count), 这个容量计数是从1而不是0开始的, 设计者这样设计的目的是为了满足后面某些指向常量池的索引值的数据在特殊情况下需要表达”不引用任何一个常量池项目”的含义.Class文件结构中只有常量池的容量计数是从1开始的, 索引集合. 字段集合. 方法集合. 属性集合的容量计数都是从0开始的.注意, Long和Double型占用两个计数.常量池中主要存放两大类常量: 字面量(Literal)和符号引用.字面量接近Java语言层面的常量概念, 如文本字符串. 声明为final的常量值等.符号引用属于编译原理的概念, 包括三类常量: 类和接口的全限定名; 字段的名称和描述符; 方法的名称和描述符. 常量池中每一项常量都是一个表, 在JDK1.7之后共有14种表结构, 它们有一个共同的特点, 就是表开始的第一位是一个u1类型的标志位(tag, 取值见下表), 代表当前这个常量属于哪种常量类型.每个常量池的常量都用一个类型为 cp_info 的表表示, 该表有 14 个值, 分别是:常量池中的14种常量项的结构总表: 3.3.1 实例对照我们Class 文件第 9 - 10 个字节为 0022, 表示有 33 个常量. 第 1 个常量. 紧接着 0022 的后一个字节为 0a, 表示该常量为CONSTANT_MethodHandle_info. 从上面的总表查阅知道, 该常量项第 2 - 3 个字节表示方法的类描述符, 这里是 0006 表示指向常量池第 6 个常量所表示的信息. 该常量项的第 4 - 5 个字节表示名称及类描述符, 这里值为 0014 表示指向常量池第 20 个常量所表示的信息. 第 2 个常量. 紧接着 0014 的后一个字节为 09, 表示该常量为CONSTANT_Fieldref_info. 从上面的总表查阅知道, 该常量项第 2 - 3 个字节表示字段的类或者接口描述符, 这里是 0015 表示指向常量池第 21 个常量所表示的信息. 该常量项的第 4 - 5 个字节表示字段描述符, 这里值为 0016 表示指向常量池第 22 个常量所表示的信息. 第 3 个常量. 紧接着 0016 的后一个字节为 08, 表示该常量为CONSTANT_String_info. 从上面的总表查阅知道, 该常量项第 2 - 3 个字节表示指向字符串字面量的索引, 这里是 0017 表示指向常量池的第 23 个常量. 第 4 个常量. 紧接着 0017 的后一个字节为 0a, 表示该常量为CONSTANT_MethodHandle_info的常量. 从上面的总表查阅知道, 该常量项第 2 - 3 个字节表示方法的类描述符, 这里是 0018 表示指向常量池第 24 个常量所表示的信息. 该常量项的第 4 - 5 个字节表示名称及类描述符, 这里值为 0019 表示指向常量池第 25 个常量所表示的信息. 第 5 个常量. 紧接着 0019 的后一个字节为 07, 表示该常量为CONSTANT_Class_info的常量. 从上面的总表查阅知道, 该常量项第 2 - 3 个字节表示全限定名常量项, 这里是 001a 表示指向常量池第 26 个常量所表示的信息.……更多可以参考 2.实例 部分中的分析. 3.4 访问标志在常量池结束之后, 紧接着的两个字节代表访问标记(access_flags), 这个标志用于识别一些类或者接口层次的访问信息, 包括: 这个Class是类还是接口, 是否定义为public类型, 是否定义为abstract类型等. 具体的标志位以及标志的含义见下表. 3.4.1 实例对照在实例里面, 这两个字节是 00 21, 通过查看我们并没有发现有标志值是 00 21 的标志名称. 这是因为这里的访问标志可能是由多个标志名称组成的, 所以字节码文件中的标志值其实是多个值进行或运算的结果.通过查阅上述表格, 我们可以知道, 00 21 由 00 01 和 00 20 进行或运算得来, 也就是说该类的访问标志是 public 并且允许使用 invokespecial 字节码指令的新语义. 3.5 类索引, 父类索引和接口索引集合类索引和父类索引都是一个u2类型的数据, 而接口索引集合是一组u2类型的数据的集合, Class文件中由这三项数据来确定这个类的继承关系. 3.5.1 实例对照类索引. 类索引用于确定这个类的全限定名, 它用一个 u2 类型的数据表示. 这里的类索引是 00 05 表示其指向了常量池中第 5 个常量, 通过我们之前的分析, 我们知道第 5 个常量其最终的信息是 Main 类.父类索引. 父类索引用于确定这个类的父类的全限定名, 父类索引用一个u2类型的数据表示. 这里的父类索引是 00 06 表示其指向了常量池中第 6 个常量, 通过我们之前的分析, 我们知道第 6 个常量其最终的信息是 Object 类. 因为其并没有继承任何类, 所以 Demo 类的父类就是默认的 Object 类.接口索引. 接口索引集合就用来描述哪个类实现了哪些接口, 这些被实现的接口将按 implements 语句(如果这个类本身就是一个接口, 则应当是extends语句)后的接口顺序从左到右排列在接口索引集合中. 对于接口索引集合, 入口第一项是 u2 类型的数据为接口计数器(interfaces_count), 表示索引表的容量, 而在接口计数器后则紧跟着所有的接口信息. 如果该类没有实现任何接口, 则该计数器值为0, 后面接口的索引表不再占用任何字节.这里 Main 类的字节码文件中, 因为并没有实现任何接口, 所以紧跟着父类索引后的两个字节是0x0000, 这表示该类没有实现任何接口. 因此后面的接口索引表为空. 3.6 字段表集合字段表集合用于描述接口或者类中声明的变量. 这里说的字段包括类级变量和实例级变量, 但不包括在方法内部声明的局部变量.在类接口集合后的2个字节是一个字段计数器, 表示总有有几个属性字段. 在字段计数器后, 才是具体的属性数据. 字段表的每个字段用一个名为 field_info 的表来表示, field_info 表的数据结构如下所示:字段访问标志:跟随 字段访问标志 的是两项索引值: name_index和 descriptor_index. 它们都是对常量池的引用, 分别代表字段的简单名称 以及 字段和方法的描述符.描述符的作用是描述字段的数据类型, 方法的参数列表(包括数量, 类型及顺序)和返回值.根据描述符的规则, 基本数据类型以及代表无返回值的void类型都用一个大写字符来表示, 而对象类型则用字符L加对象的全限定名表示, 见下表对于数组类型, 每一维度将使用一个前置的”[“字符来描述. 如”String[][]”, 会被记录为”[[Ljava/lang/String”,”int[]”被记录为”[I”.描述符描述方法时, 按照先参数列表, 后返回值的顺序描述. 参数列表按照参数的严格顺序放置一组小括号“()”内, 如void inc()的描述符为“()V”,“viod main(String[] args)”的描述符为“([Ljava/lang/String;)V”,“int indexOf(char[] source,int sourceOffset,int sourceCount,char[] target,int targetOffset,int targetCount,int fromIndex)”的描述符为“([CII[CIII)I”.字段表都包含的固定数据项到descriptor_index为止就结束了, 不过在descriptor_index之后跟随着一个属性表集合用于存储一些额外的信息, 字段都可以在属性表中描述零至多项的额外信息.字段表集合中不会列出从超类或者父类接口中继承而来的字段, 但有可能列出原本Java代码之中不存在的字段. 3.6.1 实例对照因为我们并没有声明任何的类成员变量或类变量, 所以在 Main 的字节码文件中, 字段计数器为 00 00, 表示没有属性字段. 3.7 方法表集合在字段表后的 2 个字节是一个方法计数器, 表示类中总有有几个方法. 在字段计数器后, 才是具体的方法数据, 方法表中的每个方法都用一个 method_info 表示, 其数据结构如下:方法表所包含的数据项目的含义也和字段表集合的非常的类似, 仅在访问标志和属性表集合的可选项中有所区别. 由于volatile, transient关键字不能修饰方法, 同时synchronized, native, strictfp和abstract关键字可以修饰方法. 对于方法表, 所有标志位及其取值如下通过访问标志, 名称索引, 描述符索引可清楚的表达方法的定义. 那方法里面的代码去哪里了呢? 方法里的Java代码经过编译器编译成字节码指令后, 存放在方法属性表集合中属性表中; 这个属性表的名称为”Code”. 属性表是Class文件格式中最具扩展性的一种数据项目.与字段表集合相对应的, 如果父类方法在子类中没有被重写(Override), 方法表集合中就不会出现来自父类的方法信息, 但可能出现编译器自动添加的方法, 最典型的便是类构造器”&lt;clinit&gt;”方法和实例构造器”&lt;init&gt;”方法.在Java语言中, 重载(Overload)一个方法, 1.要与原方法具有相同的简单名称. 2.要与原方法有不同的特征签名.Java代码的方法特征签名只包括方法名称, 参数顺序及参数类型; 而字节码的特征签名还包括方法返回值以及受查异常表. 3.7.1 实例对照Main 类的字节码文件中, 方法计数器的值为 00 02, 表示一共有 2 个方法.第 1 个方法. 方法计数器后 2 个字节表示方法访问标识, 这里是 00 01, 表示其实 ACC_PUBLIC 标识, 即该方法访问表示为 public.紧 接着 2 个字节表示方法名称的索引, 这里是 00 07 表示指向了常量池第 7 个常量, 查阅可知其指向了&lt;init&gt;. 紧接着的 2 个字节表示方法描述符索引项, 这里是 00 08 表示指向了常量池第 8 个常量, 查阅可知其指向了()V. 紧接着 2 个字节表示属性表计数器, 这里是 00 01 表示该方法一共有 1 个属性. 紧接着的一连串就是属性表的内容. 3.8 属性表集合在Class文件, 字段表, 方法表, 属性表都可以携带自己的属性表集合, 用于描述某些场景专有的信息.与Class文件中其他的数据项目要求严格的顺序, 长度和内容不同, 属性表集合的限制稍微宽松了一些, 不再要求各个属性表具有严格顺序, 并且只要不与已有属性名重复, 任何人实现的编译器都可以想属性表中写入自己定义的属性信息, Java虚拟机运行时会忽略掉它不认识的属性. 下边将介绍一些关键常用的属性.虚拟机规范预定义的属性: 属性名称 使用位置 含义 Code 方法表 Java代码编译成的字节码指令 ConstantValue 字段表 final关键字定义的常量值 Deprecated 类、方法表、字段表 被声明为deprecated的方法和字段 Exceptions 方法表 方法抛出的异常 EnclosingMethod 类文件 仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法 InnerClasses 类文件 内部类列表 LineNumberTable Code属性 Java源码的行号与字节码指令的对应关系 LocalVariableTable Code属性 方法的局部变量描述 StackMapTable Code属性 JDK1.6中新增的属性，供新的类型检查验证器（Type Checker）检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配 Signature 类、方法表、字段表 JDK1.5中新增的属性，这个属性用于支持泛型情况下的方法签名，在Java语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则Signature属性会为它记录泛型签名信息。由于Java的泛型采用擦除法实现，在为了避免类型信息被擦除后导致签名混乱，需要这个属性记录泛型中的相关信息 SourceFile 类文件 记录源文件名称 SourceDebugExtension 类文件 JDK1.6中新增的属性，SourceDebugExtension属性用于存储额外的调试信息。譬如在进行JSP文件调试时，无法通过Java堆栈来定位JSP文件的行号，JSR-45规范为这些非Java语言编写，却需要编译成字节码并运行在Java虚拟机中的程序提供了一个进行调试的标准机制，使用SourceDebugExtension属性就可以用于存储这个标准所新加入的调试信息 Synthetic 类、方法表、字段表 标识方法或字段为编译器自动生成的 LocalVariableTypeTable 类 JDK1.5中新增的属性，它使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加 RuntimeVisibleAnnotations 类、方法表、字段表 JDK1.5新增的属性，为动态注解提供支持。RuntimeVisibleAnnotations属性用于注明哪些注解是运行时（实际上运行时就是进行反射调用）可见的 RuntimeInvisibleAnnotations 类、方法表、字段表 JDK1.5新增的属性，与RuntimeVisibleAnnotations属性作用刚好相反，用于指明哪些注解是运行时不可见的 RuntimeVisibleParameterAnnotations 方法表 JDK1.5新增的属性，作用与RuntimeVisibleAnnotations属性类似，只不过作用对象为方法参数 RuntimeInvisibleParameterAnnotations 方法表 JDK1.5新增的属性，作用与RuntimeInvisibleAnnotations属性类似，只不过作用对象为方法参数 AnnotationDefault 方法表 JDK1.5新增的属性，用于记录注解类元素的默认值 BootstrapMethods 类文件 JDK1.7中新增的属性，用于保存invokedynamic指令引用的引导方法限定符 对于每个属性, 它的名称需要从常量池引用一个CONSTANT_Utf8_info类型的常量来表示, 而属性值的结构则完全自定义的, 只需要通过一个u4的长度属性去说明属性值所占用的位数即可. 一个符合规则的属性表应该满足以下定义结构.属性表结构: 类型 名称 数量 u2 attribute_name_index 1 u4 attribute_length 1 u1 info attribute_length attribute_name_index是指向CONSTANT_Utf8_info类型常量的索引, CONSTANT_Utf8_info类型常量记录着属性的名称; attribute_length标识属性值所占用的位数. 3.8.1 实例对照这里不做过多扩展了, 每种属性具体的定义参考书就可以了. 4. 参考链接&lt;&lt;深入理解Java虚拟机—-JVM高级特性与最佳实践&gt;&gt;(第二版, 周志明)从 HelloWorld 看 Java 字节码文件结构Java类文件结构详解]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java自动装箱拆箱]]></title>
    <url>%2F2018%2F09%2F24%2FJava%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[1. 前言在后台开发的过程中, 使用框架开发, 经常会不得已遇到自动拆装箱的问题, 这篇文章主要是记录自动拆箱装箱的相关知识, 便于自己写出高质量的代码. 2. 概述2.1 什么是自动装箱拆箱很简单, 下面两句代码就可以看到装箱和拆箱过程. 1234//自动装箱Integer total = 99;//自定拆箱int totalprim = total; 简单一点说, 装箱就是自动将基本数据类型转换为包装器类型; 拆箱就是自动将包装器类型转换为基本数据类型.下面我们来看看需要装箱拆箱的类型有哪些: 2.2 执行过程这个过程是自动执行的, 那么我们需要看看它的执行过程: 12345678public class Main &#123; public static void main(String[] args) &#123; //自动装箱 Integer total = 99; //自定拆箱 int totalprim = total; &#125;&#125; 反编译class文件之后得到如下内容: 1javap -c Main.class Integer total = 99;执行上面那句代码的时候, 系统为我们执行了:Integer total = Integer.valueOf(99); int totalprim = total;执行上面那句代码的时候，系统为我们执行了:int totalprim = total.intValue(); 我们现在就以Integer为例, 来分析一下它的源码 2.2.1 Integer.valueOf函数123public static Integer valueOf(int i) &#123; return i &gt;= 128 || i &lt; -128 ? new Integer(i) : SMALL_VALUES[i + 128];&#125; 它会首先判断i的大小: 如果i小于-128或者大于等于128. 就创建一个Integer对象. 否则执行SMALL_VALUES[i + 128].首先我们来看看Integer的构造函数: 1234567private final int value;public Integer(int value) &#123; this.value = value;&#125;public Integer(String string) throws NumberFormatException &#123; this(parseInt(string));&#125; 它里面定义了一个value变量, 创建一个Integer对象, 就会给这个变量初始化. 第二个传入的是一个String变量, 它会先把它转换成一个int值, 然后进行初始化.下面看看SMALL_VALUES[i + 128]是什么东西: 1private static final Integer[] SMALL_VALUES = new Integer[256]; 它是一个静态的Integer数组对象, 也就是说最终valueOf返回的都是一个Integer对象.所以我们这里可以总结一点: 装箱的过程会创建对应的对象, 这个会消耗内存, 所以装箱的过程会增加内存的消耗, 影响性能. 2.2.2 intValue函数1234@Overridepublic int intValue() &#123; return value;&#125; 这个很简单, 直接返回value值即可. 2.2.3 相关问题上面我们看到在Integer的构造函数中, 它分两种情况: i &gt;= 128 || i &lt; -128 =====&gt; new Integer(i) i &lt; 128 &amp;&amp; i &gt;= -128 =====&gt; SMALL_VALUES[i + 128] 1private static final Integer[] SMALL_VALUES = new Integer[256]; SMALL_VALUES本来已经被创建好, 也就是说在i &gt;= 128 || i &lt; -128是会创建不同的对象, 在i &lt; 128 &amp;&amp; i &gt;= -128会根据i的值返回已经创建好的指定的对象. 12345678910public class Main &#123; public static void main(String[] args) &#123; Integer i1 = 100; Integer i2 = 100; Integer i3 = 200; Integer i4 = 200; System.out.println(i1==i2); //true System.out.println(i3==i4); //false &#125;&#125; 代码的后面, 我们可以看到它们的执行结果是不一样的, 为什么, 在看看我们上面的说明. i1和i2会进行自动装箱, 执行了valueOf函数, 它们的值在[-128,128)这个范围内, 它们会拿到SMALL_VALUES数组里面的同一个对象SMALL_VALUES[256], 它们引用到了同一个Integer对象, 所以它们肯定是相等的. i3和i4也会进行自动装箱, 执行了valueOf函数, 它们的值大于128, 所以会执行new Integer(200), 也就是说它们会分别创建两个不同的对象, 所以它们肯定不等. 下面我们来看看另外一个例子: 12345678910public class Main &#123; public static void main(String[] args) &#123; Double i1 = 100.0; Double i2 = 100.0; Double i3 = 200.0; Double i4 = 200.0; System.out.println(i1==i2); //false System.out.println(i3==i4); //false &#125;&#125; 看看上面的执行结果, 跟Integer不一样, 这样也不必奇怪, 因为它们的valueOf实现不一样, 结果肯定不一样, 那为什么它们不统一一下呢?这个很好理解, 因为对于Integer, 在[-128,128)之间只有固定的256个值, 所以为了避免多次创建对象, 我们事先就创建好一个大小为256的Integer数组SMALL_VALUES, 所以如果值在这个范围内, 就可以直接返回我们事先创建好的对象就可以了.但是对于Double类型来说, 我们就不能这样做, 因为它在这个范围内个数是无限的.总结一句就是: 在某个范围内的整型数值的个数是有限的, 而浮点数却不是.所以在Double里面的做法很直接, 就是直接创建一个对象, 所以每次创建的对象都不一样. 123public static Double valueOf(double d) &#123; return new Double(d);&#125; 下面我们进行一个归类:Integer派别: Integer, Short, Byte, Character, Long这几个类的valueOf方法的实现是类似的.Double派别: Double, Float的valueOf方法的实现是类似的. 每次都返回不同的对象.下面对Integer派别进行一个总结, 如下图:下面我们来看看另外一种情况: 12345678910public class Main &#123; public static void main(String[] args) &#123; Boolean i1 = false; Boolean i2 = false; Boolean i3 = true; Boolean i4 = true; System.out.println(i1==i2);//true System.out.println(i3==i4);//true &#125;&#125; 可以看到返回的都是true, 也就是它们执行valueOf返回的都是相同的对象. 123public static Boolean valueOf(boolean b) &#123; return b ? Boolean.TRUE : Boolean.FALSE;&#125; 可以看到它并没有创建对象, 因为在内部已经提前创建好两个对象, 因为它只有两种情况, 这样也是为了避免重复创建太多的对象. 12public static final Boolean TRUE = new Boolean(true);public static final Boolean FALSE = new Boolean(false); 上面把几种情况都介绍到了 , 下面来进一步讨论其他情况. 123Integer num1 = 400; int num2 = 400; System.out.println(num1 == num2); //true 说明num1 == num2进行了拆箱操作 123Integer num1 = 100; int num2 = 100; System.out.println(num1.equals(num2)); //true 我们先来看看equals源码: 1234@Overridepublic boolean equals(Object o) &#123; return (o instanceof Integer) &amp;&amp; (((Integer) o).value == value);&#125; 我们指定equal比较的是内容本身, 并且我们也可以看到equal的参数是一个Object对象, 我们传入的是一个int类型, 所以首先会进行装箱, 然后比较, 之所以返回true , 是由于它比较的是对象里面的value值. 123456Integer num1 = 100; int num2 = 100; Long num3 = 200l; System.out.println(num1 + num2); //200System.out.println(num3 == (num1 + num2)); //trueSystem.out.println(num3.equals(num1 + num2)); //false 当一个基础数据类型与封装类进行==, +, -, *, /运算时, 会将封装类进行拆箱, 对基础数据类型进行运算. 对于num3.equals(num1 + num2)为false的原因很简单, 我们还是根据代码实现来说明: 1234@Overridepublic boolean equals(Object o) &#123; return (o instanceof Long) &amp;&amp; (((Long) o).value == value);&#125; 它必须满足两个条件才为true: 类型相同 内容相同 上面返回false的原因就是类型不同. 1234Integer num1 = 100;Integer num2 = 200;Long num3 = 300l;System.out.println(num3 == (num1 + num2)); //true 我们来反编译一些这个class文件:可以看到运算的时候首先对num3进行拆箱(执行num3的longValue得到基础类型为long的值300), 然后对num1和mum2进行拆箱(分别执行了num1和num2的intValue得到基础类型为int的值100和200), 然后进行相关的基础运算.我们来对基础类型进行一个测试: 1234int num1 = 100;int num2 = 200;long num3 = 300;System.out.println(num3 == (num1 + num2)); //true 就说明了为什么最上面会返回true.所以, 当 “==”运算符的两个操作数都是 包装器类型的引用, 则是比较指向的是否是同一个对象, 而如果其中有一个操作数是表达式(即包含算术运算)则比较的是数值(即会触发自动拆箱的过程).陷阱: 12Integer integer100=null; int int100=integer100; 这两行代码是完全合法的, 完全能够通过编译的,但 是在运行时, 就会抛出空指针异常.其 中, integer100为Integer类型的对象, 它当然可以指向null. 但在第二行时, 就会对integer100进行拆箱. 也就是对一个null对象执行intValue()方法, 当然会抛出空指针异常.所 以, 有拆箱操作时一定要特别注意封装类对象是否为null. 3. 特别强调当两种不同类型用==比较时, 包装器类的会拆箱;当同种类型用==比较时, 会直接比较.(int 与 Integer 属于不同类型) 4. 参考链接详解Java的自动装箱与拆箱(Autoboxing and unboxing)]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java注解]]></title>
    <url>%2F2018%2F09%2F24%2FJava%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. 前言使用框架的时候, 经常会遇到注解, 为了更好的阅读框架源码, 同时为了让自己的代码质量更高, 所以写这篇文章来记录注解相关的知识. 2. JDK中的常见注解@Override 用于修饰此方法覆盖了父类的方法;@Deprecated 用于修饰已经过时的方法;@SuppressWarings(“deprecation”) 用于通知Java编译器忽略特定的编译警告. 3. 注解的分类源码注解: 注解只在源码中存在, 编译成.class文件就不存在了编译时注解: 注解在源码和.class文件中都存在(如: JDK内置系统注解)运行时注解: 在运行阶段还起作用, 甚至会影响运行逻辑的注解(如: Spring中@Autowried) 元注解: 注解的注解 4. 自定义注解4.1 注解定义123456789@Target(&#123;ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Description &#123; String desc(); String author(); int age() default 18;&#125; 4.2注解应用1234@Description(desc = "I am eyeColor", author = "My body")public String eyeColor()&#123; return "red";&#125; 4.3 元注解元注解是什么意思呢?元注解是可以注解到注解上的注解, 或者说元注解是一种基本注解, 但是它能够应用到其它的注解上面.元标签有 @Retention, @Documented, @Target, @Inherited, @Repeatable 5 种. 4.3.1 @RetentionRetention 的英文意为保留期的意思. 当 @Retention 应用到一个注解上的时候, 它解释说明了这个注解的的存活时间.它的取值如下: RetentionPolicy.SOURCE 注解只在源码阶段保留, 在编译器进行编译时它将被丢弃忽视. RetentionPolicy.CLASS 注解只被保留到编译进行的时候, 它并不会被加载到 JVM 中. RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候, 它会被加载进入到 JVM 中, 所以在程序运行时可以获取到它们. 123@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123;&#125; 4.3.2 @Documented顾名思义, 这个元注解肯定是和文档有关. 它的作用是能够将注解中的元素包含到 Javadoc 中去. 1234@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface TestAnnotation &#123;&#125; 4.3.3 @TargetTarget 是目标的意思, @Target 指定了注解运用的地方. ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 12345@Retention(RetentionPolicy.RUNTIME)@Documented@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)public @interface TestAnnotation &#123;&#125; 4.3.4 @InheritedInherited 是继承的意思, 但是它并不是说注解本身可以继承, 而是说如果一个超类被 @Inherited 注解过的注解进行注解的话, 那么如果它的子类没有被任何注解应用的话, 那么这个子类就继承了超类的注解. 12345678@Inherited@Retention(RetentionPolicy.RUNTIME)@interface Test &#123;&#125;@Testpublic class A &#123;&#125;public class B extends A &#123;&#125; 注解 Test 被 @Inherited 修饰, 之后类 A 被 Test 注解, 类 B 继承 A,类 B 也拥有 Test 这个注解. 4.3.5 @RepeatableRepeatable 自然是可重复的意思. @Repeatable 是 Java 1.8 才加进来的, 所以算是一个新的特性.什么样的注解会多次应用呢?通常是注解的值可以同时取多个.举个例子, 一个人他既是程序员又是产品经理,同时他还是个画家. 1234567891011121314@interface Persons &#123; Person[] value();&#125;@Repeatable(Persons.class)@interface Person&#123; String role() default "";&#125;@Person(role="artist")@Person(role="coder")@Person(role="PM")public class SuperMan&#123;&#125; 注意上面的代码, @Repeatable 注解了 Person. 而 @Repeatable 后面括号中的类相当于一个容器注解.什么是容器注解呢? 就是用来存放其它注解的地方. 它本身也是一个注解.我们再看看代码中的相关容器注解. 123@interface Persons &#123; Person[] value();&#125; 按照规定, 它里面必须要有一个 value 的属性, 属性类型是一个被 @Repeatable 注解过的注解数组, 注意它是数组. 4.4 注解属性注解的属性也叫做成员变量. 注解只有成员变量, 没有方法. 注解的成员变量在注解的定义中以”无形参的方法”形式来声明, 其方法名定义了该成员变量的名字, 其返回值定义了该成员变量的类型. 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; int id(); String msg();&#125; 上面代码定义了 TestAnnotation 这个注解中拥有 id 和 msg 两个属性. 在使用的时候, 我们应该给它们进行赋值.赋值的方式是在注解的括号内以 value=”” 形式, 多个属性之前用, 隔开. 123@TestAnnotation(id=3,msg="hello annotation")public class Test &#123;&#125; 需要注意的是, 在注解中定义属性时它的类型必须是 8 种基本数据类型外加 类、接口、注解及它们的数组.注解中属性可以有默认值, 默认值需要用 default 关键值指定 .比如: 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; public int id() default -1; public String msg() default "Hi";&#125; TestAnnotation 中 id 属性默认值为 -1, msg 属性默认值为 Hi.它可以这样应用. 12@TestAnnotation()public class Test &#123;&#125; 因为有默认值, 所以无需要再在 @TestAnnotation 后面的括号里面进行赋值了, 这一步可以省略.另外, 还有一种情况. 如果一个注解内仅仅只有一个名字为 value 的属性时, 应用这个注解时可以直接接属性值填写到括号内. 123public @interface Check &#123; String value();&#125; 上面代码中, Check 这个注解只有 value 这个属性. 所以可以这样应用. 12@Check("hi")int a; 这和下面的效果是一样的 12@Check(value="hi")int a; 最后, 还需要注意的一种情况是一个注解没有任何属性. 比如 1public @interface Perform &#123;&#125; 那么在应用这个注解的时候, 括号都可以省略. 12@Performpublic void testMethod()&#123;&#125; 4.5 语法总结 使用@interface关键字定义注解 无参无异常声明成员 可用default为成员指定一个默认值 合法成员类型, 包括: 基本数据类型, String, Class, Annotation和Enumeration 如只有一个成员, 则成员名必须为value(), 且使用时可忽略”value=” 注解类可以没有成员, 没有成员的注解称为标识注解. 5. 注解的提取与应用博文前面的部分讲了注解的基本语法, 要想提取注解, 离不开一个手段, 那就是反射. 5.1 注解与反射 1.注解通过反射获取. 首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解 1public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) &#123;&#125; 2.1.然后通过 getAnnotation() 方法来获取 Annotation 对象. 1public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) &#123;&#125; 2.2.或者是 getAnnotations() 方法. 1public Annotation[] getAnnotations() &#123;&#125; 前一种方法返回指定类型的注解, 后一种方法返回注解到这个元素上的所有注解. 3.如果获取到的 Annotation 如果不为 null, 则就可以调用它们的属性方法了. 比如 1234567891011@TestAnnotation()public class Test &#123; public static void main(String[] args) &#123; boolean hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class); if ( hasAnnotation ) &#123; TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class); System.out.println("id:"+testAnnotation.id()); System.out.println("msg:"+testAnnotation.msg()); &#125; &#125;&#125; 程序的运行结果是: 12id:-1msg:Hi 这个正是 TestAnnotation 中 id 和 msg 的默认值.上面的例子中, 只是检阅出了注解在类上的注解, 其实属性, 方法上的注解照样是可以的. 同样还是要假手于反射.这里我就不继续举例子了.需要注意的是, 如果一个注解要在运行时被成功提取, 那么 @Retention(RetentionPolicy.RUNTIME) 是必须的. 5.2 注解的使用场景注解主要给编译器及工具类型的软件用的. 5.3 注解的缺点注解的提取需要借助于 Java 的反射技术, 反射比较慢, 所以注解使用时也需要谨慎计较时间成本. 6. 参考链接全面解析Java注解秒懂，Java 注解 （Annotation）你可以这样学]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射]]></title>
    <url>%2F2018%2F09%2F23%2FJava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[1. 前言Java反射也是日常开发和阅读源码中经常遇到的, 掌握反射是非常有必要的. 2. 概述2.1 什么是反射简单来说, 反射可以帮助我们在动态运行的时候, 对于任意一个类, 可以获得其所有的方法(包括 public protected private 默认状态的), 所有的变量(包括 public protected private 默认状态的). 反射就是把Java类中的各种成分映射成一个个的Java对象.例如: 一个类有: 成员变量, 方法, 构造方法, 包等等信息, 利用反射技术可以对一个类进行解剖, 把个个组成部分映射成一个个对象.如图是类的正常加载过程: 反射的原理在于Class对象. 2.2 反射有什么用a. 获取某些类的一些变量, 调用某些类的私有方法b. 增加代码的灵活性. 很多主流框架都使用了反射技术. 3. 反射的使用假如有这样一个类 Person, 它拥有多个成员变量, country,city,name,province,height,age 等, 同时它拥有多个 构造方法, 多个方法, 这些变量, 方法的访问权限既有 public 也有 private 的. 下面我们以这个为例子, 一起看怎样使用反射获得相应的 Filed, Constructor, Method.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.HashMap;public class Person &#123; public String country; public String city; private String name; private String province; private Integer height; private Integer age; public Person() &#123; System.out.println("调用Person的无参构造方法"); &#125; private Person(String country, String city, String name) &#123; this.country = country; this.city = city; this.name = name; &#125; public Person(String country, Integer age) &#123; this.country = country; this.age = age; &#125; private String getMobile(String number) &#123; String mobile = "010-110" + "-" + number; return mobile; &#125; private void setCountry(String country) &#123; this.country=country; &#125; public void getGenericHelper(HashMap&lt;String, Integer&gt; hashMap) &#123; &#125; public Class getGenericType() &#123; try &#123; HashMap&lt;String, Integer&gt; hashMap = new HashMap&lt;String, Integer&gt;(); Method method = getClass().getDeclaredMethod("getGenericHelper",HashMap.class); Type[] genericParameterTypes = method.getGenericParameterTypes(); if (null == genericParameterTypes || genericParameterTypes.length &lt; 1) &#123; return null; &#125; ParameterizedType parameterizedType=(ParameterizedType)genericParameterTypes[0]; Type rawType = parameterizedType.getRawType(); System.out.println("----&gt; rawType=" + rawType); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); if (actualTypeArguments==genericParameterTypes || actualTypeArguments.length&lt;1) &#123; return null; &#125; for (int i = 0; i &lt; actualTypeArguments.length; i++) &#123; Type type = actualTypeArguments[i]; System.out.println("----&gt; type=" + type); &#125; &#125; catch (Exception e) &#123; &#125; return null; &#125; @Override public String toString() &#123; return "Person&#123;" + "country='" + country + '\'' + ", city='" + city + '\'' + ", name='" + name + '\'' + ", province='" + province + '\'' + ", height=" + height + '&#125;'; &#125;&#125; 3.1 获得构造方法几个重要的方法 方法 描述 public Constructor getConstructor(Class… parameterTypes) 获得指定的构造方法，注意只能获得 public 权限的构造方法，其他访问权限的获取不到 public Constructor getDeclaredConstructor(Class… parameterTypes) 获得指定的构造方法，注意可以获取到任何访问权限的构造方法。 public Constructor[] getConstructors() throws SecurityException 获得所有 public 访问权限的构造方法 public Constructor[] getDeclaredConstructors() throws SecurityException 获得所有的构造方法，包括（public, private,protected,默认权限的） 3.1.1 获得所有的构造方法123456789101112131415161718192021222324import java.lang.reflect.Constructor;public class Main&#123; public static void main(String[] args)&#123; String className = Person.class.getName(); printConstructor(className); &#125; public static void printConstructor(String className) &#123; try &#123; Class aClass = Class.forName(className); Constructor[] constructors = aClass.getConstructors(); print(constructors); System.out.println("====================="); Constructor[] declaredConstructors = aClass.getDeclaredConstructors(); print(declaredConstructors); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static void print(Constructor[] constructors)&#123; for(Constructor constructor : constructors)&#123; System.out.println(constructor.toString()); &#125; &#125;&#125; 运行结果:123456public Person(java.lang.String,java.lang.Integer)public Person()=====================public Person(java.lang.String,java.lang.Integer)private Person(java.lang.String,java.lang.String,java.lang.String)public Person() 3.1.2 获得指定的构造方法123456789101112131415161718192021222324252627282930313233import java.lang.reflect.Constructor;public class Main&#123; public static void main(String[] args)&#123; String className = Person.class.getName(); Constructor constructor = getConstructor(className, String.class, Integer.class); try &#123; Object meinv = constructor.newInstance("CHINA", 24); Person person = (Person) meinv; System.out.println("testConstructor: = " + person.toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Constructor getConstructor(String className, Class&lt;?&gt;... clzs) &#123; try &#123; Class&lt;?&gt; aClass = Class.forName(className); Constructor&lt;?&gt; declaredConstructor = aClass.getDeclaredConstructor(clzs); print(declaredConstructor); // if Constructor is not public,you should call this declaredConstructor.setAccessible(true); return declaredConstructor; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static void print(Constructor constructor)&#123; System.out.println(constructor.toString()); &#125;&#125; 运行结果:12public Person(java.lang.String,java.lang.Integer)testConstructor: =Person&#123;country='CHINA', city='null', name='null', province='null', height=null&#125; 这说明我们成功通过反射调用 Person 带两个参数的沟改造方法. 3.1.3 注意事项如果该方法, 或者该变量不是 public 访问权限的, 我们应该调用相应的 setAccessible(true) 方法, 才能访问得到12//if Constructor is not public,you should call thisdeclaredConstructor.setAccessible(true); 3.2 获得Filed变量3.2.1 获得所有的Filed变量123456789101112131415161718192021222324import java.lang.reflect.Field;public class Main&#123; public static void main(String[] args)&#123; String className = Person.class.getName(); printFiled(className); &#125; public static void printFiled(String className) &#123; try &#123; Class aClass = Class.forName(className); Field[] fields = aClass.getFields(); print(fields); System.out.println("============================"); Field[] declaredFields = aClass.getDeclaredFields(); print(declaredFields); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static void print(Field[] fields)&#123; for(Field field : fields)&#123; System.out.println(field.toString()); &#125; &#125;&#125; 运行结果:123456789public java.lang.String Person.countrypublic java.lang.String Person.city============================public java.lang.String Person.countrypublic java.lang.String Person.cityprivate java.lang.String Person.nameprivate java.lang.String Person.provinceprivate java.lang.Integer Person.heightprivate java.lang.Integer Person.age 3.2.2 获得指定的Filed变量现在假如我们要获得 Person 中的私有变量 age , 我们可以通过以下的代码获得.1234567891011121314151617import java.lang.reflect.Field;public class Main&#123; public static void main(String[] args) throws Exception&#123; String className = Person.class.getName(); Person person = new Person("CHINA", 12); Field field = getFiled(className, "age"); Integer integer = (Integer) field.get(person); System.out.println("integer = " + integer); &#125; public static Field getFiled(String className, String filedName) throws Exception&#123; Class aClass = Class.forName(className); Field declaredField = aClass.getDeclaredField(filedName); //if not public,you should call this declaredField.setAccessible(true); return declaredField; &#125;&#125; 运行结果:1integer = 12 3.3 执行Method主要有以下几个方法,1234public Method[] getDeclaredMethods()public Method[] getMethods() throws SecurityExceptionpublic Method getDeclaredMethod()public Method getMethod(String name, Class&lt;?&gt; ... parameterTypes) 3.3.1 获取所有的Method123456789101112131415161718192021import java.lang.reflect.Method;public class Main&#123; public static void main(String[] args)&#123; String className = Person.class.getName(); printMethods(className); &#125; public static void printMethods(String className) &#123; try &#123; Class&lt;?&gt; aClass = Class.forName(className); Method[] declaredMethods = aClass.getDeclaredMethods(); print(declaredMethods); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static void print(Method[] declaredMethods)&#123; for(Method method : declaredMethods)&#123; System.out.println(method.toString()); &#125; &#125;&#125; 运行结果:12345public java.lang.String Person.toString()public java.lang.Class Person.getGenericType()private void Person.setCountry(java.lang.String)public void Person.getGenericHelper(java.util.HashMap)private java.lang.String Person.getMobile(java.lang.String) 3.3.2 获取指定的Method12345678910111213141516171819import java.lang.reflect.Method;public class Main&#123; public static void main(String[] args) throws Exception&#123; String className = Person.class.getName(); Person person=new Person(); Method method = getMethod(className, "setCountry", String.class); // 执行方法，结果保存在 person 中 Object o = method.invoke(person, "CHINA"); // 拿到我们传递进取的参数 country 的值 China String country=person.country; System.out.println("country : " + country); &#125; public static Method getMethod(String className, String methodName, Class&lt;?&gt;... clzs) throws Exception &#123; Class&lt;?&gt; aClass = Class.forName(className); Method declaredMethod = aClass.getDeclaredMethod(methodName, clzs); declaredMethod.setAccessible(true); return declaredMethod; &#125;&#125; 运行结果:1country : CHINA 3.4 操作数组123456789101112131415161718192021222324import java.lang.reflect.Array;public class Main&#123; public static void main(String[] args) &#123; testArrayClass(); &#125; /** * 利用反射操作数组 * 1 利用反射修改数组中的元素 * 2 利用反射获取数组中的每个元素 */ public static void testArrayClass() &#123; String[] strArray = new String[]&#123;"5","7","暑期","美女","女生","女神"&#125;; Array.set(strArray,0,"帅哥"); Class clazz = strArray.getClass(); if (clazz.isArray()) &#123; int length = Array.getLength(strArray); for (int i = 0; i &lt; length; i++) &#123; Object object = Array.get(strArray, i); String className=object.getClass().getName(); System.out.println("----&gt; object=" + object+",className="+className); &#125; &#125; &#125;&#125; 运行结果:123456----&gt; object=帅哥,className=java.lang.String----&gt; object=7,className=java.lang.String----&gt; object=暑期,className=java.lang.String----&gt; object=美女,className=java.lang.String----&gt; object=女生,className=java.lang.String----&gt; object=女神,className=java.lang.String 从结果可以说明, 我们成功通过 Array.set(strArray,0,”帅哥”) 改变数组的值. 3.5 获得泛型类型12public static void getGenericHelper(HashMap&lt;String, Person&gt; map) &#123;&#125; 现在假设我们有这样一个方法, 那我们要怎样获得 HashMap 里面的 String, Person 的类型呢?123456789101112131415161718192021222324252627282930import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.HashMap;public class Main&#123; public static void main(String[] args) throws Exception&#123; getGenericType(); &#125; public static void getGenericType() throws Exception&#123; Method method =TestHelper.class.getDeclaredMethod("getGenericHelper", HashMap.class); Type[] genericParameterTypes = method.getGenericParameterTypes(); // 检验是否为空 if (null == genericParameterTypes || genericParameterTypes.length &lt; 1) &#123; return ; &#125; // 取 getGenericHelper 方法的第一个参数 ParameterizedType parameterizedType=(ParameterizedType)genericParameterTypes[0]; Type rawType = parameterizedType.getRawType(); System.out.println("----&gt; rawType=" + rawType); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); if (actualTypeArguments==genericParameterTypes || actualTypeArguments.length&lt;1) &#123; return ; &#125; // 打印出每一个类型 for (int i = 0; i &lt; actualTypeArguments.length; i++) &#123; Type type = actualTypeArguments[i]; System.out.println("----&gt; type=" + type); &#125; &#125;&#125; 运行结果:123----&gt; rawType=class java.util.HashMap----&gt; type=class java.lang.String----&gt; type=class Person 3.6 怎样获得Metho, Field, Constructor的访问权限(public, private, ptotected等)其实很简单, 我们阅读文档可以发现他们都有 getModifiers() 方法, 该方法放回 int 数字, 我们在利用 Modifier.toString() 就可以得到他们的访问权限.12int modifiers = method.getModifiers();Modifier.toString(modifiers); 4. 参考链接Java基础之—反射（非常重要）Java 反射机制详解]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java泛型]]></title>
    <url>%2F2018%2F09%2F23%2FJava%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1. 前言Java源码中有大量泛型的使用, 但是, 日常开发中, 对泛型特性的了解却仅限于表面的浅浅一层, 所以这里记录泛型相关的一些知识. 2. 泛型概述2.1 什么是泛型泛型, 即”参数化类型”. 一提到参数, 最熟悉的就是定义方法时有形参, 然后调用此方法时传递实参. 那么参数化类型怎么理解呢? 顾名思义, 就是将类型由原来的具体的类型参数化, 类似于方法中的变量参数, 此时类型也定义成参数形式(可以称之为类型形参), 然后在使用/调用时传入具体的类型(类型实参). 泛型的本质是为了参数化类型(在不创建新的类型的情况下, 通过泛型指定的不同类型来控制形参具体限制的类型). 也就是说在泛型使用过程中, 操作的数据类型被指定为一个参数, 这种参数类型可以用在类, 接口和方法中, 分别被称为泛型类, 泛型接口, 泛型方法. 2.2 为什么要有泛型代码示例:1234567891011public class Main &#123; public static void main(String[] args)&#123; List arrayList = new ArrayList(); arrayList.add("aaaa"); arrayList.add(100); for(int i = 0; i&lt; arrayList.size();i++)&#123; String item = (String)arrayList.get(i); System.out.println("泛型测试, item = " + item); &#125; &#125;&#125; 运行结果:123泛型测试, item = aaaaException in thread "main" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String at Main.main(Main.java:11) ArrayList可以存放任意类型, 例子中添加了一个String类型, 添加了一个Integer类型, 在使用时都以String的方式使用, 因此程序崩溃了. 为了解决类似这样的问题(在编译阶段就可以解决), 泛型应运而生.我们将第一行声明初始化list的代码更改一下, 编译器会在编译阶段就能够帮我们发现类似这样的问题.123List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();...//arrayList.add(100); 在编译阶段，编译器就会报错 2.3 特性泛型只在编译阶段有效. 看下面的代码 12345678910public class Main &#123; public static void main(String[] args)&#123; List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;(); Class classStringArrayList = stringArrayList.getClass(); Class classIntegerArrayList = integerArrayList.getClass(); System.out.println(classStringArrayList); System.out.println(classIntegerArrayList); &#125;&#125; 结果:12class java.util.ArrayListclass java.util.ArrayList 通过上面的例子可以证明, 在编译之后程序会采取去泛型化的措施. 也就是说Java中的泛型, 只在编译阶段有效. 在编译过程中, 正确检验泛型结果后, 会将泛型的相关信息擦除, 并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法. 也就是说, 泛型信息不会进入到运行时阶段. 3. 泛型的使用泛型有三种使用方式, 分别为: 泛型类, 泛型接口, 泛型方法 3.1 泛型类泛型类型用于类的定义中, 被称为泛型类. 通过泛型可以完成对一组类的操作对外开放相同的接口. 最典型的就是各种容器类, 如: List, Set, Map.泛型类的最基本写法(这么看可能会有点晕, 会在下面的例子中详解):12345class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123; private 泛型标识 /*（成员变量类型）*/ var; ..... &#125;&#125; 一个最普通的泛型类:123456789101112//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123; //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; &#125; public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; &#125;&#125; 1234567891011public class Main &#123; public static void main(String[] args)&#123; //泛型的类型参数只能是类类型（包括自定义类），不能是简单类型 //传入的实参类型需与泛型的类型参数类型相同，即为Integer. Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456); //传入的实参类型需与泛型的类型参数类型相同，即为String. Generic&lt;String&gt; genericString = new Generic&lt;String&gt;("key_vlaue"); System.out.println("泛型测试, key is " + genericInteger.getKey()); System.out.println("泛型测试, key is " + genericString.getKey()); &#125;&#125; 运行结果:12泛型测试, key is 123456泛型测试, key is key_vlaue 定义的泛型类, 就一定要传入泛型类型实参么? 并不是这样, 在使用泛型的时候如果传入泛型实参, 则会根据传入的泛型实参做相应的限制, 此时泛型才会起到本应起到的限制作用. 如果不传入泛型类型实参的话, 在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型.123456789101112public class Main &#123; public static void main(String[] args)&#123; Generic generic = new Generic("111111"); Generic generic1 = new Generic(4444); Generic generic2 = new Generic(55.55); Generic generic3 = new Generic(false); System.out.println("泛型测试, key is " + generic.getKey()); System.out.println("泛型测试, key is " + generic1.getKey()); System.out.println("泛型测试, key is " + generic2.getKey()); System.out.println("泛型测试, key is " + generic3.getKey()); &#125;&#125; 运行结果:1234泛型测试, key is 111111泛型测试, key is 4444泛型测试, key is 55.55泛型测试, key is false 3.2 泛型接口泛型接口与泛型类的定义及使用基本相同. 泛型接口常被用在各种类的生产器中, 可以看一个例子:1234//定义一个泛型接口public interface Generator&lt;T&gt; &#123; public T next();&#125; 当实现泛型接口的类, 未传入泛型实参时:1234567891011/** * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错："Unknown class" */class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; @Override public T next() &#123; return null; &#125;&#125; 当实现泛型接口的类, 传入泛型实参时:1234567891011121314151617/** * 传入泛型实参时： * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt; * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。 * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。 */public class FruitGenerator implements Generator&lt;String&gt; &#123; private String[] fruits = new String[]&#123;"Apple", "Banana", "Pear"&#125;; @Override public String next() &#123; Random rand = new Random(); return fruits[rand.nextInt(3)]; &#125;&#125; 3.3 泛型通配符我们知道Integer是Number的一个子类, 同时在特性章节中我们也验证过Generic与Generic实际上是相同的一种类型. 那么问题来了, 在使用Generic作为形参的方法中, 能否使用Generic的实例传入呢? 在逻辑上类似于Generic和Generic是否可以看成具有父子关系的泛型类型呢?为了弄清楚这个问题, 我们使用Generic这个泛型类继续看下面的例子:12345678910111213public class Main &#123; public static void main(String[] args)&#123; Generic&lt;Integer&gt; gInteger = new Generic&lt;Integer&gt;(123); Generic&lt;Number&gt; gNumber = new Generic&lt;Number&gt;(456); showKeyValue(gNumber); // 下面showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt; // cannot be applied to Generic&lt;java.lang.Number&gt; // showKeyValue(gInteger); &#125; public static void showKeyValue(Generic&lt;Number&gt; obj)&#123; System.out.println("泛型测试, key value is " + obj.getKey()); &#125;&#125; 123456789101112//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123; //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; &#125; public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; &#125;&#125; 通过提示信息我们可以看到Generic不能被看作为`Generic的子类. 由此可以看出:同一种泛型可以对应多个版本(因为参数类型是不确定的), 不同版本的泛型类实例是不兼容的.回到上面的例子, 如何解决上面的问题? 总不能为了定义一个新的方法来处理Generic类型的类, 这显然与java中的多台理念相违背. 因此我们需要一个在逻辑上可以表示同时是Generic和Generic父类的引用类型. 由此类型通配符应运而生.我们可以将上面的方法改一下:123public void showKeyValue(Generic&lt;?&gt; obj)&#123; System.out.println("泛型测试, key value is " + obj.getKey());&#125; 类型通配符一般是使用? 代替具体的类型实参, 注意了, 此处 ? 是类型实参, 而不是类型形参. 再直白点的意思就是, 此处的?和Number, String, Integer一样都是一种实际的类型, 可以把?看成所有类型的父类. 是一种真实的类型.可以解决当具体类型不确定的时候, 这个通配符就是?; 当操作类型时, 不需要使用类型的具体功能时, 只使用Object类中的功能. 那么可以用? 通配符来表未知类型. 3.4 泛型方法泛型类, 是在实例化类的时候指明泛型的具体类型, 泛型方法, 是在调用方法的时候指明泛型的具体类型.123456789101112131415/** * 泛型方法的基本介绍 * @param tClass 传入的泛型实参 * @return T 返回值为T类型 * 说明： * 1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。 * 2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 * 3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。 * 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 */public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException , IllegalAccessException&#123; T instance = tClass.newInstance(); return instance;&#125; 1Object obj = genericMethod(Class.forName(&quot;Test&quot;)); 3.4.1 泛型方法的基本用法光看上面的例子有的同学可能依然会非常迷糊, 我们再通过一个例子, 把我泛型方法再总结一下.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class GenericTest &#123; //这个类是个泛型类，在上面已经介绍过 public class Generic&lt;T&gt;&#123; private T key; public Generic(T key) &#123; this.key = key; &#125; //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。 //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。 //所以在这个方法中才可以继续使用 T 这个泛型。 public T getKey()&#123; return key; &#125; /** * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E" * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。 public E setKey(E key)&#123; this.key = key &#125; */ &#125; /** * 这才是一个真正的泛型方法。 * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T * 这个T可以出现在这个泛型方法的任意位置. * 泛型的数量也可以为任意多个 * 如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123; * ... * &#125; */ public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123; System.out.println("container key :" + container.getKey()); //当然这个例子举的不太合适，只是为了说明泛型方法的特性。 T test = container.getKey(); return test; &#125; //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。 public void showKeyValue1(Generic&lt;Number&gt; obj)&#123; System.out.println("泛型测试, key value is " + obj.getKey()); &#125; //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符? //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类 public void showKeyValue2(Generic&lt;?&gt; obj)&#123; System.out.println("泛型测试, key value is " + obj.getKey()); &#125; /** * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' " * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。 * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。 public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123; ... &#125; */ /** * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' " * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。 * 所以这也不是一个正确的泛型方法声明。 public void showkey(T genericObj)&#123; &#125; */ public static void main(String[] args) &#123; &#125;&#125; 3.4.2 类中的泛型方法当然这并不是泛型方法的全部, 泛型方法可以出现杂任何地方和任何场景中使用. 但是有一种情况是非常特殊的, 当泛型方法出现在泛型类中时, 我们再通过一个例子看一下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class GenericFruit &#123; class Fruit&#123; @Override public String toString() &#123; return "fruit"; &#125; &#125; class Apple extends Fruit&#123; @Override public String toString() &#123; return "apple"; &#125; &#125; class Person&#123; @Override public String toString() &#123; return "Person"; &#125; &#125; class GenerateTest&lt;T&gt;&#123; public void show_1(T t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。 //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。 public &lt;E&gt; void show_3(E t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。 public &lt;T&gt; void show_2(T t)&#123; System.out.println(t.toString()); &#125; &#125; public void main(String[] args) &#123; Apple apple = new Apple(); Person person = new Person(); GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;(); //apple是Fruit的子类，所以这里可以 generateTest.show_1(apple); //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person //generateTest.show_1(person); //使用这两个方法都可以成功 generateTest.show_2(apple); generateTest.show_2(person); //使用这两个方法也都可以成功 generateTest.show_3(apple); generateTest.show_3(person); &#125;&#125; 3.4.3 泛型方法与可变参数再看一个泛型方法和可变参数的例子:12345678910public class Main&#123; public static void main(String[] args)&#123; printMsg("111",222,"aaaa","2323.4",55.55); &#125; public static &lt;T&gt; void printMsg( T... args)&#123; for(T t : args)&#123; System.out.println("泛型测试, t is " + t); &#125; &#125;&#125; 3.4.4 静态方法与泛型静态方法有一种情况需要注意一下, 那就是在类中的静态方法使用泛型: 静态方法无法访问类上定义的泛型; 如果静态方法操作的引用数据类型不确定的时候, 必须要将泛型定义在方法上.即: 如果静态方法要使用泛型的话, 必须将静态方法也定义成泛型方法.12345678910111213public class StaticGenerator&lt;T&gt; &#123; .... .... /** * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法） * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。 * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息： "StaticGenerator cannot be refrenced from static context" */ public static &lt;T&gt; void show(T t)&#123; &#125;&#125; 3.4.5 泛型方法总结泛型方法能使方法独立于类而产生变化, 以下是一个基本的指导原则: 无论何时, 如果你能做到, 你就该尽量使用泛型方法. 也就是说, 如果使用泛型方法将整个类泛型化, 那么就应该使用泛型方法. 另外对于一个static的方法而言, 无法访问泛型类型的参数. 所以如果static方法要使用泛型能力, 就必须使其成为泛型方法. 3.5 泛型上下边界在使用泛型的时候, 我们还可以为传入的泛型类型实参进行上下边界的限制, 如: 类型实参只准传入某种类型的父类或某种类型的子类.为泛型添加上边界, 即传入的类型实参必须是指定类型的子类型.123456789101112131415161718public class Main&#123; public static void main(String[] args)&#123; Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;("11111"); Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222); Generic&lt;Float&gt; generic3 = new Generic&lt;Float&gt;(2.4f); Generic&lt;Double&gt; generic4 = new Generic&lt;Double&gt;(2.56); //这一行代码编译器会提示错误，因为String类型并不是Number类型的子类 //showKeyValue1(generic1); showKeyValue1(generic2); showKeyValue1(generic3); showKeyValue1(generic4); &#125; public static void showKeyValue1(Generic&lt;? extends Number&gt; obj)&#123; System.out.println("泛型测试, key value is " + obj.getKey()); &#125;&#125; 如果我们把泛型类的定义也改一下:123456789public class Generic&lt;T extends Number&gt;&#123; private T key; public Generic(T key) &#123; this.key = key; &#125; public T getKey()&#123; return key; &#125;&#125; 12//这一行代码也会报错，因为String不是Number的子类Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;("11111"); 再来一个泛型方法的例子:1234567//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错："Unexpected bound"public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container)&#123; System.out.println("container key :" + container.getKey()); T test = container.getKey(); return test;&#125; 通过上面的两个例子可以看出: 泛型的上下边界添加, 必须与泛型的声明在一起. 3.6 泛型数组在Java中 “是不能创建一个确切的泛型类型的数组” 的.也就是说下面的这个例子是不可以的:1List&lt;String&gt;[] ls = new ArrayList&lt;String&gt;[10];而使用通配符创建泛型数组是可以的, 如下面这个例子:1List&lt;?&gt;[] ls = new ArrayList&lt;?&gt;[10];这样也是可以的:1List&lt;String&gt;[] ls = new ArrayList[10];下面使用Sun的一篇文档的一个例子来说明这个问题:1234567List&lt;String&gt;[] lsa = new List&lt;String&gt;[10]; // Not really allowed. Object o = lsa; Object[] oa = (Object[]) o; List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;(); li.add(new Integer(3)); oa[1] = li; // Unsound, but passes run time store check String s = lsa[1].get(0); // Run-time error: ClassCastException. * 这种情况下, 由于JVM泛型的擦除机制, 在运行时JVM是不知道泛型信息的, 所以可以给oa[1]赋上一个ArrayList而不会出现异常, 但是在取出数据的时候却要做一次类型转换, 所以就会出现ClassCastException, 如果可以进行泛型数组的声明, 上面说的这种情况在编译期将不会出现任何的警告和错误, 只有在运行时才会出错.这个部分写不下去了, 记住一点就好, 不要使用泛型数组!!! 4. 参考链接java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java序列化]]></title>
    <url>%2F2018%2F09%2F23%2FJava%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1. 前言阅读源码和日常开发, 序列化也是基础中的基础, 这篇文章主要是记录序列化相关的知识点. 2. 基本概念2.1 什么是序列化和反序列化 Java序列化是指把Java对象转换为字节序列的过程, 而Java反序列化是指把字节序列恢复为Java对象的过程; 序列化: 对象序列化的最主要的用处就是在传递和保存对象的时候, 保证对象的完整性和可传递性. 序列化是把对象转换成有序字节流, 以便在网络上传输或者保存在本地文件中. 序列化后的字节流保存了Java对象的状态以及相关的描述信息. 序列化机制的核心作用就是对象状态的保存与重建. 反序列化: 客户端从文件中或网络上获得序列化后的对象字节流后, 根据字节流中所保存的对象状态及描述信息, 通过反序列化重建对象. 本质上讲, 序列化就是把实体对象状态按照一定的格式写入到有序字节流, 反序列化就是从有序字节流重建对象, 恢复对象状态. 2.2 为什么需要序列化与反序列化我们知道, 当两个进程进行远程通信时, 可以相互发送各种类型的数据, 包括文本, 图片, 音频, 视频等, 而这些数据都会以二进制序列的形式在网络上传送.那么当两个Java进程进行通信时, 能否实现进程间的对象传送呢? 答案是可以的! 如何做到? 这就需要Java序列化与反序列化了!换句话说, 一方面, 发送方需要把这个Java对象转换为字节序列, 然后在网络上传送; 另一方面, 接收方需要从字节序列中恢复出Java对象.当我们明晰了为什么需要Java序列化和反序列化后, 我们很自然地会想Java序列化的好处. 其好处一是实现了数据的持久化, 通过序列化可以把数据永久地保存到硬盘上(通常存放在文件里), 二是, 利用序列化实现远程通信, 即在网络上传送对象的字节序列.总的来说可以归结为以下几点: 永久性保存对象, 保存对象的字节序列到本地文件或者数据库中; 通过序列化以字节流的形式使对象在网络中进行传递和接收; 通过序列化在进程间传递对象; 2.3 序列化算法一般会按步骤做如下事情 将对象实例相关的类元数据输出. 递归地输出类的超类描述直到不再有超类. 类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值. 从上至下递归输出实例的数据. 2.4 Java如何实现序列化和反序列化2.4.1 JDK类库中序列化和反序列化APIjava.io.ObjectOutputStream: 表示对象输出流;它的writeObject(Object obj)方法可以对参数指定的obj对象进行序列化, 把得到的字节序列写到一个目标输出流中;java.io.ObjectInputStream: 表示对象输入流;它的readObject()方法源输入流中读取字节序列, 再把它们反序列化成为一个对象, 并将其返回; 2.4.2 实现序列化的要求只有实现了Serializable或Externalizable接口的类的对象才能被序列化, 否则抛出异常! 2.4.3 实现Java对象序列化与反序列化的方法假定一个User类, 它的对象需要序列化, 可以有如下三种方法: 若User类仅仅实现了Serializable接口, 则可以按照以下方式进行序列化和反序列化:ObjectOutputStream采用默认的序列化方式, 对User对象的非transient的实例变量进行序列化.ObjcetInputStream采用默认的反序列化方式, 对User对象的非transient的实例变量进行反序列化. 若User类仅仅实现了Serializable接口, 并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out), 则采用以下方式进行序列化与反序列化:ObjectOutputStream调用User对象的writeObject(ObjectOutputStream out)的方法进行序列化.ObjectInputStream会调用User对象的readObject(ObjectInputStream in)的方法进行反序列化. 若User类实现了Externalnalizable接口, 且User类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法, 则按照以下方式进行序列化与反序列化:ObjectOutputStream调用User对象的writeExternal(ObjectOutput out))的方法进行序列化.ObjectInputStream会调用User对象的readExternal(ObjectInput in)的方法进行反序列化. 2.5 JDK类库中序列化和反序列化的步骤序列化步骤:1234// 步骤一: 创建一个对象输出流, 它可以包装一个其它类型的目标输出流, 如文件输出流:ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("D:\\object.out"));// 步骤二: 通过对象输出流的writeObject()方法写对象:oos.writeObject(new User("xuliugen", "123456", "male")); 反序列化步骤:1234// 步骤一: 创建一个对象输入流, 它可以包装一个其它类型输入流，如文件输入流：ObjectInputStream ois= new ObjectInputStream(new FileInputStream("object.out"));// 步骤二: 通过对象输出流的readObject()方法读取对象：User user = (User) ois.readObject(); 2.6 示例1234567891011121314151617181920212223242526272829303132333435363738import java.io.*;public class Main &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //序列化 FileOutputStream fos = new FileOutputStream("object.out"); ObjectOutputStream oos = new ObjectOutputStream(fos); User user1 = new User("xuliugen", "123456", "male"); oos.writeObject(user1); oos.flush(); oos.close(); //反序列化 FileInputStream fis = new FileInputStream("object.out"); ObjectInputStream ois = new ObjectInputStream(fis); User user2 = (User) ois.readObject(); System.out.println(user2.getUserName()+ " " + user2.getPassword() + " " + user2.getSex()); //反序列化的输出结果为：xuliugen 123456 male &#125;&#125;class User implements Serializable &#123; private String userName; private String password; private String sex; public User(String userName, String password, String sex) &#123; this.userName = userName; this.password = password; this.sex = sex; &#125; public String getUserName() &#123; return userName; &#125; public String getPassword() &#123; return password; &#125; public String getSex() &#123; return sex; &#125;&#125; 序列化图示反序列化图示 3. 注意事项 序列化时, 只对对象的状态进行保存, 而不管对象的方法; 当一个父类实现序列化, 子类自动实现序列化, 不需要显式实现Serializable接口; 当一个对象的实例变量引用其他对象, 序列化该对象时也把引用对象进行序列化; 并非所有的对象都可以序列化, 至于为什么不可以, 有很多原因了, 比如:a. 安全方面的原因, 比如一个对象拥有private, public等field, 对于一个要传输的对象, 比如写到文件, 或者进行RMI传输等等, 在序列化进行传输的过程中, 这个对象的private等域是不受保护的;b. 资源分配方面的原因, 比如socket, thread类, 如果可以序列化, 进行传输或者保存, 也无法对他们进行重新的资源分配, 而且, 也是没有必要这样实现; 声明为static和transient类型的成员数据不能被序列化. 因为static代表类的状态, transient代表对象的临时数据. 序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联, 该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类. 为它赋予明确的值. 显式地定义serialVersionUID有两种用途:a. 在某些场合, 希望类的不同版本对序列化兼容, 因此需要确保类的不同版本具有相同的serialVersionUID;b. 在某些场合, 不希望类的不同版本对序列化兼容, 因此需要确保类的不同版本具有不同的serialVersionUID. Java有很多基础类已经实现了serializable接口, 比如String,Vector等.但是也有一些没有实现serializable接口的; 如果一个对象的成员变量是一个对象, 那么这个对象的数据成员也会被保存, 这是能用序列化解决深拷贝的重要原因. 4. 参考链接序列化和反序列化的底层实现原理是什么？深入理解JAVA序列化]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java关键字final]]></title>
    <url>%2F2018%2F09%2F23%2FJava%E5%85%B3%E9%94%AE%E5%AD%97final%2F</url>
    <content type="text"><![CDATA[1. 前言阅读Java源码或者日常后台开发中, 会不可避免的与final打交道, 那么final关键字究竟有哪些特性?这篇文章主要介绍final关键字及其相关知识点. 2. 基本用法在Java中, final可以用来修饰类,方法和变量(包括成员变量和局部变量). 我们先来简单介绍一下final关键字的这几个用法. 2.1 final修饰类常见的一个例子就是String类. 当用final修饰一个类时, 表明这个类不能被继承, 并且final类中的所有成员方法都会被隐式地指定为final方法, 但成员变量不会变.一般来说, 我们还是尽量不要将类设计为final类, 除非我们出于某些因素的考虑必须这么做. 比如不希望类被继承, 也就是说不希望类被修改语义. 如果我们继承String类, 那么就可以定义一个可被修改的String类, 这对于String类的使用者来说近乎是一种灾难. 2.2 final修饰方法使用final修饰方法有两个原因:一是把方法锁定, 以防任何继承类修改它的含义;二是效率. 在早期的Java实现版本中, 会将final方法转为内嵌调用. 但是如果方法过于庞大, 可能看不到内嵌调用带来的任何性能提升. 在最近的Java版本中, 不需要使用final方法进行这些优化了.同final类相似, 只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final. 另外,类 的private方法会隐式地被指定为final方法, 其语义要求private方法不能被重新定义. 2.3 final修饰变量final用得最多的地方就是修饰变量. 对于一个final变量, 如果是基本数据类型的变量, 则其数值一旦在初始化之后便不能更改;如果是引用类型的变量, 则在对其初始化之后便不能再让其指向另一个对象, 但是它指向的对象的内容是可变的.由于final变量初始化之后无法修改, 针对这个特性, Java编译器对此进行了优化. 当final变量是基本数据类型以及String类型时, 如果在编译期间能知道它的确切值, 则编译器会把它当做编译期常量使用. 这个优化通常对于程序逻辑没有太多影响, 但如果用==比较的时候, 可能会出乎意料. 3. 总结综上所述, final在修饰类和方法时, 代表不能再修改其定义, 而在修饰变量时, 则类似C++中的const关键字, 用于表示常量. 一个好的编程习惯是我们应该尽量将变量声明为final的, 除非变量必须是可变的. 例如当你在方法中不需要改变作为参数的变量时, 可以使用final进行声明, 这样可以防止你无意的修改, 尤其是当你的方法很长很复杂的时候. 当然是否用final修饰参数, 都不会影响方法之外的变量. 4. 参考链接聊聊Java的final关键字]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java字符串处理]]></title>
    <url>%2F2018%2F09%2F23%2FJava%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 前言对字符串的操作是后台开发中非常常见的, 对字符串相关的类有深刻的认识有助于写出高质量的代码. 这篇文章主要是介绍String, StringBuffer, StringBuilder这三个字符串相关的类. 2. 基本认识2.1 String1234567891011121314/** Strings are constant; their values cannot be changed after they * are created. String buffers support mutable strings. * Because String objects are immutable they can be shared. * 字符串是不变的，他们的值在创造后不能改变。 * 字符串缓冲区支持可变字符串，因为字符串对象是不可变的，所以它们可以共享。 * * @see StringBuffer * @see StringBuilder * @see Charset * @since 1.0 */public final class String implements Serializable, Comparable&lt;String&gt;, CharSequence &#123; private static final long serialVersionUID = -6849794470754667710L; private static final char REPLACEMENT_CHAR = (char) 0xfffd; 这句话总结归纳了String的两个最重要的特点:String是值不可变的常量, 是线程安全的(can be shared).String类使用了final修饰符, String类是不可继承的. 2.2 StringBufferStringBuffer字符串变量(线程安全)是一个容器, 最终会通过toString方法变成字符串;1234567891011121314151617181920public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, Appendable, CharSequence&#123; /** * Constructs a string buffer with no characters in it and an * initial capacity of 16 characters. */ public StringBuffer() &#123; super(16); &#125; public synchronized StringBuffer append(int i) &#123; super.append(i); return this; &#125; public synchronized StringBuffer delete(int start, int end) &#123; super.delete(start, end); return this; &#125;&#125; 2.3 StringBuilderStringBuilder 字符串变量(非线程安全).12345678910111213public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, Appendable, CharSequence &#123; public StringBuilder() &#123; super(16); &#125; public StringBuilder append(String str) &#123; super.append(str); return this; &#125; public StringBuilder delete(int start, int end) &#123; super.delete(start, end); return this; &#125;&#125; 3. 源码理解3.1 String 与 StringBuffer/StringBuilder 的区别String和StringBuffer/StringBuilder底层都是一个char数组, 但是String的char数组是final的;StringBuffer/StringBuilder的char数组不是final的.(1)String在修改时不会改变对象自身, 在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象, 然后将指针指向新的 String 对象, 所以经常改变内容的字符串最好不要用 String.1234567public class Main &#123; public static void main(String[] args) &#123; String str = "abc"; String str2 = str + ""; System.out.println(str == str2); &#125;&#125; 结果:1false (2)StringBuffer/StringBuilder在修改时会改变对象自身, 每次结果都会对StringBuffer/StringBuilder对象本身进行操作, 而不是生成新的对象, 再改变对象引用. 所以在一般情况下我们推荐使用StringBuffer/StringBuilder, 特别是字符串对象经常改变的情况下.StringBuffer/StringBuilder上的主要操作是 append 和 insert 方法.1234567public class Main &#123; public static void main(String[] args) &#123; StringBuffer stringBuffer = new StringBuffer("abc"); StringBuffer stringBuffer2 = stringBuffer.append("a"); System.out.println(stringBuffer == stringBuffer2); &#125;&#125; 结果:1true 3.2 StringBuffer 与 StringBuilder 的区别StringBuffer: 线程安全的, 通过synchronized实现;StringBuilder: 线程非安全的. 4. 总结 如果要操作少量的数据用 String; 多线程操作字符串缓冲区下操作大量数据 StringBuffer; 单线程操作字符串缓冲区下操作大量数据 StringBuilder. 5. 参考链接Java基础之String、StringBuffer与StringBuilder的区别及应用场景]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合(二)----Set]]></title>
    <url>%2F2018%2F09%2F22%2FJava%E9%9B%86%E5%90%88(%E4%BA%8C)----Set%2F</url>
    <content type="text"><![CDATA[1. 前言集合是Java基础中非常重要的一部分, 也是日常中用到非常多的类, 这篇博客主要记录集合Set相关的知识. 特别声明: 大部分内容并非原创, 引用自参考链接. 2. SetSet继承于Collection接口, 是一个不允许出现重复元素, 并且无序的集合, 主要有HashSet和TreeSet两大实现类.在判断重复元素的时候, Set集合会调用hashCode()和equal()方法来实现.HashSet是哈希表结构, 主要利用HashMap的key来存储元素, 计算插入元素的hashCode来获取元素在集合中的位置;TreeSet是红黑树结构, 每一个元素都是树中的一个节点, 插入的元素都会进行排序; 2.1 Set常用操作与List接口一样, Set接口也提供了集合操作的基本方法.但与List不同的是, Set还提供了equals(Object o)和hashCode(), 供其子类重写, 以实现对集合中插入重复元素的处理;12345678910111213141516171819202122232425262728293031public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123; A:添加功能 boolean add(E e); boolean addAll(Collection&lt;? extends E&gt; c); B:删除功能 boolean remove(Object o); boolean removeAll(Collection&lt;?&gt; c); void clear(); C:长度功能 int size(); D:判断功能 boolean isEmpty(); boolean contains(Object o); boolean containsAll(Collection&lt;?&gt; c); boolean retainAll(Collection&lt;?&gt; c); E:获取Set集合的迭代器： Iterator&lt;E&gt; iterator(); F:把集合转换成数组 Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); //判断元素是否重复，为子类提高重写方法 boolean equals(Object o); int hashCode();&#125; 2.2 初识HashSetHashSet实现Set接口, 底层由HashMap(后面讲解)来实现, 为哈希表结构, 新增元素相当于HashMap的key, value默认为一个固定的Object. HashSet相当于一个阉割版的HashMap;当有元素插入的时候, 会计算元素的hashCode值, 将元素插入到哈希表对应的位置中来;它继承于AbstractSet, 实现了Set, Cloneable, Serializable接口.(1)HashSet继承AbstractSet类, 获得了Set接口大部分的实现, 减少了实现此接口所需的工作, 实际上是又继承了AbstractCollection类;(2)HashSet实现了Set接口, 获取Set接口的方法, 可以自定义具体实现, 也可以继承AbstractSet类中的实现;(3)HashSet实现Cloneable, 得到了clone()方法, 可以实现克隆功能;(4)HashSet实现Serializable, 表示可以被序列化, 通过序列化去传输, 典型的应用就是hessian协议.具有如下特点:(1)不允许出现重复因素;(2)允许插入Null值;(3)元素无序(添加顺序和遍历顺序不一致);(4)线程不安全, 若2个线程同时操作HashSet, 必须通过代码实现同步; 2.2.1 HashSet元素添加Set集合不允许添加重复元素, 那么到底是个怎么情况呢?来看一个简单的例子:12345678910111213141516171819202122232425262728293031public class HashSetTest &#123; public static void main(String[] agrs)&#123; //hashCode() 和 equals()测试： hashCodeAndEquals(); &#125; public static void hashCodeAndEquals()&#123; //第一个 Set集合： Set&lt;String&gt; set1 = new HashSet&lt;String&gt;(); String str1 = new String("jiaboyan"); String str2 = new String("jiaboyan"); set1.add(str1); set1.add(str2); System.out.println("长度："+set1.size()+",内容为："+set1); //第二个 Set集合： Set&lt;App&gt; set2 = new HashSet&lt;App&gt;(); App app1 = new App(); app1.setName("jiaboyan"); App app2 = new App(); app2.setName("jiaboyan"); set2.add(app1); set2.add(app2); System.out.println("长度："+set2.size()+",内容为："+set2); //第三个 Set集合： Set&lt;App&gt; set3 = new HashSet&lt;App&gt;(); App app3 = new App(); app3.setName("jiaboyan"); set3.add(app3); set3.add(app3); System.out.println("长度："+set3.size()+",内容为："+set3); &#125;&#125; 测试结果:123长度：1,内容为：[jiaboyan]长度：2,内容为：[App@74a14482, App@4554617c]长度：1,内容为：[App@1540e19d] 可以看到, 第一个Set集合中最终只有一个元素; 第二个Set集合保留了2个元素; 第三个集合也只有1个元素;究竟是什么原因呢?让我们来看看HashSet的add(E e)方法:123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 在底层HashSet调用了HashMap的put(K key, V value)方法:123456789101112131415161718192021public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125; 简单概括如下:在向HashMap中添加元素时, 先判断key的hashCode值是否相同, 如果相同, 则调用==, equals()进行判断, 若相同则覆盖原有元素; 如果不同, 则直接向Map中添加元素;反过来, 我们在看下上面的例子:在第一个Set集合中, 我们new了两个String对象, 赋了相同的值. 当传入到HashMap中时, key均为”jiaboyan”, 所以hash和i的值都相同. 进行if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))判断, 由于String对象重写了equals()方法,所以在((k = e.key) == key || key.equals(k))判断时, 返回了true, 所以第二次的插入并不会增加Set集合的长度;第二个Set集合中, 也是new了两个对象, 但没有重写equals()方法(底层调用的Object的equals()，也就是==判断), 所以会增加2个元素;第三个Set集合中, 只new了一个对象, 调用的两次add方法都添加的这个新new的对象,所以也只是保留了1个元素; 2.3 初识TreeSet从名字上可以看出, 此集合的实现和树结构有关.与HashSet集合类似, TreeSet也是基于Map来实现, 具体实现TreeMap, 其底层结构为红黑树;与HashSet不同的是, TreeSet具有排序功能, 分为自然排序(123456)和自定义排序两类, 默认是自然排序; 在程序中, 我们可以按照任意顺序将元素插入到集合中, 等到遍历时TreeSet会按照一定顺序输出–倒序或者升序;它继承AbstractSet, 实现NavigableSet, Cloneable, Serializable接口.(1)与HashSet同理, TreeSet继承AbstractSet类,获得了Set集合基础实现操作;(2)TreeSet实现NavigableSet接口, 而NavigableSet又扩展了SortedSet接口. 这两个接口主要定义了搜索元素的能力, 例如给定某个元素,查找该集合中比给定元素大于, 小于, 等于的元素集合, 或者比给定元素大于, 小于, 等于的元素个数; 简单地说, 实现NavigableSet接口使得TreeSet具备了元素搜索功能;(3)TreeSet实现Cloneable接口, 意味着它也可以被克隆;(4)TreeSet实现了Serializable接口, 可以被序列化, 可以使用hessian协议来传输;具有如下特点:(1)对插入的元素进行排序, 是一个有序的集合(主要与HashSet的区别);(2)底层使用红黑树结构, 而不是哈希表结构;(3)允许插入Null值;(4)不允许插入重复元素;(5)线程不安全; 2.3.1 TreeSet元素排序在前面的章节, 我们讲到了TreeSet是一个有序集合,可以对集合元素排序,其中分为自然排序和自定义排序,那么这两种方式如何实现呢?首先,我们通过JDK提供的对象来展示, 我们使用String, Integer:1234567891011121314151617181920public class TreeSetTest &#123; public static void main(String[] agrs)&#123; naturalSort(); &#125; //自然排序顺序：升序 public static void naturalSort()&#123; TreeSet&lt;String&gt; treeSetString = new TreeSet&lt;String&gt;(); treeSetString.add("a"); treeSetString.add("z"); treeSetString.add("d"); treeSetString.add("b"); System.out.println("字母顺序：" + treeSetString.toString()); TreeSet&lt;Integer&gt; treeSetInteger = new TreeSet&lt;Integer&gt;(); treeSetInteger.add(1); treeSetInteger.add(24); treeSetInteger.add(23); treeSetInteger.add(6); System.out.println("数字顺序：" + treeSetInteger.toString()); &#125;&#125; 测试结果:12字母顺序：[a, b, d, z]数字顺序：[1, 6, 23, 24] 接下来, 我们自定义对象, 看能否实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.TreeSet;public class Main &#123; public static void main(String[] agrs)&#123; customSort(); &#125; //自定义排序顺序：升序 public static void customSort()&#123; TreeSet&lt;App&gt; treeSet = new TreeSet&lt;App&gt;(); //排序对象： App app1 = new App("hello",10); App app2 = new App("world",20); App app3 = new App("my",15); App app4 = new App("name",25); //添加到集合： treeSet.add(app1); treeSet.add(app2); treeSet.add(app3); treeSet.add(app4); System.out.println("TreeSet集合顺序为："+treeSet); &#125;&#125;class App&#123; private String name; private Integer age; public App()&#123;&#125; public App(String name,Integer age)&#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public static void main(String[] args )&#123; System.out.println( "Hello World!" ); &#125;&#125; 测试结果: 123456Exception in thread "main" java.lang.ClassCastException: App cannot be cast to java.lang.Comparable at java.util.TreeMap.compare(TreeMap.java:1294) at java.util.TreeMap.put(TreeMap.java:538) at java.util.TreeSet.add(TreeSet.java:255) at Main.customSort(Main.java:15) at Main.main(Main.java:4) 为什么会报错呢?12345compare(key, key); // type (and possibly null) checkfinal int compare(Object k1, Object k2) &#123; return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2);&#125; 通过查看源码发现, 在TreeSet调用add方法时, 会调用到底层TreeMap的put方法, 在put方法中会调用到compare(key, key)方法, 进行key大小的比较;在比较的时候, 会将传入的key进行类型强转, 所以当我们自定义的App类进行比较的时候, 自然就会抛出异常, 因为App类并没有实现Comparable接口;将App实现Comparable接口, 再做比较:123456789101112131415161718192021222324252627282930313233343536373839class App implements Comparable&lt;App&gt;&#123; private String name; private Integer age; public App()&#123;&#125; public App(String name,Integer age)&#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public static void main(String[] args )&#123; System.out.println( "Hello World!" ); &#125; @Override //自定义比较：先比较name的长度，在比较age的大小； public int compareTo(App app) &#123; //比较name的长度： int num = this.name.length() - app.name.length(); //如果name长度一样，则比较年龄的大小： return num == 0 ? this.age - app.age : num; &#125; @Override public String toString() &#123; return "App&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 测试结果:1TreeSet集合顺序为：[App&#123;name=&apos;my&apos;, age=15&#125;, App&#123;name=&apos;name&apos;, age=25&#125;, App&#123;name=&apos;hello&apos;, age=10&#125;, App&#123;name=&apos;world&apos;, age=20&#125;] 此外, 还有另一种方式, 那就是实现Comparetor接口, 并重写compare方法;12345678//自定义App类的比较器：public class AppComparator implements Comparator&lt;App&gt; &#123; //比较方法：先比较年龄，年龄若相同在比较名字长度； public int compare(App app1, App app2) &#123; int num = app1.getAge() - app2.getAge(); return num == 0 ? app1.getName().length() - app2.getName().length() : num; &#125;&#125; 此时, App不用在实现Comparerable接口了, 单纯的定义一个类即可;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.Comparator;import java.util.TreeSet;public class Main &#123; public static void main(String[] agrs)&#123; customSort(); &#125; //自定义排序顺序：升序 public static void customSort()&#123; TreeSet&lt;App&gt; treeSet = new TreeSet&lt;App&gt;(new AppComparator()); //排序对象： App app1 = new App("hello",10); App app2 = new App("world",20); App app3 = new App("my",15); App app4 = new App("name",25); //添加到集合： treeSet.add(app1); treeSet.add(app2); treeSet.add(app3); treeSet.add(app4); System.out.println("TreeSet集合顺序为："+treeSet); &#125;&#125;class App&#123; private String name; private Integer age; public App()&#123;&#125; public App(String name,Integer age)&#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public static void main(String[] args )&#123; System.out.println( "Hello World!" ); &#125; @Override public String toString() &#123; return "App&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125;//自定义App类的比较器：class AppComparator implements Comparator&lt;App&gt; &#123; //比较方法：先比较年龄，年龄若相同在比较名字长度； public int compare(App app1, App app2) &#123; int num = app1.getAge() - app2.getAge(); return num == 0 ? app1.getName().length() - app2.getName().length() : num; &#125;&#125; 测试结果:1TreeSet集合顺序为：[App&#123;name=&apos;hello&apos;, age=10&#125;, App&#123;name=&apos;my&apos;, age=15&#125;, App&#123;name=&apos;world&apos;, age=20&#125;, App&#123;name=&apos;name&apos;, age=25&#125;] 最后, 再说下关于compareTo(), compare()方法:123结果返回大于0时，方法前面的值大于方法中的值；结果返回等于0时，方法前面的值等于方法中的值；结果返回小于0时，方法前面的值小于方法中的值； 2.4 HashSet源码分析(基于JDK1.7.0_75)HashSet基于HashMap, 底层方法是通过调用HashMap的API来实现, 因此HashSet源码结构比较简单, 代码较少. 2.4.1 成员变量在HashSet中, 有两个成员变量比较重要–map, PRESENT;其中,map就是存储元素的地方, 实际是一个HashMap. 当有元素插入到HashSet中时, 会被当做HashMap的key保存到map属性中去.对于HashMap来说,光有key还不够, 在HashSet的实现中, 每个key对应的value都默认为PRESENT属性, 也就是new了一个Object对象而已;123456789public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123; static final long serialVersionUID = -5024744406713321676L; //HashSet通过HashMap保存集合元素的： private transient HashMap&lt;E,Object&gt; map; //HashSet底层由HashMap实现，新增的元素为map的key，而value则默认为PRESENT。 private static final Object PRESENT = new Object();&#125; 2.4.2 构造方法HashSet的构造方法很简单, 主要是在方法内部初始化map属性, new了一个HashMap对象;123456789101112131415161718192021222324252627public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; //无参构造方法： public HashSet() &#123; //默认new一个HashMap map = new HashMap&lt;&gt;(); &#125; // 带集合的构造函数 public HashSet(Collection&lt;? extends E&gt; c) &#123; // 进行初始化HashMap容量判断， map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); &#125; // 指定HashSet初始容量和加载因子的构造函数：主要用于Map内部的扩容机制 public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor); &#125; // 指定HashSet初始容量的构造函数 public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity); &#125; //与前4个不同，此构造最终new了一个LinkedHashMap对象： HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125;&#125; 2.4.3 add()HashSet的add(E e)方法, 主要是调用底层HashMap的put(K key, V value)方法.其中key就是HashSet集合插入的元素, 而value则是默认的PRESENT属性(一个new Object());1234//调用HashMap中的put()方法:public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 2.4.4 remove()与add(E e)方法类似, HashSet的remove(Object o)也是调用了底层HashMap的(Object key)方法;主要是计算出要删除元素的hash值, 在HashMap找到对应的对象, 然后从Entry[]数组中删除;1234//调用HashMap中的remove方法：public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125; 2.5 TreeSet源码分析(基于JDK1.7.0_75)与HashSet类似, TreeSet底层也是采用了一个Map来保存集合元素, 这个Map就是NavigableMap.不过, NavigableMap仅仅是一个接口, 具体的实现还是使用了TreeMap类; 2.5.1 成员变量成员变量m是一个NavigableMap类型的Map集合, 常用实现是TreeMap对象;在TreeMap中, key是我们TreeSet插入的元素, 而value则是TreeSet中另一个成员变量PRESENT, 一个普通的不能再普通的Object对象;1234567public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable &#123; //TreeSet中保存元素的map对象： private transient NavigableMap&lt;E,Object&gt; m; //map对象中保存的value: private static final Object PRESENT = new Object();&#125; 2.5.2 构造方法12345678910111213141516171819202122232425public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable &#123; //最底层的构造方法，不对外。传入一个NavigableMap接口的实现类 TreeSet(NavigableMap&lt;E,Object&gt; m) &#123; this.m = m; &#125; //无参构造：向底层构造传入一个TreeMap对象： public TreeSet() &#123; this(new TreeMap&lt;E,Object&gt;()); &#125; //传入比较器的构造：通常传入一个自定义Comparator的实现类； public TreeSet(Comparator&lt;? super E&gt; comparator) &#123; this(new TreeMap&lt;&gt;(comparator)); &#125; //将集合Collection传入TreeSet中： public TreeSet(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; //将集合SortedSet传入TreeSet中： public TreeSet(SortedSet&lt;E&gt; s) &#123; this(s.comparator()); addAll(s); &#125;&#125; 2.5.3 add()向TreeSet中添加元素123public boolean add(E e) &#123; return m.put(e, PRESENT)==null;&#125; 2.5.4 remove()删除TreeSet中元素o123public boolean remove(Object o) &#123; return m.remove(o)==PRESENT;&#125; 2.6 SortedSet和NavigableSet到底是什么在一些关于TreeSet讲解的文章中, 在介绍TreeSet的时候都会提到NavigableSet, 接着会说下NavigableSet是个”导航Set集合”, 提供了一系列”导航”方法. 那么, 什么是”导航”方法?通过接口的定义, 我们可以看到NavigableSet继承了SortedSet接口(后面说), 实现了对其的扩展;而通过下面的方法, 我们得出NavigableSet实际提供了一系列的搜索匹配元素的功能, 能获取到某一区间内的集合元素;123456789101112131415161718192021public interface NavigableSet&lt;E&gt; extends SortedSet&lt;E&gt; &#123; E lower(E e);//返回此set集合中小于e元素的最大元素 E floor(E e);//返回此set集合中小于等于e元素的最大元素 E ceiling(E e);//返回此set集合中大于等于e元素的最小元素 E higher(E e);//返回此set集合中大于e元素的最小元素 E pollFirst(); //获取并移除此set集合中的第一个元素 E pollLast();//获取并移除此set集合中的最后一个元素 Iterator&lt;E&gt; iterator();//返回此set集合的迭代器--升序 NavigableSet&lt;E&gt; descendingSet();//以倒序的顺序返回此set集合 Iterator&lt;E&gt; descendingIterator();//返回此set集合的迭代器--倒序 //返回此set集合的部分元素--从fromElement开始到toElement结束，其中fromInclusive、toInclusive意为返回的集合是否包含头尾元素 NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive); //返回此set集合的部分元素--小于toElement，inclusive意味返回的集合是否包含toElement NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive); //返回此set集合的部分元素--从fromElement开始到toElement结束，包含头不含为尾 SortedSet&lt;E&gt; subSet(E fromElement, E toElement); //返回此set集合的部分元素--小于toElement SortedSet&lt;E&gt; headSet(E toElement); //返回此set集合的部分元素--大于等于toElement SortedSet&lt;E&gt; tailSet(E fromElement);&#125; 说完了NavigableSet, 我们在一起儿看下其父类SortedSet接口:通过名字, 我们可以得出此接口跟排序有关, 会提供跟排序的方法;1234567891011121314public interface SortedSet&lt;E&gt; extends Set&lt;E&gt; &#123; //返回与排序有关的比较器 Comparator&lt;? super E&gt; comparator(); //返回从fromElement到toElement的元素集合： SortedSet&lt;E&gt; subSet(E fromElement, E toElement); //返回从第一个元素到toElement元素的集合： SortedSet&lt;E&gt; headSet(E toElement); //返回从fromElement开始到最后元素的集合： SortedSet&lt;E&gt; tailSet(E fromElement); //返回集合中的第一个元素： E first(); //返回集合中的最后一个元素： E last();&#125; 3. 参考链接Java集合：Set源码详细分析(一)Java集合：Set源码详细分析(二)]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合(三)----HashMap]]></title>
    <url>%2F2018%2F09%2F22%2FJava%E9%9B%86%E5%90%88(%E4%B8%89)----HashMap%2F</url>
    <content type="text"><![CDATA[1. 前言集合是Java基础中非常重要的一部分, 也是日常中用到非常多的类, 这篇博客主要记录集合HashMap相关的知识. 2. HashMap2.1 概述HashMap 是用于映射(键值对)处理的数据类型, 基于哈希表的 Map 接口的非同步实现, 允许插入最多一条key为null的记录, 允许插入多条value为null的记录. 此外, HashMap 不保证元素顺序, 根据需要该容器可能会对元素重新哈希, 元素的顺序也会被重新打散, 因此在不同时间段迭代同一个 HashMap 的顺序可能会不同. HashMap 非线程安全, 即任一时刻有多个线程同时写 HashMap 的话可能会导致数据的不一致. HashMap 实际上是数组+链表+红黑树的结合体, 其底层包含一个数组, 数组中的每一项元素的可能值有四种: null, 单独一个结点, 链表, 红黑树(JDK1.8 开始 HashMap 通过使用红黑树来提高元素查找效率). 当往 HashMap 中 put 元素的时候, 需要先根据 key 的哈希值得到该元素在数组中的位置(即下标), 如果该位置上已经存放有其他元素了, 那么在这个位置上的元素将以链表或者红黑树的形式来存放, 如果该位置上没有元素, 就直接向该位置存放元素.HashMap 要求映射中的 key 是不可变对象，即要求该对象在创建后它的哈希值不会被改变，否则 Map 对象很可能就定位不到映射的位置了. 2.2 类声明12public class HashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable, Serializable 2.3 常量HashMap 中声明的常量有以下几个, 其中需要特别关注的是装载因子 DEFAULT_LOAD_FACTOR 和 TREEIFY_THRESHOLD. 装载因子用于规定数组在自动扩容之前可以数据占有其容量的最高比例, 即当数据量占有数组的容量达到这个比例后, 数组将自动扩容. 装载因子衡量的是一个散列表的空间的使用程度, 装载因子越大表示散列表的装填程度越高, 反之愈小. 因此如果装载因子越大, 则对空间的利用程度更高, 相对应的是查找效率的降低. 如果装载因子太小, 那么数组的数据将过于稀疏, 对空间的利用率低, 官方默认的装载因子为0.75, 是平衡空间利用率和运行效率两者之后的结果. 如果在实际情况中, 内存空间较多而对时间效率要求很高, 可以选择降低装载因子的值; 如果内存空间紧张而对时间效率要求不高, 则可以选择提高装载因子的值. 此外, 即使装载因子和哈希算法设计得再合理, 也不免会出现由于哈希冲突导致链表长度过长的情况, 这将严重影响 HashMap 的性能. 为了优化性能, 从 JDK1.8 开始引入了红黑树, 当链表长度超出 TREEIFY_THRESHOLD 规定的值时, 链表就会被转换为红黑树, 利用红黑树快速增删改查的特点以提高 HashMap 的性能.12345678910111213141516171819202122//序列化IDprivate static final long serialVersionUID = 362498820763181265L;//哈希桶数组的默认容量static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;//网上很多文章都说这个值是哈希桶数组能够达到的最大容量，其实这样说并不准确//从 resize() 方法的扩容机制可以看出来，HashMap 每次扩容都是将数组的现有容量增大一倍//如果现有容量已大于或等于 MAXIMUM_CAPACITY ，则不允许再次扩容//否则即使此次扩容会导致容量超出 MAXIMUM_CAPACITY ，那也是允许的static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//装载因子的默认值//装载因子用于规定数组在自动扩容之前可以数据占有其容量的最高比例，即当数据量占有数组的容量达到这个比例后，数组将自动扩容//装载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小//对于使用链表的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，则对空间的利用程度更高，相对应的是查找效率的降低//如果负载因子太小，那么数组的数据将过于稀疏，对空间的利用率低//官方默认的负载因子为0.75，是平衡空间利用率和运行效率两者之后的结果static final float DEFAULT_LOAD_FACTOR = 0.75f;//为了提高效率，当链表的长度超出这个值时，就将链表转换为红黑树static final int TREEIFY_THRESHOLD = 8; 2.4 成员变量123456789101112131415161718192021222324//哈希桶数组，在第一次使用时才初始化//容量值应是2的整数倍transient Node&lt;K, V&gt;[] table;/** * Holds cached entrySet(). Note that AbstractMap fields are used * for keySet() and values(). */transient Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;//Map的大小transient int size;//每当Map的结构发生变化时，此参数就会递增//当在对Map进行迭代操作时，迭代器会检查此参数值//如果检查到此参数的值发生变化，就说明在迭代的过程中Map的结构发生了变化，因此会直接抛出异常transient int modCount;//数组的扩容临界点，当数组的数据量达到这个值时就会进行扩容操作//计算方法：当前容量 x 装载因子int threshold;//使用的装载因子值final float loadFactor; 2.5 构造函数12345678910111213141516171819202122232425262728//设置Map的初始化大小和装载因子public HashMap(int initialCapacity, float loadFactor) &#123; //检查参数合法性 if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125;//设置Map的初始化大小public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;//都使用默认值public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR;&#125;//传入初始数据public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 2.6 结点类123456789101112131415161718//结点static class Node&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123; //当前结点的 key 的哈希值 final int hash; //键 final K key; //值 V value; //下一个结点 Node&lt;K, V&gt; next; Node(int hash, K key, V value, Node&lt;K, V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; ··· &#125; 2.7 哈希算法在查询, 添加和移除键值对时, 定位到哈希桶数组的指定位置都是很关键的第一步, 只有 HashMap 中的元素尽量分布均匀, 才能在定位键值对时快速地查找到相应位置, 避免频繁地去遍历链表或者红黑树, 这就需要依靠于一个比较好的哈希算法了. 以下是 HashMap 中计算 key 值的哈希值以及根据哈希值获取其在哈希桶数组中位置的算法.12345678910111213141516171819202122//计算哈希值static final int hash(Object key) &#123; int h; //高位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;//根据 key 值获取 Valuepublic V get(Object key) &#123; Node&lt;K, V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;//查找指定结点final Node&lt;K, V&gt; getNode(int hash, Object key) &#123; ··· //只有当 table 不为空且 hash 对应的位置不为 null 才有可获取的元素值 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; ··· &#125; return null;&#125; 确定键值对在哈希桶数组的位置的步骤分为三步: 计算 key 的 hashCode（h = key.hashCode()）, 高位运算（h &gt;&gt;&gt; 16）、取模运算（(n - 1) &amp; hash） 2.8 插入数据在上边说过, HashMap 是数组+链表+红黑树的结合, 数组包含的元素的可能值分为四种类型: null, 单个结点, 链表, 红黑树. 在插入结点时(每一个待存数据都会被包装为结点对象), 会根据待插入 Key 的哈希值来决定结点在数组中的位置, 如果计算得出的位置此时包含的元素为 null , 则直接将结点存入该位置, 如果不为 null , 则说明发生了哈希碰撞, 此时就需要将结点插入到链表或者是红黑树中. 当哈希算法的计算结果越分散均匀, 哈希碰撞的概率就越小, map 的存取效率就会越高. 如果待插入结点的 key 与链表或红黑树中某个已有结点的 key 相等(hash 值相等且两者 equals 成立), 则新添加的结点将覆盖原有数据.插入数据对应的是 put(K key, V value) 方法.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//插入数据public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;//计算哈希值static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent 为 true 表示不会覆盖有相同 key 的非 null value，否则会覆盖原有值 * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; p; int n, i; //如果 table 还未初始化，则调用 resize 方法进行初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //判断要存入的 key 是否存在哈希冲突，等于 null 说明不存在冲突 if ((p = tab[i = (n - 1) &amp; hash]) == null) //直接在索引 i 处构建包含待存入元素的结点 tab[i] = newNode(hash, key, value, null); else &#123; //走入本分支，说明待存入的 key 存在哈希冲突 Node&lt;K, V&gt; e; K k; //p 值已在上一个 if 语句中赋值了，此处就直接来判断 key 值之间的相等性 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //指向冲突的头结点 e = p; //如果头结点的 key 与待插入的 key 不相等，且头结点是 TreeNode 类型，说明该 hash 值是采用红黑树来处理冲突 else if (p instanceof TreeNode) //如果红黑数中包含有相同 key 的结点，则返回该结点，否则返回 null e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(this, tab, hash, key, value); else &#123; //采用链表来处理 hash 值冲突 for (int binCount = 0; ; ++binCount) &#123; //当遍历到链表尾部时 if ((e = p.next) == null) &#123; //构建一个新的结点添加到链表尾部 p.next = newNode(hash, key, value, null); //如果链表的长度已达到允许的最大长度 TREEIFY_THRESHOLD - 1 时，就将链表转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //当 e 指向的结点的 key 值与待插入的 key 相等时则跳出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; //如果 e != null，说明原先已存在相同 key 的键 if (e != null) &#123; V oldValue = e.value; //只有当 onlyIfAbsent 为 true 且 oldValue 不为 null 时才不会覆盖原有值 if (!onlyIfAbsent || oldValue == null) e.value = value; //用于 LinkedHashMap ，在 HashMap 中是空实现 afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //当元素数量达到扩容临界点时，需要进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 2.9 读取数据读取数据对应的是 get(Object key)方法12345678910111213141516171819202122232425262728293031//根据 key 值获取 Valuepublic V get(Object key) &#123; Node&lt;K, V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;//查找指定结点final Node&lt;K, V&gt; getNode(int hash, Object key) &#123; Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; first, e; int n; K k; //只有当 table 不为空且 hash 对应的位置不为 null 才有可获取的元素值 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //如果头结点的 hash 值与 Key 与待插入数据相等的话，则说明找到了对应值 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // first.next != null 说明存在哈希冲突 if ((e = first.next) != null) &#123; //如果是由红黑树来处理哈希冲突，则由此查找相应结点 if (first instanceof TreeNode) return ((TreeNode&lt;K, V&gt;) first).getTreeNode(hash, key); //遍历链表 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 2.10 移除结点从 Map 中移除键值对的操作, 在底层数据结构的体现就是移除对某个结点对象的引用, 可能是从数组中, 也可能是链表或者红黑树.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public V remove(Object key) &#123; Node&lt;K, V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; &#125; /** * Implements Map.remove and related methods * * @param hash key 的哈希值 * @param key the key * @param value key对应的值，只有当 matchValue 为 true 时才需要使用到，否则忽略该值 * @param matchValue 如果为 true ，则只有当 Map 中存在某个键 equals key 且 value 相等时才会移除该元素，否则只要 key 的 hash 值相等就直接移除该元素 * @param movable if false do not move other nodes while removing * @return the node, or null if none */ final Node&lt;K, V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; p; int n, index; //只有当 table 不为空且 hash 对应的索引位置存在值时才有可移除的对象 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K, V&gt; node = null, e; K k; V v; //如果与头结点的 key 相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; //存在哈希冲突 //用红黑树来处理哈希冲突 if (p instanceof TreeNode) //查找对应结点 node = ((TreeNode&lt;K, V&gt;) p).getTreeNode(hash, key); else &#123; //用链表来处理哈希冲突 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; //node != null 说明存在相应结点 //如果 matchValue 为 false ，则通过之前的判断可知查找到的结点的 key 与 参数 key 的哈希值一定相等，此处就可以直接移除结点 node //如果 matchValue 为 true ，则当 value 相等时才需要移除该结点 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) //对应红黑树 ((TreeNode&lt;K, V&gt;) node).removeTreeNode(this, tab, movable); else if (node == p) //对应 key 与头结点相等的情况，此时直接将指针移向下一位即可 tab[index] = node.next; else //对应的是链表的情况 p.next = node.next; ++modCount; --size; //用于 LinkedHashMap ，在 HashMap 中是空实现 afterNodeRemoval(node); return node; &#125; &#125; return null; &#125; 2.11 扩容如果哈希桶数组很大, 即使用的是较差的哈希算法元素也会比较分散, 如果哈希桶数组很小, 即使用的是好的哈希算法也会出现较多哈希碰撞的情况, 所以就需要在空间成本和时间成本之间权衡, 除了设计较好的哈希算法以减少哈希冲突外, 也需要在合适的的时机对哈希桶数组进行必要的扩容. 当 HashMap 中的元素越来越多时, 因为数组的长度是固定的, 所以哈希冲突的几率也就越来越高, 为了提高效率, 此时就需要对 HashMap 中的数组进行扩容, 而扩容操作最消耗性能的地方就在于: 原数组中的数据必须重新计算其在新数组中的位置并存放到新数组中. 那么 HashMap 扩容操作的触发时机是什么时候呢? 当 HashMap 中的元素个数超出 threshold 时(数组容量 与 loadFactor 的乘积), 就会进行数组扩容. 默认情况下, 数组的默认值为 16, loadFactor 的默认值为 0.75, 这是平衡空间利用率和运行效率两者之后的结果. 也就是说, 假设数组当前大小为16, loadFactor 值为0.75, 那么当 HashMap 中的元素个数达到12个时, 就会自动触发扩容操作, 把数组的大小扩充到 2 * 16 = 32, 即扩大一倍, 然后重新计算每个元素在新数组中的位置, 而这是一个非常消耗性能的操作, 所以如果已经预知到待存入 HashMap 的数据量, 那么在初始化 HashMap 时直接指定初始化大小会是一种更为高效的做法. 更改: 那么 HashMap 扩容操作的触发时机是什么时候呢?同时满足下面的两个条件:1. 存放新值的时候当前已有元素的个数必须大于等于阈值2. 存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值换算出来的数组下标位置已经存在值） 扩容操作对应的是 resize()方法 2.11.1 JDK1.8引入的扩容巧妙设计经过rehash之后, 元素的位置要么是在原位置, 要么是在原位置再移动2次幂的位置.图(a)表示扩容前的key1和key2两种key确定索引位置的示例;图(b)表示扩容后key1和key2两种key确定索引位置的示例, 其中hash1是key1对应的哈希与高位运算结果.元素在重新计算hash之后, 因为n变为2倍, 那么n-1的mask范围在高位多1bit(红色), 因此新的index就会发生这样的变化因此, 我们在扩充HashMap的时候, 不需要像JDK1.7的实现那样重新计算hash, 只需要看看原来的hash值新增的那个bit是1还是0就好了, 是0的话索引没变, 是1的话索引变成”原索引+oldCap”, 可以看看下图为16扩充为32的resize示意图:这个设计确实非常的巧妙, 既省去了重新计算hash值的时间, 而且同时, 由于新增的1bit是0还是1可以认为是随机的, 因此resize的过程, 均匀的把之前的冲突的节点分散到新的bucket了. 这一块就是JDK1.8新增的优化点. 有一点注意区别, JDK1.7中rehash的时候, 旧链表迁移新链表的时候, 如果在新表的数组索引位置相同, 则链表元素会倒置, 但是从上图可以看出, JDK1.8不会倒置. 2.11.2 resize源码解读12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879final Node&lt;K, V&gt;[] resize() &#123; Node&lt;K, V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float) newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float) MAXIMUM_CAPACITY ? (int) ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes"，"unchecked"&#125;) Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K, V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K, V&gt;) e).split(this, newTab, j, oldCap); else &#123; // 链表优化重hash的代码块 Node&lt;K, V&gt; loHead = null, loTail = null; Node&lt;K, V&gt; hiHead = null, hiTail = null; Node&lt;K, V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125;// 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 2.12 效率测试这里来测试下不同的初始化大小以及 key 值的 HashCode 值的分布情况的不同对 HashMap 效率的影响首先来定义作为 Key 的类, hashCode() 方法直接返回其包含的属性 value123456789101112131415161718import java.util.Objects;public class Key &#123; private int value; public Key(int value) &#123; this.value = value; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Key key = (Key) o; return value == key.value; &#125; @Override public int hashCode() &#123; return Objects.hash(value); &#125;&#125; 初始化大小从 100 到 100000 之间以 10 倍的倍数递增，向 HashMap 存入同等数据量的数据，观察不同 HashMap 存入数据消耗的总时间12345678910111213141516171819202122232425import java.util.HashMap;import java.util.Map;public class KeyMain &#123; private static final int MAX_KEY = 20000; private static final Key[] KEYS = new Key[MAX_KEY]; static &#123; for (int i = 0; i &lt; MAX_KEY; i++) &#123; KEYS[i] = new Key(i); &#125; &#125; private static void test(int size) &#123; long startTime = System.currentTimeMillis(); Map&lt;Key, Integer&gt; map = new HashMap&lt;&gt;(size); for (int i = 0; i &lt; MAX_KEY; i++) &#123; map.put(KEYS[i], i); &#125; long endTime = System.currentTimeMillis(); System.out.println("初始化大小是：" + size + " , 所用时间：" + (endTime - startTime) + "毫秒"); &#125; public static void main(String[] args) &#123; for (int i = 20; i &lt;= MAX_KEY; i *= 10) &#123; test(i); &#125; &#125;&#125; 运行结果:1234初始化大小是：20 , 所用时间：9毫秒初始化大小是：200 , 所用时间：13毫秒初始化大小是：2000 , 所用时间：5毫秒初始化大小是：20000 , 所用时间：3毫秒 在上述使用的例子中, 各个 Key 对象之间的哈希码值各不相同, 所以键值对在哈希桶数组中的分布可以说是很均匀的了, 此时主要影响性能的就是扩容机制了, 由上图可以看出各个初始化大小对 HashMap 的性能影响还是很大的接下来再看看各个 Key 对象之间频繁发生哈希冲突时 HashMap 的性能令 Key 类的 hashCode() 方法固定返回 100, 则每个键值对在存入 HashMap 时, 一定会发生哈希冲突1234@Overridepublic int hashCode() &#123; return 100;&#125; 运行结果:1234初始化大小是：20 , 所用时间：6192毫秒初始化大小是：200 , 所用时间：6004毫秒初始化大小是：2000 , 所用时间：5633毫秒初始化大小是：20000 , 所用时间：5914毫秒 此时主要影响性能的点就在于对哈希冲突的处理了 2.13 equals()和hashCode()在使用Map存对象的时候, 要记得, 一定要重写此类的 equals() 和 hashCode() 方法哦!!! 3. 参考链接HashMap源码，你知道多少？HashMap的扩容机制—resize()深入理解HashMap的扩容机制]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合(一)----List]]></title>
    <url>%2F2018%2F09%2F22%2FJava%E9%9B%86%E5%90%88(%E4%B8%80)----List%2F</url>
    <content type="text"><![CDATA[1. 前言集合是Java基础中非常重要的一部分, 也是日常中用到非常多的类, 这篇博客主要记录集合List相关的知识. 特别声明: 大部分内容并非原创, 引用自参考链接. 2. Java集合相比于数组(Array)来说, 集合类的长度可变, 更加适合于现代开发需求;在程序运行时, Java集合可以动态的进行扩展, 随着元素的增加而扩大.在Java中, 集合类通常存在于java.util包中.Java集合主要由2大体系构成, 分别是Collection体系和Map体系, 其中Collection和Map分别是2大体系中的顶层接口.Collection主要有三个子接口, 分别为List(列表), Set(集), Queue(队列). 其中, List, Queue中的元素有序可重复, 而Set中的元素无序不可重复;List中主要有ArrayList, LinkedList两个实现类; Set中则是有HashSet实现类; 而Queue是在JDK1.5后才出现的新集合, 主要以数组和链表两种形式存在.Map同属于java.util包中, 是集合的一部分,但与Collection是相互独立的, 没有任何关系. Map中都是以key-value的形式存在, 其中key必须唯一, 主要有HashMap, Hashtable, TreeMap三个实现类. 3. List在Collection中, List集合是有序的, Developer可对其中每个元素的插入位置进行精确地控制, 可以通过索引来访问元素, 遍历元素.在List集合中, 我们常用到ArrayList和LinkedList这两个类. 3.1 初识ArrayList其中, ArrayList底层通过数组实现, 随着元素的增加而动态扩容. 而LinkedList底层通过链表来实现, 随着元素的增加不断向链表的后端增加节点.ArrayList是Java集合框架中使用最多的一个类, 是一个数组队列, 线程不安全集合.它继承于AbstractList, 实现了List, RandomAccess, Cloneable, Serializable接口.(1)ArrayList实现List, 得到了List集合框架基础功能;(2)ArrayList实现RandomAccess, 获得了快速随机访问存储元素的功能, RandomAccess是一个标记接口, 没有任何方法;(3)ArrayList实现Cloneable, 得到了clone()方法, 可以实现克隆功能;(4)ArrayList实现Serializable, 表示可以被序列化, 通过序列化去传输, 典型的应用就是hessian协议. 它具有如下特点:(1)容量不固定, 随着容量的增加而动态扩容(阈值基本不会达到)(2)有序集合(插入的顺序=输出的顺序)(3)插入的元素可以为null(4)增删改查效率更高(相对于LinkedList来说)(5)线程不安全. 数据结构: 3.2 初识LinkedListLinkedList是一个双向链表, 每一个节点都拥有指向前后节点的引用. 相比于ArrayList来说, LinkedList的随机访问效率更低.它继承AbstractSequentialList, 实现了List, Deque, Cloneable, Serializable接口.(1)LinkedList实现List, 得到了List集合框架基础功能;(2)LinkedList实现Deque, Deque 是一个双向队列, 也就是既可以先入先出, 又可以先入后出,说 简单些就是既可以在头部添加元素, 也可以在尾部添加元素;(3)LinkedList实现Cloneable, 得到了clone()方法, 可以实现克隆功能;(4)LinkedList实现Serializable, 表示可以被序列化, 通过序列化去传输, 典型的应用就是hessian协议.数据结构: 3.3 List常用方法12345678910111213141516171819202122232425262728A:添加功能boolean add(E e):向集合中添加一个元素void add(int index, E element):在指定位置添加元素boolean addAll(Collection&lt;? extends E&gt; c)：向集合中添加一个集合的元素。B:删除功能void clear()：删除集合中的所有元素E remove(int index)：根据指定索引删除元素，并把删除的元素返回boolean remove(Object o)：从集合中删除指定的元素boolean removeAll(Collection&lt;?&gt; c):从集合中删除一个指定的集合元素。C:修改功能E set(int index, E element):把指定索引位置的元素修改为指定的值，返回修改前的值。D:获取功能E get(int index)：获取指定位置的元素Iterator iterator():就是用来获取集合中每一个元素。E:判断功能boolean isEmpty()：判断集合是否为空。boolean contains(Object o)：判断集合中是否存在指定的元素。boolean containsAll(Collection&lt;?&gt; c)：判断集合中是否存在指定的一个集合中的元素。F:长度功能int size():获取集合中的元素个数。G:把集合转换成数组Object[] toArray():把集合变成数组。 3.4 ArrayList和LinkedList性能比较3.4.1 元素新增从直观上看, 在新增操作时, ArrayList效率不如LinkedList, 因为ArrayList底层是数组实现, 在动态扩容时, 性能有所损耗, 而LinkedList不存在数组扩容机制, 所以LinkedList效率更高. 1234567891011121314151617181920212223242526public class ListTest &#123; //迭代次数 public static int ITERATION_NUM = 100000; public static void main(String[] agrs) &#123; insertPerformanceCompare(); &#125; //新增性能比较： public static void insertPerformanceCompare() &#123; System.out.println("LinkedList新增测试开始"); long start = System.nanoTime(); List&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;(); for (int x = 0; x &lt; ITERATION_NUM; x++) &#123; linkedList.add(x); &#125; long end = System.nanoTime(); System.out.println(end - start); System.out.println("ArrayList新增测试开始"); start = System.nanoTime(); List&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); for (int x = 0; x &lt; ITERATION_NUM; x++) &#123; arrayList.add(x); &#125; end = System.nanoTime(); System.out.println(end - start); &#125;&#125; 结果: 1234567891011121314151617第一组:LinkedList新增测试开始7609993ArrayList新增测试开始6071437第二组:LinkedList新增测试开始12317919ArrayList新增测试开始5754172第三组:LinkedList新增测试开始8291202ArrayList新增测试开始5320576 结果与预想的有些不太一样, ArrayList的新增性能并不低.究其原因, 可能是经过JDK近几年的更新发展, 对于数组复制的实现进行了优化, 以至于ArrayList的性能也得到了提高. 也可能是由于, LinkedList每次add操作都需要创建一个node对象, 这会产生额外开销, 而ArrayList只有在扩容的时候才需要数组的复制, 不扩容的时候, 没有额外开销. 3.4.2 元素获取由于LinkedList是链表结构, 没有角标的概念, 没有实现RandomAccess接口, 不具备随机元素访问功能, 所以在get方面表现的差强人意, ArrayList再一次完胜. 1234567891011121314151617181920212223242526272829303132333435363738public class ListTest &#123; //迭代次数，集合大小： public static int ITERATION_NUM = 100000; public static void main(String[] agrs) &#123; getPerformanceCompare(); &#125; //获取性能比较： public static void getPerformanceCompare() &#123; //填充ArrayList集合： List&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); for (int x = 0; x &lt; ITERATION_NUM; x++) &#123; arrayList.add(x); &#125; //填充LinkedList集合： List&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;(); for (int x = 0; x &lt; ITERATION_NUM; x++) &#123; linkedList.add(x); &#125; //创建随机数对象： Random random = new Random(); System.out.println("LinkedList获取测试开始"); long start = System.nanoTime(); for (int x = 0; x &lt; ITERATION_NUM; x++) &#123; int j = random.nextInt(x + 1); int k = linkedList.get(j); &#125; long end = System.nanoTime(); System.out.println(end - start); System.out.println("ArrayList获取测试开始"); start = System.nanoTime(); for (int x = 0; x &lt; ITERATION_NUM; x++) &#123; int j = random.nextInt(x + 1); int k = arrayList.get(j); &#125; end = System.nanoTime(); System.out.println(end - start); &#125;&#125; 结果: 1234567891011121314151617第一组:LinkedList获取测试开始6193992452ArrayList获取测试开始9773597第二组:LinkedList获取测试开始6920119875ArrayList获取测试开始4026352第三组:LinkedList获取测试开始5559676521ArrayList获取测试开始10468298 从结果中可以看到, ArrayList在随机访问方面表现的十分优秀, 比LinkedList强了很多, 基本上保持在500-1000倍.LinkedList为什么这么慢呢?这主要是LinkedList的代码实现所致, 每一次获取都是从头开始遍历, 一个个节点去查找, 每查找一次就遍历一次, 所以性能自然得不到提升. 3.5 ArrayList源码分析(基于JDK1.7.0_45)接下来, 我们几对ArrayList的源码进行一个解析, 主要从以下几个问题出发.(1)ArrayList构造(2)增删改查实现(3)迭代器-modCount(4)为什么数组对象要使用transient修饰符(5)System.arraycopy()参数含义 和 Arrays.copyOf()参数含义我们通过这这几个问题, 来一步步的学习ArrayList. 3.5.1 ArrayList构造器在JDK1.7版本中, ArrayList的无参构造方法并没有生成容量为10的数组;elementData对象是ArrayList集合底层保存元素的实现;size属性记录了ArrayList集合中实际元素的个数; 123456789101112131415161718192021222324252627282930313233343536373839public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; //实现Serializable接口，生成的序列版本号： private static final long serialVersionUID = 8683452581122892189L; //ArrayList初始容量大小：在无参构造中不使用了 private static final int DEFAULT_CAPACITY = 10; //空数组对象：初始化中默认赋值给elementData private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //ArrayList中实际存储元素的数组： private transient Object[] elementData; //集合实际存储元素长度： private int size; //ArrayList有参构造：容量大小 public ArrayList(int initialCapacity) &#123; //即父类构造：protected AbstractList() &#123;&#125;空方法 super(); //如果传递的初始容量小于0 ，抛出异常 if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); //初始化数据：创建Object数组 this.elementData = new Object[initialCapacity]; &#125; //ArrayList无参构造： public ArrayList() &#123; //即父类构造：protected AbstractList() &#123;&#125;空方法 super(); //初始化数组：空数组，容量为0 this.elementData = EMPTY_ELEMENTDATA; &#125; //ArrayList有参构造：Java集合 public ArrayList(Collection&lt;? extends E&gt; c) &#123; //将集合转换为数组： elementData = c.toArray(); //设置数组的长度： size = elementData.length; if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125;&#125; 3.5.2 add()ArrayList增加元素的方法事关重要, 我们都知道ArrayList底层是由数组, 可以随着元素的增加而扩容, 那么具体是如何实现的呢?在JDK1.7当中, 当第一个元素添加时, ensureCapacityInternal()方法会计算ArrayList的扩容大小, 默认为10;其中grow()方法最为重要, 如果需要扩容, 那么扩容后的大小是原来的1.5倍, 实际上最终调用了Arrays.copyOf()方法得以实现; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//添加元素epublic boolean add(E e) &#123; ensureCapacityInternal(size + 1); //将对应角标下的元素赋值为e： elementData[size++] = e; return true;&#125;//得到最小扩容量private void ensureCapacityInternal(int minCapacity) &#123; //如果此时ArrayList是空数组,则将最小扩容大小设置为10： if (elementData == EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //判断是否需要扩容： ensureExplicitCapacity(minCapacity);&#125;//判断是否需要扩容private void ensureExplicitCapacity(int minCapacity) &#123; //操作数+1 modCount++; //判断最小扩容容量-数组大小是否大于0： if (minCapacity - elementData.length &gt; 0) //扩容： grow(minCapacity);&#125;//ArrayList动态扩容的核心方法:private void grow(int minCapacity) &#123; //获取现有数组大小： int oldCapacity = elementData.length; //位运算，得到新的数组容量大小，为原有的1.5倍： int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //如果新扩容的大小依旧小于传入的容量值，那么将传入的值设为新容器大小： if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //如果新容器大小，大于ArrayList最大长度： if (newCapacity - MAX_ARRAY_SIZE &gt; 0) //计算出最大容量值： newCapacity = hugeCapacity(minCapacity); //数组复制： elementData = Arrays.copyOf(elementData, newCapacity);&#125;//计算ArrayList最大容量：private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) throw new OutOfMemoryError(); //如果新的容量大于MAX_ARRAY_SIZE。将会调用hugeCapacity将int的最大值赋给newCapacity: return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 3.5.3 remove()remove(int index)是针对于角标来进行删除, 不需要去遍历整个集合, 效率更高;而remove(Object o)是针对于对象来进行删除, 需要遍历整个集合进行equals()方法比对, 所以效率较低;不过, 无论是哪种形式的删除, 最终都会调用System.arraycopy()方法进行数组复制操作, 所以效率都会受到影响; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//在ArrayList的移除index位置的元素public E remove(int index) &#123; //检查角标是否合法：不合法抛异常 rangeCheck(index); //操作数+1： modCount++; //获取当前角标的value: E oldValue = elementData(index); //获取需要删除元素 到最后一个元素的长度，也就是删除元素后，后续元素移动的个数； int numMoved = size - index - 1; //如果移动元素个数大于0 ，也就是说删除的不是最后一个元素： if (numMoved &gt; 0) // 将elementData数组index+1位置开始拷贝到elementData从index开始的空间 System.arraycopy(elementData, index+1, elementData, index, numMoved); //size减1，并将最后一个元素置为null elementData[--size] = null; //返回被删除的元素： return oldValue;&#125;//在ArrayList的移除对象为O的元素，不返回被删除的元素：public boolean remove(Object o) &#123; //如果o==null，则遍历集合，判断哪个元素为null： if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; //快速删除，和前面的remove（index）一样的逻辑 fastRemove(index); return true; &#125; &#125; else &#123; //同理： for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;//快速删除：private void fastRemove(int index) &#123; //操作数+1 modCount++; //获取需要删除元素 到最后一个元素的长度，也就是删除元素后，后续元素移动的个数； int numMoved = size - index - 1; //如果移动元素个数大于0 ，也就是说删除的不是最后一个元素： if (numMoved &gt; 0) // 将elementData数组index+1位置开始拷贝到elementData从index开始的空间 System.arraycopy(elementData, index+1, elementData, index, numMoved); //size减1，并将最后一个元素置为null elementData[--size] = null;&#125; 3.5.4 set()由于ArrayList实现了RandomAccess, 所以具备了随机访问特性, 调用elementData()可以获取到对应元素的值； 1234567891011//设置index位置的元素值了element，返回该位置的之前的值public E set(int index, E element) &#123; //检查index是否合法：判断index是否大于size rangeCheck(index); //获取该index原来的元素： E oldValue = elementData(index); //替换成新的元素： elementData[index] = element; //返回旧的元素： return oldValue;&#125; 3.5.5 get()通过elementData()方法获取对应角标元素, 在返回时候进行类型转换; 1234567891011//获取index位置的元素public E get(int index) &#123; //检查index是否合法： rangeCheck(index); //获取元素： return elementData(index);&#125;//获取数组index位置的元素：返回时类型转换E elementData(int index) &#123; return (E) elementData[index];&#125; 3.5.6 modCount含义在Itr迭代器初始化时,将ArrayList的modCount属性的值赋值给了expectedModCount.通过上面的例子中, 我们可以知道当进行增删改时, modCount会随着每一次的操作而+1, modCount记录了ArrayList内发生改变的次数.当迭代器在迭代时, 会判断expectedModCount的值是否还与modCount的值保持一致, 如果不一致则抛出异常.AbstractList类当中定义的变量: 1protected transient int modCount = 0; ArrayList获取迭代器对象: 1234//返回一个Iterator对象，Itr为ArrayList的一个内部类，其实现了Iterator&lt;E&gt;接口public Iterator&lt;E&gt; iterator() &#123; return new java.util.ArrayList.Itr();&#125; 迭代器实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//Itr实现了Iterator接口，是ArrayList集合的迭代器对象private class Itr implements Iterator&lt;E&gt; &#123; //类似游标，指向迭代器下一个值的位置 int cursor; //迭代器最后一次取出的元素的位置。 int lastRet = -1; //Itr初始化时候ArrayList的modCount的值。 int expectedModCount = modCount; //利用游标，与size之前的比较，判断迭代器是否还有下一个元素 public boolean hasNext() &#123; return cursor != size; &#125; //迭代器获取下一个元素： public E next() &#123; //检查modCount是否改变： checkForComodification(); int i = cursor; //游标不会大于等于集合的长度： if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = java.util.ArrayList.this.elementData; //游标不会大于集合中数组的长度： if (i &gt;= elementData.length) throw new ConcurrentModificationException(); //游标+1 cursor = i + 1; //取出元素： return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); //检查modCount是否改变：防止并发操作集合 checkForComodification(); try &#123; //删除这个元素： java.util.ArrayList.this.remove(lastRet); //删除后，重置游标，和当前指向元素的角标 lastRet cursor = lastRet; lastRet = -1; //重置expectedModCount： expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; //并发检查： final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 3.5.7 transienttransient修饰符是什么含义?当我们序列化对象时, 如果对象中某个属性不进行序列化操作, 那么在该属性前添加transient修饰符即可实现; 例如: 1private transient Object[] elementData; 那么, 为什么ArrayList不想对elementData属性进行序列化呢? elementData可是集合中保存元素的数组啊, 如果不序列化elementData属性, 那么在反序列化时候, 岂不是丢失了原先的元素?ArrayList在添加元素时, 可能会对elementData数组进行扩容操作, 而扩容后的数组可能并没有全部保存元素.例如: 我们创建了new Object[10]数组对象, 但是我们只向其中添加了1个元素, 而剩余的9个位置并没有添加元素. 当我们进行序列化时, 并不会只序列化其中一个元素, 而是将整个数组进行序列化操作, 那些没有被元素填充的位置也进行了序列化操作, 间接的浪费了磁盘的空间, 以及程序的性能.所以, ArrayList才会在elementData属性前加上transient修饰符.接下来, 我们来看下ArrayList的writeObject(), readObject(): 12345678910111213141516171819202122232425//序列化写入：private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; int expectedModCount = modCount; s.defaultWriteObject(); s.writeInt(size); for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;// 序列化读取：private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; s.defaultReadObject(); s.readInt(); if (size &gt; 0) &#123; ensureCapacityInternal(size); Object[] a = elementData; for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; ArrayList在序列化时会调用writeObject(), 直接将elementData写入ObjectOutputStream;而反序列化时则调用readObject(), 从ObjectInputStream获取elementData; 3.5.8 Arrays.copyOf()该方法在内部创建了一个新数组, 底层实现是调用System.arraycopy(); 12345678public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; original - 要复制的数组newLength - 要返回的副本的长度newType - 要返回的副本的类型 3.5.9 System.arraycopy()该方法是用了native关键字, 调用的为C++编写的底层函数. 123public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); src - 源数组srcPos - 源数组中的起始位置dest - 目标数组destPos - 目标数据中的起始位置length - 要复制的数组元素的数量 3.6 LinkedList源码分析(基于JDK1.7.0_45)发现很多文章在介绍的时候, 都说LinkedList是一个环形链表结构, 头尾相连. 但, 当我开始看源码的时候, 发现并不是环形链表, 是一个直线型链表结构. 这是因为JDK1.7之前的版本是环形链表, 而到了JDK1.7以后进行了优化, 变成了直线型链表结构; 3.6.1 LinkedList基础结构在LinkedList中, 内部类Node对象最为重要, 它组成了LinkedList集合的整个链表, 分别指向上一个点, 下一个结点, 存储着集合中的元素;成员变量中, first表明是头结点, last表明是尾结点; 1234567891011121314151617181920212223242526272829303132public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123; //LinkedList的元素个数： transient int size = 0; //LinkedList的头结点：Node内部类 transient java.util.LinkedList.Node&lt;E&gt; first; //LinkedList尾结点：Node内部类 transient java.util.LinkedList.Node&lt;E&gt; last; //空实现：头尾结点均为null，链表不存在 public LinkedList() &#123; &#125; //调用添加方法： public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; //节点的数据结构，包含前后节点的引用和当前节点 private static class Node&lt;E&gt; &#123; //结点元素： E item; //结点后指针 java.util.LinkedList.Node&lt;E&gt; next; //结点前指针 java.util.LinkedList.Node&lt;E&gt; prev; Node(java.util.LinkedList.Node&lt;E&gt; prev, E element, java.util.LinkedList.Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125;&#125; 3.6.2 add()LinkedList的添加方法, 主要分为2种, 一是直接添加一个元素, 二是在指定角标下添加一个元素;add(E e)底层调用linkLast(E e)方法, 就是在链表的最后面插入一个元素;add(int index, E element), 插入的角标如果==size, 则插入到链表最后; 否则, 按照角标大小插入到对应位置; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//添加元素：添加到最后一个结点；public boolean add(E e) &#123; linkLast(e); return true;&#125;//last节点插入新元素：void linkLast(E e) &#123; //将尾结点赋值个体L: final java.util.LinkedList.Node&lt;E&gt; l = last; //创建新的结点，将新节点的前指针指向l: final java.util.LinkedList.Node&lt;E&gt; newNode = new java.util.LinkedList.Node&lt;&gt;(l, e, null); //新节点置为尾结点： last = newNode; //如果尾结点l为null：则是空集合新插入 if (l == null) //头结点也置为 新节点： first = newNode; else //l节点的后指针指向新节点： l.next = newNode; //长度+1 size++; //操作数+1 modCount++;&#125;//向对应角标添加元素：public void add(int index, E element) &#123; //检查传入的角标 是否正确： checkPositionIndex(index); //如果插入角标==集合长度，则插入到集合的最后面： if (index == size) linkLast(element); else //插入到对应角标的位置：获取此角标下的元素先 linkBefore(element, node(index));&#125;//在succ前插入 新元素e：void linkBefore(E e, java.util.LinkedList.Node&lt;E&gt; succ) &#123; //获取被插入元素succ的前指针元素： final java.util.LinkedList.Node&lt;E&gt; pred = succ.prev; //创建新增元素节点，前指针 和 后指针分别指向对应元素： final java.util.LinkedList.Node&lt;E&gt; newNode = new java.util.LinkedList.Node&lt;&gt;(pred, e, succ); succ.prev = newNode; //succ的前指针元素可能为null，为null的话说明succ是头结点，则把新建立的结点置为头结点： if (pred == null) first = newNode; else //succ前指针不为null，则将前指针的结点的后指针指向新节点： pred.next = newNode; //长度+1 size++; //操作数+1 modCount++;&#125; 对于LinkedList集合增加元素来说, 可以简单的概括为以下几点:将添加的元素转换为LinkedList的Node对象节点;增加该Node节点的前后引用, 即该Node节点的prev, next属性, 让其分别指向哪一个节点);修改该Node节点的前后Node节点中pre/next属性, 使其指向该节点. 3.6.3 remove()LinkedList的删除也提供了2种形式, 其一是通过角标删除元素, 其二就是通过对象删除元素; 不过, 无论哪种删除, 最终调用的都是unlink来实现的; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//删除对应角标的元素：public E remove(int index) &#123; checkElementIndex(index); //node()方法通过角标获取对应的元素，在后面介绍 return unlink(node(index));&#125;//删除LinkedList中的元素，可以删除为null的元素，逐个遍历LinkedList的元素，重复元素只删除第一个：public boolean remove(Object o) &#123; //如果删除元素为null： if (o == null) &#123; for (java.util.LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; //如果删除元素不为null： for (java.util.LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125;//移除LinkedList结点：remove()方法中调用E unlink(java.util.LinkedList.Node&lt;E&gt; x) &#123; //获取被删除结点的元素E： final E element = x.item; //获取被删除元素的后指针结点： final java.util.LinkedList.Node&lt;E&gt; next = x.next; //获取被删除元素的前指针结点： final java.util.LinkedList.Node&lt;E&gt; prev = x.prev; //被删除结点的 前结点为null的话： if (prev == null) &#123; //将后指针指向的结点置为头结点 first = next; &#125; else &#123; //前置结点的 尾结点指向被删除的next结点； prev.next = next; //被删除结点前指针置为null: x.prev = null; &#125; //对尾结点同样处理： if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 3.6.4 set()LinkedList的set(int index, E element)方法与add(int index,E element)的设计思路基本一致, 都是创建新Node节点, 插入到对应的角标下, 修改前后节点的prev, next属性;其中, node(int index)方法至关重要, 通过对应角标获取到对应的集合元素.可以看到, node()中是根据角标的大小是选择从前遍历还是从后遍历整个集合. 也可以间接的说明, LinkedList在随机获取元素时性能很低, 每次的获取都得从头或者从尾遍历半个集合. 123456789101112131415161718192021222324252627//设置对应角标的元素：public E set(int index, E element) &#123; checkElementIndex(index); //通过node()方法，获取到对应角标的元素： java.util.LinkedList.Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125;//获取对应角标所属于的结点：java.util.LinkedList.Node&lt;E&gt; node(int index) &#123; //位运算：如果位置索引小于列表长度的一半，则从头开始遍历；否则，从后开始遍历； if (index &lt; (size &gt;&gt; 1)) &#123; java.util.LinkedList.Node&lt;E&gt; x = first; //从头结点开始遍历：遍历的长度就是index的长度，获取对应的index的元素 for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; //从集合尾结点遍历： java.util.LinkedList.Node&lt;E&gt; x = last; //同样道理： for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 3.6.5 get()1get(int index) 终于到了最后一个方法, 也是开发中最常用的方法. 其中, 核心方法node(int index)在上面已经介绍过.在通过node(int index)获取到对应节点后, 返回节点中的item属性, 该属性就是我们所保存的元素. 1234567//获取相应角标的元素：public E get(int index) &#123; //检查角标是否正确： checkElementIndex(index); //获取角标所属结点的 元素值： return node(index).item;&#125; 4. 参考链接Java集合：ListJava集合：List源码详细分析]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人收藏]]></title>
    <url>%2F2018%2F09%2F22%2F%E4%B8%AA%E4%BA%BA%E6%94%B6%E8%97%8F%2F</url>
    <content type="text"><![CDATA[一、日常使用二、在线工具 markdown表格在线生成工具http://www.tablesgenerator.com/markdown_tables 16进制转文本字符串http://www.bejson.com/convert/ox2str/ 密码生成器https://suijimimashengcheng.51240.com/ 三、客户端工具 Sublime Text(可以以十六进制的形式显示文本文件)https://www.sublimetext.com/]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>收藏夹</tag>
      </tags>
  </entry>
</search>
