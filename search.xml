<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java高并发程序设计(七)--并行算法之并行排序]]></title>
    <url>%2F2019%2F03%2F12%2FJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E4%B8%83)--%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B9%B6%E8%A1%8C%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1. 分离数据相关性:奇偶交换排序选择排序. 冒泡排序的过程 奇偶交换排序的过程 奇偶交换排序说白了就是将整个比较交换分割为奇阶段和偶阶段,使得每一个阶段内的所有比较和交换都是没有数据相关性的.因此,每一次比较和交换都可以独立执行,也就可以并行化了. 1.1 奇偶交换排序的串行实现1234567891011121314151617181920public static void oddEvenSort(int [] arr)&#123; int exchFlag = 1; int start = 0; while (exchFlag == 1 || start == 1)&#123; exchFlag = 0; for(int i = start; i &lt; arr.length - 1; i += 2)&#123; if(arr[i] &gt; arr[i+1])&#123; int temp = arr[i]; arr[i] = arr[i+1]; arr[i+1] = temp; exchFlag = 1; &#125; &#125; if(start == 0)&#123; start = 1; &#125;else &#123; start = 0; &#125; &#125;&#125; 1.2 奇偶交换排序的并行实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; pOddEvenSort(arr); for(int i = 0; i &lt; arr.length; i++)&#123; System.out.println(arr[i]); &#125; pool.shutdown(); &#125; static int [] arr = new int[] &#123;2,3,6,6,8,9,6,2&#125;; static ExecutorService pool = Executors.newCachedThreadPool(); static int exchFlag = 1; static synchronized void setExchFlag(int v)&#123; exchFlag = v; &#125; static synchronized int getExchFlag()&#123; return exchFlag; &#125; public static class OddEvenSortTask implements Runnable&#123; int i; CountDownLatch countDownLatch; public OddEvenSortTask(int i, CountDownLatch countDownLatch) &#123; this.i = i; this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; if(arr[i] &gt; arr[i+1])&#123; int temp = arr[i]; arr[i] = arr[i+1]; arr[i+1] = temp; setExchFlag(1); &#125; countDownLatch.countDown(); &#125; &#125; public static void pOddEvenSort(int [] arr) throws InterruptedException &#123; int start = 0; while (getExchFlag() == 1 || start == 1)&#123; setExchFlag(0); int num = arr.length/2 - (arr.length % 2 == 0?start:0); CountDownLatch countDownLatch = new CountDownLatch(num); for(int i = start; i &lt; arr.length - 1; i = i + 2)&#123; pool.submit(new OddEvenSortTask(i, countDownLatch)); &#125; countDownLatch.await(); if(start == 0)&#123; start = 1; &#125;else &#123; start = 0; &#125; &#125; &#125;&#125; 2. 希尔排序简单的插入排序很难并行化,因为这一次的数据插入依赖于上一次得到的有序序列,因此多个步骤之间无法并行.为此,我们可以对插入排序进行扩展,这就是希尔排序. 希尔排序将整个数组根据建个h分割为若干个子数组.子数组相互穿插在一起,在每一次排序时,分别对每一个子数组进行排序.当h为3时,希尔排序将整个数组分为交织在一起的三个子数组,其中,所有的方块为一个子数组,所有的圆形,三角形分别组成另外两个子数组,每次排序时,总算交换间隔为h的两个元素. 2.1 串行实现1234567891011121314151617public class Solution &#123; public void shellSort(int[] array) &#123; int d = array.length; while (d &gt; 0) &#123; d = d / 2; for (int i = d; i &lt; array.length; i++) &#123; int number = array[i]; int j = i - d; while (j &gt;= 0 &amp;&amp; array[j] &gt; number) &#123; array[j + d] = array[j]; j -= d; &#125; array[j + d] = number; &#125; &#125; &#125;&#125; 2.2 并行实现123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; static ExecutorService es = Executors.newCachedThreadPool(); static int[] array = &#123;1, 3, 4, 5, 2&#125;; public static class shellSort implements Runnable &#123; static int d; static int start; static CountDownLatch latch; public shellSort(int d, int start, CountDownLatch latch) &#123; this.d = d; this.start = start; this.latch = latch; &#125; @Override public void run() &#123; for (int i = start; i &lt; array.length; i++) &#123; int number = array[i]; int j = i - d; while (j &gt;= 0 &amp;&amp; array[j] &gt; number) &#123; array[j + d] = array[j]; j -= d; &#125; array[j + d] = number; latch.countDown(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException&#123; int d = array.length; while (d &gt; 0) &#123; d /= 2; CountDownLatch latch = new CountDownLatch(d); for (int i = 0; i &lt; d; i++) &#123; es.submit(new shellSort(d, i, latch)); &#125; latch.await(); &#125; &#125;&#125; 3. 参考文献&lt;&lt; Java高并发程序设计 &gt;&gt;(葛一鸣 郭超) 插入排序及希尔排序的并行化实现]]></content>
      <categories>
        <category>高并发程序设计</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
        <tag>并发设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高并发程序设计(六)--并行算法之并行搜索]]></title>
    <url>%2F2019%2F03%2F12%2FJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E5%85%AD)--%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B9%B6%E8%A1%8C%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[1. 并行搜索并行的无序数组的搜索实现. 给定一个数组,我们要查找满足条件的元素. 2. 思考对于串行程序来说,只要遍历一下数组就可以得到结果.但是如果要使用并行方式,则需要额外增加一些线程间的通信机制,使各个线程可以有效运行. 一种简单的策略就是将原始数据集合按照期望的线程数进行分割.如果我们计划使用两个线程进行搜索,那么就可以把一个数组或集合分割成两个.每个线程各自独立搜索,当其中有一个线程找到数据后,立即返回结果即可. 3. 示例SearchTask 1234567891011121314import java.util.concurrent.Callable;public class SearchTask implements Callable&lt;Integer&gt; &#123; int begin, end, searchValue; public SearchTask(int begin, int end, int searchValue) &#123; this.begin = begin; this.end = end; this.searchValue = searchValue; &#125; @Override public Integer call()&#123; int re = Main.search(begin, end, searchValue); return re; &#125;&#125; Main 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.ArrayList;import java.util.List;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.atomic.AtomicInteger;public class Main &#123; public static int [] arr = new int[]&#123;1, 2, 3&#125;; public static AtomicInteger result = new AtomicInteger(-1); public static final int Thread_Num = 2; public static ExecutorService pool = Executors.newCachedThreadPool(); public static int search(int begin, int end, int searchValue)&#123; for(int i = begin; i &lt; end; i++)&#123; if(result.get() &gt;= 0)&#123; return result.get(); &#125; if(arr[i] == searchValue)&#123; if(!result.compareAndSet(-1, i))&#123; return result.get(); &#125; return i; &#125; &#125; return -1; &#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; int val = 3; int subArrSize = arr.length / Thread_Num + 1; List&lt;Future&lt;Integer&gt;&gt; re = new ArrayList&lt;&gt;(); for(int i = 0 ; i &lt; arr.length; i += subArrSize)&#123; int end = i + subArrSize; if(end &gt; arr.length)&#123; end = arr.length; &#125; re.add(pool.submit(new SearchTask(i, end, val))); &#125; for(Future&lt;Integer&gt; fu : re)&#123; if(fu.get() &gt;= 0)&#123; System.out.println(fu.get()); &#125; &#125; &#125;&#125; 4. 参考文献&lt;&lt; Java高并发程序设计 &gt;&gt;(葛一鸣 郭超)]]></content>
      <categories>
        <category>高并发程序设计</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
        <tag>并发设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CPU Cache的优化--解决伪共享问题]]></title>
    <url>%2F2019%2F03%2F11%2FCPU%20Cache%E7%9A%84%E4%BC%98%E5%8C%96--%E8%A7%A3%E5%86%B3%E4%BC%AA%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 伪共享问题(false sharing)对于解释伪共享问题,就需要了解一下缓存行的相关概念.缓存行是主存复制到高速缓存的最小单位,一般情况下缓存行的大小为32~128字节(通常为64字节). 在多线程程序执行的过程中,有可能将2个或多个需要频繁修改的变量存储在同一个缓存行当中.这样以来,会频繁的造成缓存头失效的问题.如下图所示: 从编码的角度,为了解决上面的问题,可以使用额外字段来填充缓存行数据.从而达到不同变量之间占用不用的缓存行,增加缓存的命中率.优化后如下图所示: 2. 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Test implements Runnable &#123; //public static final int NUM_THREAD = Runtime.getRuntime().availableProcessors(); // CUP核数 public static final int NUM_THREAD = 4; // CPU核数 public static final long INTERATIONS = 500L * 1000L * 1000L; private final int arrayIndex; private static VolatileLong[] longs = new VolatileLong[NUM_THREAD]; static &#123; for (int i = 0; i &lt; longs.length; i++) &#123; longs[i] = new VolatileLong(); &#125; &#125; public Test(final int arrayIndex) &#123; this.arrayIndex = arrayIndex; &#125; public static void main(String[] args) throws InterruptedException &#123; System.out.println(Runtime.getRuntime().availableProcessors()); final long start = System.currentTimeMillis(); runTest(); System.out.println("duration = " + (System.currentTimeMillis() - start)); &#125; private static void runTest() throws InterruptedException &#123; Thread[] threads = new Thread[NUM_THREAD]; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new Thread(new Test(i)); &#125; for (Thread thread : threads) &#123; thread.start(); &#125; for (Thread thread : threads) &#123; thread.join(); &#125; &#125; @Override public void run() &#123; long i = INTERATIONS + 1; while (0 != --i) &#123; longs[arrayIndex].value = i; &#125; &#125; public static final class VolatileLong &#123; public volatile long value = 0L; public long p1, p2, p3, p4, p5, p6, p7; // 用来填充缓存行 &#125;&#125; 1234# 有填充代码duration = 5100# 无填充代码duration = 32064 3. 参考链接CPU Cache的优化：解决伪共享问题]]></content>
      <categories>
        <category>高并发程序设计</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
        <tag>并发设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高并发程序设计(五)--并行模式]]></title>
    <url>%2F2019%2F03%2F11%2FJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E4%BA%94)--%E5%B9%B6%E8%A1%8C%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 单例模式1234567891011public class StaticSingleton &#123; private StaticSingleton()&#123; System.out.println("StaticSingleton is create"); &#125; private static class SingletonHolder&#123; private static StaticSingleton instance = new StaticSingleton(); &#125; public static StaticSingleton getInstance()&#123; return SingletonHolder.instance; &#125;&#125; 相比传统的单例模式的优点:1.只有在第一次使用的时候,实例才会被创建.2.没有锁,高并发环境下性能优越. 2. 不变模式在并行软件的开发过程中,同步操作似乎是不可避免的,当多线程对同一个对象进行读写操作时,为了保证数据一致性和正确性,有必要对对象进行同步.而同步操作对系统的性能是有相当的损耗的,为了尽可能的取出这些同步操作,提高程序并行能力,可以使用一种不可变对象,依靠对象的不变性,可以确保其在没有同步操作的多线程环境中依然时钟保持内部状态一致性和正确性,这就是不变模式. 不变模式天生就是多线程友好的,它的核心思想是,一个对象一旦被创建,则它的状态将永远不会发生改变.所以,没有一个线程可以修改其内部状态和数据,同时其内部状态也绝不会自行发生改变.基于这些特性,对不变对象的多线程操作不需要进行同步控制. 不变模式和只读模式是有一定区别的.不变模式是比只读属性具有更强一致性和不变性.对只读属性的对象而言,对象本身不能被其他线程修改,但是对象的自身状态却可能自行修改.比如,一个对象的存活时间是只读的,但是这个属性,随着时间的推移,是时刻变化的. 不变模式的主要使用场景需要满足2个条件:1.当前对象创建后,其内部状态和数据不再发生任何变化;2.对象需要被共享,被多线程频繁访问. 在Java语言中,不变模式的实现很简单.为确保对象被创建后,不发生任何改变,并保证不变模式正常工作,只需注意以下4点:1.取出所有setter方法及所有修改自身属性的方法;2.将所有属性设置为私有,并用final修饰,确保其不可修改;3.确保没有子类可以重载修改它的行为,即final class;4.有一个可以创建完整对象的构造函数. 在JDK中,不变模式的应用非常广泛.其中,最为典型的就是java.lang.String类.此外,所有的元数据类包装类,都是使用不变模式实现的.主要的不变模式类型如下: 123456789java.lang.Stringjava.lang.Booleanjava.lang.Bytejava.lang.Characterjava.lang.Doublejava.lang.Floatjava.lang.Integerjava.lang.Longjava.lang.Short 由于基本数据类型和String类型在实际的软件开发中应用及其广泛,使用不变模式后,所有实例的方法均不需要进行同步操作,保证了它们在多线程环境下的性能. 3. 生产者-消费者模式生产者-消费者模式是一个经典的多线程设计模式.它为多线程间的协作提供了良好的解决方案.在生产者-消费者模式中,通常由两类线程,即若干个生产者线程和若干个消费者线程.生产者线程负责提交用户请求,消费者线程则负责具体处理生产者提交的任务.生产者和消费者之间则通过共享内存缓冲区进行通信. 3.1 示例生产者 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.Random;import java.util.concurrent.BlockingQueue;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;public class Producer implements Runnable&#123; private volatile boolean isRunning = true; private BlockingQueue&lt;PCData&gt; queue; private static AtomicInteger count = new AtomicInteger(); private static final int SLEEPTIME = 1000; public Producer(BlockingQueue&lt;PCData&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; PCData data = null; System.out.println("start producer id = " + Thread.currentThread().getId()); try &#123; while (isRunning)&#123; Thread.sleep(SLEEPTIME); data = new PCData(count.incrementAndGet()); System.out.println(data + "is put into queue"); if(!queue.offer(data, 2, TimeUnit.SECONDS))&#123; System.err.println("failed to put data: " + data); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); Thread.currentThread().interrupt(); &#125; &#125; public void stop()&#123; isRunning = false; &#125;&#125; 消费者 123456789101112131415161718192021222324252627282930313233import java.text.MessageFormat;import java.util.Random;import java.util.concurrent.BlockingQueue;public class Consumer implements Runnable &#123; private BlockingQueue&lt;PCData&gt; queue; private static final int SLEEPTIME = 1000; public Consumer(BlockingQueue&lt;PCData&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; System.out.println("start Consumer id = " + Thread.currentThread().getId()); Random r = new Random(); try &#123; while (true)&#123; PCData data = queue.take(); if(data != null)&#123; int re = data.getData() * data.getData(); System.out.println(MessageFormat.format("&#123;0&#125; * &#123;1&#125; = &#123;2&#125;", data.getData(), data.getData(), re)); Thread.sleep(r.nextInt(SLEEPTIME)); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); Thread.currentThread().interrupt(); &#125; &#125;&#125; 任务 123456789101112131415161718public class PCData &#123; private final int data; public PCData(int data) &#123; this.data = data; &#125; public int getData() &#123; return data; &#125; @Override public String toString() &#123; return "PCData&#123;" + "data=" + data + '&#125;'; &#125;&#125; 客户端 12345678910111213141516171819202122232425262728293031import java.util.concurrent.BlockingQueue;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.LinkedBlockingQueue;public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; BlockingQueue&lt;PCData&gt; queue = new LinkedBlockingQueue&lt;&gt;(); Producer producer1 = new Producer(queue); Producer producer2 = new Producer(queue); Producer producer3 = new Producer(queue); Consumer consumer1 = new Consumer(queue); Consumer consumer2 = new Consumer(queue); Consumer consumer3 = new Consumer(queue); ExecutorService service = Executors.newCachedThreadPool(); service.execute(producer1); service.execute(producer2); service.execute(producer3); service.execute(consumer1); service.execute(consumer2); service.execute(consumer3); Thread.sleep(10 * 1000); producer1.stop(); producer2.stop(); producer3.stop(); Thread.sleep(3000); service.shutdown(); &#125;&#125; 高性能的生产者-消费者可以通过无锁的方式的实现,如第三方框架Disruptor. 4. Futrue模式Future模式是多线程开发中非常常见的一种设计模式.它的核心思想是异步调用.当我们需要调用一个函数方法时,如果这个函数执行很慢,那么我们就要进行等待.但有时候,我们可能并不急着要结果.因此,我们可以让被调用者立即返回,让他在后台慢慢处理这个请求.对于调用者来说,则可以先处理一些其他任务,在真正需要数据的场合再去尝试获取需要的数据. 4.1 示例 Data 123public interface Data &#123; public String getResult();&#125; RealData 12345678910111213141516171819202122public class RealData implements Data &#123; protected final String result; public RealData(String result) &#123; StringBuffer stringBuffer = new StringBuffer(); for(int i = 0; i &lt; 10; i++)&#123; stringBuffer.append(result); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.result = stringBuffer.toString(); &#125; @Override public String getResult() &#123; return result; &#125;&#125; FutureData 1234567891011121314151617181920212223242526public class FutureData implements Data &#123; protected RealData realData = null; protected boolean isReady = false; public synchronized void setRealData(RealData realData)&#123; if(isReady == true)&#123; return; &#125; this.realData = realData; isReady = true; notifyAll(); &#125; @Override public synchronized String getResult() &#123; while (!isReady)&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; return realData.getResult(); &#125;&#125; Client 12345678910111213public class Client &#123; public Data request(final String queryStr)&#123; final FutureData futureData = new FutureData(); new Thread()&#123; @Override public void run() &#123; RealData realData = new RealData(queryStr); futureData.setRealData(realData); &#125; &#125;.start(); return futureData; &#125;&#125; Main 123456789public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; Client client = new Client(); Data data = client.request("name"); System.out.println("请求完毕"); Thread.sleep(2000); System.out.println("数据 = " + data.getResult()); &#125;&#125; 4.2 说明JDK内部已经有一套完整的实现.可以直接使用. 5. 并行流水线并行算法可以充分发挥多核CPU的性能,但是,并非所有的计算都可以改造成并发的形式. 执行过程中有数据相关性的运算都是无法完美并行化的. 解决的思路就是流水线的思想. 6. 参考文献&lt;&lt; Java高并发程序设计 &gt;&gt;(葛一鸣 郭超) Java多线程 - Future模式]]></content>
      <categories>
        <category>高并发程序设计</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
        <tag>并发设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java四种引用]]></title>
    <url>%2F2019%2F03%2F07%2FJava%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 定义Java四种引用包括强引用,软引用,弱引用,虚引用. 1.1 强引用只要引用存在,垃圾回收器永远不会回收. 123456Object obj = new Object();// 也可直接通过obj取得对应的对象,如:obj.equels(new Object());// 而这样,obj对象对后面new Object的一个强引用,只有当obj这个引用被释放之后,对象才会被释放掉,这也是我们经常所用到的编码形式. 1.2 软引用非必须引用,内存溢出之前进行回收,可以通过以下代码实现 123456Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null;sf.get();//有时候会返回null// 这时候sf是对obj的一个软引用,通过sf.get()方法可以取到这个对象,当然,当这个对象被标记为需要回收的对象时,则返回null; 软引用主要用户实现类似缓存的功能,在内存足够的情况下直接通过软引用取值,无需从繁忙的真实来源查询数据,提升速度;当内存不足时,自动删除这部分缓存数据,从真正的来源查询这些数据. 1.3 弱引用第二次垃圾回收时回收,可以通过如下代码实现 1234567Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null;wf.get();//有时候会返回nullwf.isEnqueued();//返回是否被垃圾回收器标记为即将回收的垃圾// 弱引用是在第二次垃圾回收时回收,短时间内通过弱引用取对应的数据,可以取到,当执行过第二次垃圾回收时,将返回null. 弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾,可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记. 1.4 虚引用垃圾回收时回收,无法通过引用取到对象值,可以通过如下代码实现 123456Object obj = new Object();ReferenceQueue queue = new ReferenceQueue();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, queue);obj=null;pf.get();//永远返回nullpf.isEnqueued();//返回是否从内存中已经删除 虚引用是每次垃圾回收的时候都会被回收,通过虚引用的get方法永远获取到的数据为null,因此也被成为幽灵引用.虚引用主要用于检测对象是否已经从内存中删除. 2. 参考链接Java四种引用包括强引用，软引用，弱引用，虚引用。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存泄漏与内存溢出]]></title>
    <url>%2F2019%2F03%2F07%2FJava%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[1. 定义内存溢出 out of memory,是指程序在申请内存时,没有足够的内存空间供其使用,出现out of memory;比如申请了一个integer,但给它存了long才能存下的数,那就是内存溢出.(内存溢出就是你要求分配的内存超出了系统能给你的,系统不能满足需求,于是产生溢出.) 内存泄露 memory leak,是指程序在申请内存后,无法释放已申请的内存空间,一次内存泄露危害可以忽略,但内存泄露堆积后果很严重,无论多少内存,迟早会被占光.(内存泄漏 即 该被释放的内存没有被及时的释放,一直被某个或某些实例所持有却不再使用导致GC不能回收.) 2. 参考链接内存溢出和内存泄漏的区别、产生原因以及解决方案]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高并发程序设计(四)--锁优化及注意事项]]></title>
    <url>%2F2019%2F03%2F01%2FJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E5%9B%9B)--%E9%94%81%E4%BC%98%E5%8C%96%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[1. 提高锁性能的几点建议锁优化的核心思想就是尽可能减少锁带来的额外开销. 1.1 减少锁持有时间减少锁的持有时间有助于降低锁冲突的可能性,进而提升系统的并发能力. 对比两段代码 123456// 代码一public synchronized void syncMethod()&#123; othercode1(); metextMethod(); othercode2();&#125; 12345678// 代码二public void syncMethod2()&#123; othercode1(); synchronized (this) &#123; metextMethod(); &#125; othercode2();&#125; 其中, othercode1()othercode2()都没有持有锁的必要性. 1.2 减少锁粒度所谓减少锁粒度,就是指缩小锁定对象的范围,从而减少锁冲突的可能性,进而提高系统的并发能力. ConcurrentHashMap就是典型的实例(相对于HashMap),使用分段锁减少了锁粒度. 缺点是,当系统需要取得全局锁时,其消耗的资源会比较多,因为当试图访问全局信息时,就会需要同时取得所有段的锁方能顺利实施.(参考ConcurrentHashMap的size方法) 1.3 读写分离锁来替换独占锁本质上是减少锁粒度的一种情况,上面ConcurrentHashMap是通过分割结构实现,而读写分离锁则是对系统功能点的分割.适用于读多写少的场景. 1.4 锁分离锁分离是读写锁思想的进一步延伸.说白了就是,根据应用程序的功能特点,使用分离思想.比如LinkedBlockingQueue中对队列的put和take,是两个不存在锁竞争的操作,如果用一把独占锁,就会导致锁竞争相对比较激烈,因此可以用两把不同的锁控制,从而减少冲突. 1.5 锁粗化虚拟机在遇到一连串地对同一锁不断进行请求和释放的操作时,便会把所有的锁操作整合成对锁的一次请求,从而减少对锁的请求同步次数,这个操作叫做锁的粗化. 12345678910111213// 优化前synchronized (lock)&#123; // 1. do sth.&#125;synchronized (lock)&#123; // 2. do sth.&#125;// 优化后synchronized (lock)&#123; // 1. do sth. // 2. do sth.&#125; 在开发过程中,应该有意识地在合理的场合进行锁的粗化,尤其是当在循环内请求锁时. 12345678910111213// 优化前for(int i = 0; i &lt; CIRCLE; i++)&#123; synchronized (lock)&#123; // do sth. &#125;&#125;// 优化后synchronized (lock)&#123; for(int i = 0; i &lt; CIRCLE; i++)&#123; // do sth. &#125;&#125; 锁粗化的思想和减少锁持有时间是相反的,在不同的场合,它们的效果不同,应该根据实际情况,进行权衡. 2. JVM在锁优化方面的工作2.1 锁偏向如果一个线程获得了锁,那么锁就进入了偏向模式,当这个线程再次请求锁时,无须再做任何同步操作,这样就节省了大量有关锁申请的操作,从而提高了程序性能.因此,对于几乎没有锁竞争的场合,偏向锁有比较好的优化效果,因为连续多次极有可能是同一个线程请求相同的锁.而对于锁竞争比较激烈的场合,其效果不佳.因为在竞争激烈的场合,最有可能的情况是每次都是不同的线程来请求相同的锁.这样偏向模式会失效,还不如不启用偏向锁. 可以使用JVM参数来显式开启偏向锁. 2.2 轻量级锁如果偏向锁失败,虚拟机并不会立即挂起线程,它还会使用一种称为轻量级锁的优化手段.轻量级锁的操作也很轻便,它只是简单地将对象头部作为指针,指向持有锁的线程堆栈的内部,来判断一个线程是否持有对象锁.如果线程获得轻量级锁成功,则可以顺利进入临界区,如果轻量级锁加锁失败,则表示其他线程抢先争夺到了锁,那么当前线程的请求就会膨胀为重量级锁. 2.3 自旋锁锁膨胀后,虚拟机为避免线程真实地在操作系统层面挂起,虚拟机还会做最后的努力–自旋锁,由于当前线程暂时无法获得锁,但是什么时候可以获得锁是一个未知数.也许在几个CPU时钟周期后,就可以得到锁.如果这样,简单粗暴地挂起线程可能是一种得不偿失的操作.因此,系统会进行一次赌注:它会假设在不久的将来,线程可以得到这把锁.因此,虚拟机会让当前线程做几个空循环,在经过若干次循环后,如果可以得到锁,那么就顺利进入临界区.如果还不能得到锁,才会真实地将线程在操作系统层面挂起. 2.4 锁消除锁消除是一种更彻底的锁优化.Java虚拟机在JIT编译时,通过对上下文的扫描,去除不可能存在共享资源竞争的锁.通过锁消除,可以节省毫无意义的请求锁时间. 锁消除涉及的关键技术为逃逸分析,所谓逃逸分析,就是观察某一个变量是否会逃出某一个作用域. 逃逸分析必须在-server模式下进行,逃逸分析和锁消除都需要通过JVM参数开启. 3. ThreadLocalThreadLocal,顾名思义,线程的局部变量,只有当前线程可以访问. 3.1 基本使用为每一个线程分配不同的线程对象,需要在应用层面保证.ThreadLocal只是起到了简单的容器作用. 1234567891011121314151617181920212223242526272829303132import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Course &#123; private static ThreadLocal&lt;SimpleDateFormat&gt; t1 = new ThreadLocal&lt;SimpleDateFormat&gt;(); public static class ParseDate implements Runnable&#123; private int i = 0; public ParseDate(int i) &#123; this.i = i; &#125; @Override public void run() &#123; try &#123; if(t1.get() == null)&#123; t1.set(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")); &#125; Date t = t1.get().parse("2019-03-07 15:29:" + i%60); System.out.println(i + ":" + t); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newFixedThreadPool(10); for(int i = 0; i &lt; 1000; i++)&#123; executorService.execute(new ParseDate(i)); &#125; &#125;&#125; 3.2 实现原理12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 思考: 这些变量是维护在Thread类内部的,这也意味着只要线程不退出,对象的引用将一直存在.线程退出时,Thread类会进行一些清理工作,包括清理ThreadLocalMap. 1234567891011121314private void exit() &#123; if (group != null) &#123; group.threadTerminated(this); group = null; &#125; /* Aggressively null out all reference fields: see bug 4006245 */ target = null; /* Speed the release of some of these resources */ threadLocals = null; inheritableThreadLocals = null; inheritedAccessControlContext = null; blocker = null; uncaughtExceptionHandler = null;&#125; 如果使用线程池,将一些大对象设置到ThreadLocal中,就可能会出现内存泄漏.如果希望及时回收对象,最好使用ThreadLocal.remove(). 另外, 通过 t1 = null 也可以实现对象的回收, 其中t1是ThreadLocal. 具体原理如下图. 3.3 ThreadLocal有何好处如果共享对象对于竞争的处理容易引起性能损失, 我们就应该考虑使用ThreadLocal为每个线程分配单独的对象. ThreadLocal 并不是为了解决线程安全问题,而是提供了一种将实例绑定到当前线程的机制,类似于隔离的效果,实际上自己在方法中 new 出来变量也能达到类似的效果. ThreadLocal 最大的用处就是用来把实例变量共享成全局变量,在程序的任何方法中都可以访问到该实例变量而已. 也就是说 ThreadLocal 的用法和我们自己 new 对象一样, 然后将这个 new 的对象传递到各个方法中. 但是到处传递的话, 太麻烦了. 这个时候,就应该用 ThreadLocal. 4. 无锁锁是一种悲观的策略,它总是假设每一次的临界区操作会产生冲突.无锁是一种乐观的策略,它会假设对资源的访问是没有冲突的.无锁策略核心是CAS(Compare And Set) 4.1 并发策略CAS优点:非阻塞性导致对死锁问题天生免疫;线程间相互影响远小于基于锁的方式;没有锁竞争带来的系统开销,也没有线程间频繁调度带来的开销. CAS算法的过程是这样:它包含三个参数 CAS(V,E,N). V表示要更新的变量,E表示预期的值,N表示新值. 仅当V值等于E值时,才会将V的值设置成N,否则什么都不做.最后CAS返回当前V的值.CAS算法需要你额外给出一个期望值,也就是你认为现在变量应该是什么样子,如果变量不是你想象的那样,那说明已经被别人修改过.你就重新读取,再次尝试修改即可. 4.2 无锁的线程安全整数AtomicIntergerJDK并发包中的atomic包,里面实现了一些直接使用CAS操作的线程安全的类型. 4.3 无锁的对象引用AtomicReferenceAtomicReference是对应普通的对象引用.也就是它可以保证你再修改对象引用时的线程安全性. 4.3.1 ABA问题比如说一个线程one从内存位置V中取出A,这时候另一个线程two也从内存中取出A,并且two进行了一些操作变成了B,然后two又将V位置的数据变成A,这时候线程one进行CAS操作发现内存中仍然是A,然后one操作成功.尽管线程one的CAS操作成功,但是不代表这个过程就是没有问题的.如果链表的头在变化了两次后恢复了原值.但是不代表链表就没有变化. 4.4 带有时间戳的对象引用AtomicStampedReference针对ABA问题,AtomicReference会存在问题,于是有了AtomicStampedReference来解决ABA问题. AtomicStampedReference它内部不仅维护了对象的值,还维护了一个时间戳(实际上可以使用任何一个整数来表示状态值),当AtomicStampedReference对应的数值被修改时,除了更新数据本身外,还必须要更新时间戳.当AtomicStampedReference设置对象值时,对象值以及时间戳都必须满足期望值,写入才会成功.因此即使对象值被反复读写,写回原值,只要时间戳发生变化,就能防止不恰当的写入. 4.5 无锁数组AtomicIntergerArray本质上是对int[]类型的封装,并用CAS控制int[]在多线程下的安全性. 4.6 普通变量享受原子操作AtomicIntegerFieldUpdaterAtomicIntegerFieldUpdater可以让普通变量也享受CAS操作带来的线程安全性. 几点注意: a.只能修改可见范围内的变量.b.变量必须是volatile类型.c.不支持static字段. 4.7 让线程之间互相帮助SynchronousQueueSynchronousQueue,数据交换通道. 5. 死锁死锁一旦发生,如果没有外力介入,这种等待将永远存在,从而对程序产生严重的影响. 避免死锁的办法:使用无锁函数 或者 使用重入锁的中断或者限时等待. 6. 参考链接&lt;&lt; Java高并发程序设计 &gt;&gt;(葛一鸣 郭超) ThreadLocal的彻底理解（ThreadLocal不是用来解决多线程下访问共享变量问题的）]]></content>
      <categories>
        <category>高并发程序设计</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
        <tag>并发设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 如何在线程池中寻找堆栈]]></title>
    <url>%2F2019%2F02%2F24%2FJava%20%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E5%AF%BB%E6%89%BE%E5%A0%86%E6%A0%88%2F</url>
    <content type="text"><![CDATA[1. 问题123456789101112131415161718192021import java.util.concurrent.*;public class Test &#123; public static class DivTask implements Runnable&#123; int a, b; public DivTask(int a, int b) &#123; this.a = a; this.b = b; &#125; @Override public void run() &#123; double re = a / b; System.out.println(re); &#125; &#125; public static void main(String[] args)&#123; ExecutorService executorService = new ThreadPoolExecutor(0, 5, 0L, TimeUnit.MILLISECONDS, new SynchronousQueue&lt;&gt;()); for(int i = 0; i &lt; 5; i++)&#123; executorService.submit(new DivTask(100, i)); &#125; &#125;&#125; 输出结果 1234100.033.025.050.0 没有报错信息. 2. 解决方案探索2.1 方法一:放弃submit改用execute1executorService.execute(new DivTask(100, i)); 12345Exception in thread "pool-1-thread-1" java.lang.ArithmeticException: / by zero at Test$DivTask.run(Test.java:15) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) 2.2 方法二:将submit的返回值打印12Future re = executorService.submit(new DivTask(100, i));re.get(); 1234567891011java.util.concurrent.ExecutionException: java.lang.ArithmeticException: / by zero at java.util.concurrent.FutureTask.report(FutureTask.java:122) at java.util.concurrent.FutureTask.get(FutureTask.java:192) at Test.main(Test.java:24)Caused by: java.lang.ArithmeticException: / by zero at Test$DivTask.run(Test.java:15) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) 3. 解决方案对比上面的解决方案一无法定位到问题是从哪里提交的 方案二可以知道问题是从哪里提交的 推荐采用方案二. 4. 参考链接&lt;&lt; Java高并发程序设计 &gt;&gt;(葛一鸣 郭超)]]></content>
      <categories>
        <category>高并发程序设计</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
        <tag>高并发程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高并发程序设计(三)--JDK并发包]]></title>
    <url>%2F2019%2F02%2F23%2FJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E4%B8%89)--JDK%E5%B9%B6%E5%8F%91%E5%8C%85%2F</url>
    <content type="text"><![CDATA[1. 同步控制这部分介绍多线程控制方法. 1.1 重入锁重入锁是synchronized的替代品,但是JDK6.0开始,synchronized做了大量的优化,两者性能差距不大. 123456789101112131415161718192021222324import java.util.concurrent.locks.ReentrantLock;public class Test &#123; public static class Demo extends Thread&#123; public static ReentrantLock reentrantLock = new ReentrantLock(); public static int i = 0; @Override public void run() &#123; for(int j = 0; j &lt; 1000000; j++)&#123; reentrantLock.lock(); i++; reentrantLock.unlock(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Demo(); Thread thread2 = new Demo(); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println(Demo.i); &#125;&#125; 重入锁特性重入锁之所以叫这个名字,是因为这种锁可以反复进入,就是说,一个线程可以连续两次获得同一把锁,但是在释放锁的时候,也必须释放相同次数. 12345reentrantLock.lock();reentrantLock.lock();i++;reentrantLock.unlock();reentrantLock.unlock(); 中断响应就是让锁可以响应中断,使用lock1.lockInterruptibly()来进行上锁即可收到中断请求. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.concurrent.locks.ReentrantLock;public class Test &#123; public static ReentrantLock lock1 = new ReentrantLock(); public static ReentrantLock lock2 = new ReentrantLock(); public static class Demo extends Thread&#123; int lock; public Demo(int lock) &#123; this.lock = lock; &#125; @Override public void run() &#123; try &#123; if(lock == 1)&#123; lock1.lockInterruptibly(); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; System.out.println("Interrupted Point1"); &#125; lock2.lockInterruptibly(); &#125;else &#123; lock2.lockInterruptibly(); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; System.out.println("Interrupted Point2"); &#125; lock1.lockInterruptibly(); &#125; &#125; catch (InterruptedException e) &#123; System.out.println("Interrupted Point3"); &#125;finally &#123; if(lock1.isHeldByCurrentThread())&#123; lock1.unlock(); &#125; if(lock2.isHeldByCurrentThread())&#123; lock2.unlock(); &#125; System.out.println(Thread.currentThread().getId()+":线程退出."); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Demo(1); Thread thread2 = new Demo(2); thread1.start(); thread2.start(); Thread.sleep(1000); thread2.interrupt(); &#125;&#125; 锁申请等待限时会不停地去获取锁,但是最大等待时间不会超过给定的值.通过lock.tryLock()实现,带参用法如下实例,不带参可以理解为时长为0.获取锁成功返回值为true,否则返回值为false. 123456789101112131415161718192021222324252627282930import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.ReentrantLock;public class Test &#123; public static ReentrantLock lock = new ReentrantLock(); public static class Demo extends Thread&#123; @Override public void run() &#123; try &#123; if(lock.tryLock(5, TimeUnit.SECONDS))&#123; System.out.println(Thread.currentThread().getId()+":get lock success"); Thread.sleep(6000); &#125;else &#123; System.out.println(Thread.currentThread().getId()+":get lock failed"); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if(lock.isHeldByCurrentThread())&#123; lock.unlock(); &#125; &#125; &#125; &#125; public static void main(String[] args)&#123; Thread t1 = new Demo(); Thread t2 = new Demo(); t1.start(); t2.start(); &#125;&#125; 公平锁公平锁保证先到者先得,后到者后得.不会产生饥饿现象.可重入锁默认是非公平锁.公平锁性能相对非常低下,因为要求系统维护一个有序队列.synchronized锁是非公平锁.通过new ReentrantLock(true)设置参数指定开启公平锁,true表示开启. 1234567891011121314151617181920import java.util.concurrent.locks.ReentrantLock;public class Test &#123; public static ReentrantLock lock = new ReentrantLock(true); public static class Demo extends Thread&#123; @Override public void run() &#123; while(true)&#123; lock.lock(); System.out.println(Thread.currentThread().getId()+":获得锁"); lock.unlock(); &#125; &#125; &#125; public static void main(String[] args)&#123; Thread t1 = new Demo(); Thread t2 = new Demo(); t1.start(); t2.start(); &#125;&#125; 1.2 Condition条件与 重入锁 配合使用, 达到synchronized锁中的wait notify的效果.condition.await()会使当前线程等待并释放锁.使用condition.signal()之前一定要先获得锁,用完之后一定要记得释放锁. 12345678910111213141516171819202122232425262728import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class Test &#123; public static ReentrantLock lock = new ReentrantLock(); public static Condition condition = lock.newCondition(); public static class Demo extends Thread&#123; @Override public void run() &#123; lock.lock(); try &#123; condition.await(); System.out.println("Thread is going on"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Demo(); t1.start(); Thread.sleep(2000); lock.lock(); condition.signal(); lock.unlock(); &#125;&#125; 1.3 信号量Semaphore可以指定多个线程同时访问某一个资源,并指定准入数量.有很多用法,跟ReentrantLock类似,下面给一个典型的demo. 1234567891011121314151617181920212223242526import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;public class Test &#123; public static Semaphore semaphore = new Semaphore(5); public static class Demo extends Thread&#123; @Override public void run() &#123; try &#123; semaphore.acquire(); Thread.sleep(2000); System.out.println(Thread.currentThread().getId()+":DONE!"); semaphore.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args)&#123; ExecutorService executorService = Executors.newFixedThreadPool(20); Thread thread = new Demo(); for(int i = 0; i &lt; 20; i++)&#123; executorService.submit(thread); &#125; &#125;&#125; 1.4 读写锁ReadWriteLock读写分离锁可以减少锁竞争,因为如果用重入锁,所有的读之间,读写之间,写写之间都是串行的.但是从日常需求上看,读读应该是允许并行的.适用于读多写少. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.Random;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import java.util.concurrent.locks.ReentrantReadWriteLock;public class Test &#123; public static Lock lock = new ReentrantLock(); public static ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock(); public static Lock readLock = reentrantReadWriteLock.readLock(); public static Lock writeLock = reentrantReadWriteLock.writeLock(); public int value; public int read(Lock lock)&#123; try &#123; lock.lock(); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); return value; &#125; &#125; public void write(Lock lock, int value)&#123; try &#123; lock.lock(); Thread.sleep(2000); this.value = value; &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; public static void main(String[] args)&#123; Test test = new Test(); Runnable readRunnable = new Runnable() &#123; @Override public void run() &#123; test.read(readLock);// test.read(lock); &#125; &#125;; Runnable writeRunnable = new Runnable() &#123; @Override public void run() &#123; test.write(writeLock, new Random().nextInt());// test.write(lock, new Random().nextInt()); &#125; &#125;; for(int i = 0; i &lt; 18; i++)&#123; new Thread(readRunnable).start(); &#125; for(int i = 18; i &lt; 20; i++)&#123; new Thread(writeRunnable).start(); &#125; &#125;&#125; 1.5 倒计时器CountDownLatch让线程等待,直到倒计时结束(满足停止等待的条件),再开始执行. 12345678910111213141516171819202122232425262728import java.util.Random;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Test &#123; public static CountDownLatch end = new CountDownLatch(10); public static class Demo implements Runnable &#123; @Override public void run() &#123; try &#123; Thread.sleep(new Random().nextInt(10) * 1000); System.out.println("Check complete"); end.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newFixedThreadPool(10); for(int i = 0; i &lt; 10; i++)&#123; executorService.submit(new Demo()); &#125; end.await(); System.out.println("Fire"); executorService.shutdown(); &#125;&#125; 1.6 循环栅栏CyclicBarrier功能和 倒计时器CountDownLatch 类似, 但是 循环栅栏CyclicBarrier 功能更加强大. 表现在 可以反复使用.用法:new CyclicBarrier(N, new BarrierRun(flag, N)),N表示计数器,new BarrierRun(flag, N)表示每次计数器满足之后所执行的操作. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.Random;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class Test &#123; public static class Soldier implements Runnable&#123; private String soldier; private final CyclicBarrier cyclicBarrier; public Soldier(CyclicBarrier cyclicBarrier, String soldierName) &#123; this.cyclicBarrier = cyclicBarrier; this.soldier = soldierName; &#125; @Override public void run() &#123; try &#123; cyclicBarrier.await(); dowork(); cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; void dowork()&#123; try &#123; Thread.sleep(Math.abs(new Random().nextInt()%10000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(soldier+":任务完成"); &#125; &#125; public static class BarrierRun implements Runnable&#123; boolean flag; int N; public BarrierRun(boolean flag, int n) &#123; this.flag = flag; N = n; &#125; @Override public void run() &#123; if(flag)&#123; System.out.println("司令:[士兵"+N+"个,完成任务!]"); &#125;else &#123; System.out.println("司令:[士兵"+N+"个,集合完毕!]"); flag = true; &#125; &#125; &#125; public static void main(String[] args)&#123; int N = 10; Thread [] allSoldier = new Thread[N]; boolean flag = false; CyclicBarrier cyclicBarrier = new CyclicBarrier(N, new BarrierRun(flag, N)); System.out.println("集合队伍!"); for(int i = 0; i &lt; N; i ++)&#123; System.out.println("士兵"+ i + "报道!"); allSoldier[i] = new Thread(new Soldier(cyclicBarrier, "士兵"+i)); allSoldier[i].start(); &#125; &#125;&#125; 1.7 线程阻塞工具类LockSupport和suspend+resume相比, 它不会因为resume而造成线程无法继续执行.和wait+notify相比, 它不需要先获取某个对象的锁.我觉得这个类本质上应该是用来替换suspend+resume的,因为线程挂起后并不会释放锁. 1234567891011121314151617181920212223242526import java.util.concurrent.locks.LockSupport;public class Test &#123; public static Object object = new Object(); public static class ChangeObjectThread extends Thread&#123; public ChangeObjectThread(String name) &#123; super.setName(name); &#125; @Override public void run() &#123; synchronized (object)&#123; System.out.println("in " + getName()); LockSupport.park(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new ChangeObjectThread("t1"); Thread t2 = new ChangeObjectThread("t2"); t1.start(); t2.start(); LockSupport.unpark(t1); LockSupport.unpark(t2); t1.join(); t2.join(); &#125;&#125; 2. 线程池为什么需要线程池?线程的创建和关闭需要花费时间.线程本身也是要占用内存空间.线程的回收会给GC带来压力,延长GC时间. 在实际生产环境中,线程的数量必须得到控制,盲目的大量创建线程对系统性能是有伤害的. 使用线程池后,创建线程变成了从线程池获得空闲线程,关闭线程变成了向池子归还线程. 2.1 使用线程池2.1.1 固定大小的线程池12345678910111213141516171819202122import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Test &#123; public static class MyTask implements Runnable&#123; @Override public void run() &#123; System.out.println(System.currentTimeMillis()+":Thread ID:"+Thread.currentThread().getId()); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args)&#123; MyTask myTask = new MyTask(); ExecutorService executorService = Executors.newFixedThreadPool(5); for(int i = 0; i &lt; 10; i++)&#123; executorService.submit(myTask); &#125; &#125;&#125; 2.1.2 计划任务周期性的执行任务.scheduleAtFixedRate和scheduleWithFixedDelay的区别. 如果任务遇到异常,那么后续的所有子任务都会停止调度,因此,必须保证异常被及时处理,为周期性任务的稳定调度提供条件. 123456789101112131415161718192021import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class Test &#123; public static class MyTask implements Runnable&#123; @Override public void run() &#123; System.out.println(System.currentTimeMillis()+":Thread ID:"+Thread.currentThread().getId()); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args)&#123; ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(10); scheduledExecutorService.scheduleAtFixedRate(new MyTask(), 0, 2, TimeUnit.SECONDS); scheduledExecutorService.scheduleWithFixedDelay(new MyTask(), 0, 2, TimeUnit.SECONDS); &#125;&#125; 2.1.3 核心线程池内部实现都是基于下面这个. 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); 2.1.4 拒绝策略当任务数量超过系统实际承载能力时(或者线程池规定的能力),该如何处理. 2.1.5 自定义线程创建ThreadFactory123456789101112131415161718192021222324252627282930import java.util.concurrent.*;public class Test &#123; public static class MyTask implements Runnable&#123; @Override public void run() &#123; System.out.println(System.currentTimeMillis()+":Thread ID:"+Thread.currentThread().getId()); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; MyTask myTask = new MyTask(); ExecutorService executorService = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS, new SynchronousQueue&lt;Runnable&gt;(), new ThreadFactory() &#123; @Override public Thread newThread(Runnable r) &#123; Thread t = new Thread(r); t.setDaemon(true); System.out.println("create "+t); return t; &#125; &#125;); for(int i = 0; i &lt; 5; i++)&#123; executorService.submit(myTask); &#125; Thread.sleep(2000); &#125;&#125; 2.1.6 扩展线程池1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.concurrent.*;public class Test &#123; public static class MyTask implements Runnable&#123; public String name; public MyTask(String name) &#123; this.name = name; &#125; @Override public void run() &#123; System.out.println(System.currentTimeMillis()+":Thread ID:"+Thread.currentThread().getId()); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;())&#123; @Override protected void beforeExecute(Thread t, Runnable r) &#123; System.out.println("准备执行:"+((MyTask)r).name); &#125; @Override protected void afterExecute(Runnable r, Throwable t) &#123; System.out.println("执行完成:"+((MyTask)r).name); &#125; @Override protected void terminated() &#123; System.out.println("线程池退出"); &#125; &#125;; for(int i = 0; i &lt; 5; i++)&#123; MyTask myTask = new MyTask("TASK-"+i); executorService.execute(myTask); Thread.sleep(10); &#125; executorService.shutdown(); &#125;&#125; 2.1.7 优化线程池线程数量最优的池的大小等于:Nthreads = Ncpu * Ucpu * (1 + W/C); Ncpu: CPU数量Ucpu: 目标CPU的使用率, 0~1.W/C: 等待时间与计算时间的比率 2.1.8 Fork/Join框架这是一个分而治之的框架.直接看个demo. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.ArrayList;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.concurrent.RecursiveTask;public class CountTask extends RecursiveTask&lt;Long&gt; &#123; private static final int THRESHOLD = 10000; private long start; private long end; public CountTask(long start, long end) &#123; this.start = start; this.end = end; &#125; @Override protected Long compute() &#123; long sum = 0; boolean canCompute = (end - start) &lt; THRESHOLD; if(canCompute)&#123; for(long i = start; i &lt;= end; i++)&#123; sum = sum + i; &#125; &#125;else &#123; long step = (end - start) / 100; ArrayList&lt;CountTask&gt; subTasks = new ArrayList&lt;CountTask&gt;(); long pos = start; for(int i = 0; i &lt; 100; i++)&#123; long lastOne = pos + step; if(lastOne &gt; end) lastOne = end; CountTask countTask = new CountTask(pos, lastOne); pos = lastOne + 1; subTasks.add(countTask); countTask.fork(); &#125; for(CountTask countTask : subTasks)&#123; sum += countTask.join(); &#125; &#125; return sum; &#125; public static void main(String[] args) &#123; ForkJoinPool forkJoinPool = new ForkJoinPool(); CountTask task = new CountTask(0 ,200000L); ForkJoinTask&lt;Long&gt; result = forkJoinPool.submit(task); try &#123; long res = result.get(); System.out.println("sum = "+ res); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 3. JDK的并发容器3.1 线程安全的HashMap12345// 方法一: 性能低,线程安全Map m = Collections.synchronizedMap(new HashMap&lt;&gt;())// 方法二: 性能高,线程安全ConcurrentHashMap concurrentHashMap = new ConcurrentHashMap(); 3.2 List的线程安全123456789// 线程不安全, 底层数组ArrayList arrayList = new ArrayList();// 线程安全, 底层数组Vector vector = new Vector();// 线程不安全, 底层链表LinkedList linkedList = new LinkedList();// 线程安全, 底层链表List list = Collections.synchronizedList(new LinkedList&lt;&gt;()); 3.3 高效读写的队列12// 高并发环境中性能最好的队列,线程安全.ConcurrentLinkedQueue concurrentLinkedQueue = new ConcurrentLinkedQueue(); 3.4 高效读取CopyOnWriteArrayList适用于读远大于写的场景.只有写入与写入之间需要同步等待,其他情况都不用加锁. 1CopyOnWriteArrayList copyOnWriteArrayList = new CopyOnWriteArrayList(); 3.5 数据共享通道BlockingQueue用于多线程之间的数据共享. 这是一个接口, 可以选择很多实现. 1BlockingQueue blockingQueue = new LinkedBlockingQueue(); 3.6 跳表SkipList用来快速查找的数据结构,类似于平衡树. 与平衡树的区别在于: 对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整.而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可. 这样做的好处在于: 在高并发的情况下,你会需要一个全局锁来保证整个平衡树的线程安全.而对于跳表,你只需要部分锁即可,从而拥有更好的性能. 就查询性能来说, 跳表的时间复杂度也是O(log n),所以在并发数据结构中,使用跳表来实现Map. 1ConcurrentSkipListMap concurrentSkipListMap = new ConcurrentSkipListMap(); 4. 参考文献&lt;&lt; Java高并发程序设计 &gt;&gt;(葛一鸣 郭超)]]></content>
      <categories>
        <category>高并发程序设计</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
        <tag>并发设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java错误的加锁实例]]></title>
    <url>%2F2019%2F02%2F22%2FJava%20%E9%94%99%E8%AF%AF%E7%9A%84%E5%8A%A0%E9%94%81%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1. 前言在学习 &lt;&lt; Java高并发程序设计 &gt;&gt;(葛一鸣 郭超) 的时候看到一个错误的加锁实例. 第一时间没有反应出来错误在哪, 在这里记录一下, 以后万一遇到了也容易解决. 2. 错误实例123456789101112131415161718192021222324public class Test &#123; public static class Demo extends Thread&#123; public static Integer i = 0; @Override public void run() &#123; for(int j = 0; j &lt; 100000; j++)&#123; synchronized (i)&#123; i++; &#125; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Demo(); Thread t2 = new Demo(); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(Demo.i); &#125;&#125; 输入结果并不是 200000, 而是比 200000 小. 3. 问题分析问题出在Integer变量i. 直接上源码就明白了. 1234567//* This method will always cache values in the range -128 to 127,//* inclusive, and may cache other values outside of this range.public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 4. 参考链接&lt;&lt; Java高并发程序设计 &gt;&gt;(葛一鸣 郭超)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高并发程序设计(二)--Java并行程序基础]]></title>
    <url>%2F2019%2F02%2F22%2FJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E4%BA%8C)--Java%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. 线程的状态 123456789// Thread中定义的Statepublic enum State &#123; NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED;&#125; 2. 线程的操作2.1 新建线程1234567// 新建线程Thread t1 = new Thread();t1.start();//错误的做法Thread t1 = new Thread();t1.run(); t1.run()只是调用了run方法,并不是新建线程. 2.2 终止线程12345678910111213141516171819// 不推荐的做法t1.stop();// 推荐的做法volatile boolean stopme = false;public void stopMe()&#123; stopme = true;&#125;@Overridepublic void run()&#123; while(true)&#123; if(stopme == true)&#123; System.out.printf("bye bye"); break; &#125; // do something &#125;&#125; 使用stop容易造成数据不一致. 2.3 线程中断线程中断不会使线程立即退出,而是给线程发送一个通知,告知目标线程,有人希望你退出了.至于目标线程接到通知后如何处理,则完全由目标线程自行决定. 1234567891011121314151617181920public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(new Thread()&#123; @Override public void run()&#123; while (true)&#123; if(Thread.currentThread().isInterrupted())&#123; System.out.println("Interrupted"); break; &#125; Thread.yield(); System.out.println("working"); &#125; &#125; &#125;); t1.start(); Thread.sleep(2000); t1.interrupt(); &#125;&#125; 2.4 线程等待和线程通知12345678910111213141516171819202122232425262728293031323334public class Test &#123; public static void main(String[] args) &#123; Thread t1 = new T1(); Thread t2 = new T2(); t1.start(); t2.start(); &#125; final static Object object = new Object(); public static class T1 extends Thread&#123; @Override public void run() &#123; synchronized (object)&#123; System.out.println(System.currentTimeMillis()+":T1 start!"); System.out.println(System.currentTimeMillis()+":T1 wait!"); try &#123; object.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(System.currentTimeMillis()+":T1 end!"); &#125; &#125; &#125; public static class T2 extends Thread&#123; @Override public void run() &#123; synchronized (object)&#123; System.out.println(System.currentTimeMillis()+":T2 start! notify T1."); object.notify(); System.out.println(System.currentTimeMillis()+":T2 end!"); &#125; &#125; &#125;&#125; wait方法不是可以随便调用,必须在对应的同步代码块里,wait或者notify都需要先获得目标对象的监视器.线程执行wait方法前必须先获得对应Object的监视器,wait方法执行后会释放监视器,这时其他线程就可以获取这个Object的监视器了.这就实现了线程间通信. wait和sleep都是让线程等待.wait会释放目标对象锁,sleep不会释放任何资源. 2.5 挂起线程和继续执行线程suspend和resume是一对相关的操作,也已经废弃了,不推荐使用. suspend挂起线程后不会释放任何资源,其他等待被占用资源的线程都无法执行,使用不当会导致所有相关线程都无法运行. suspend挂起线程后,线程还是Runnable状态,影响问题分析. 相关需求可以用wait和notify来实现, 下面是例子. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Test &#123; public static Object u = new Object(); public static class ChangeObjectThread extends Thread&#123; volatile boolean suspendme = false; public void suspendMe()&#123; suspendme = true; &#125; public void resumeMe()&#123; suspendme = false; synchronized (this)&#123; notify(); &#125; &#125; @Override public void run() &#123; while (true)&#123; synchronized (this)&#123; while (suspendme)&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; synchronized (u)&#123; System.out.println("in ChangeObjectThread"); &#125; Thread.yield(); &#125; &#125; &#125; public static class ReadObjectThread extends Thread&#123; @Override public void run() &#123; while (true)&#123; synchronized (u)&#123; System.out.println("in ReadObjectThread"); &#125; Thread.yield(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; ChangeObjectThread t1 = new ChangeObjectThread(); ReadObjectThread t2 = new ReadObjectThread(); t1.start(); t2.start(); Thread.sleep(2000); t1.suspendMe(); System.out.println("suspend t1 2 s"); Thread.sleep(2000); System.out.println("resume t1"); t1.resumeMe(); &#125;&#125; 2.6 等待线程结束和谦让等待线程结束(join), 谦让(yield) join方法会阻塞当前线程,直到目标线程执行结束.本质就是让当前线程wait()在目标线程对象上,目标线程执行完成后会调用notifyAll通知所有等待线程继续执行. 1234567891011121314151617181920public class Test &#123; public volatile static int i = 0; public static class AddThread extends Thread&#123; @Override public void run() &#123; for(i = 0; i &lt; 10000000; i++)&#123; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; AddThread addThread = new AddThread(); addThread.start(); addThread.join(); System.out.println(i); &#125;&#125; Thread.yield()方法会让当前线程让出CPU,不过让出后还会进行CPU资源的争夺,能否再次分配到就看系统了. 3. 线程组用来管理线程. 建议在创建线程和线程组的时候,取一个好听的名字. 下个给个例子,了解一下有这么回事. 123456789101112131415161718192021222324252627public class Test &#123; public static void main(String[] args)&#123; ThreadGroup tg = new ThreadGroup("PrintGroup"); Thread thread1 = new Thread(tg, new Service(), "T1"); Thread thread2 = new Thread(tg, new Service(), "T2"); thread1.start(); thread2.start(); System.out.println(tg.activeCount()); tg.list(); &#125; public static class Service extends Thread&#123; @Override public void run() &#123; String groupAndName = Thread.currentThread().getThreadGroup().getName() + "-" + Thread.currentThread().getName(); while (true)&#123; System.out.println("I am "+ groupAndName); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 4. 守护线程守护线程是一种特殊的线程,就和它的名字一样,它是系统的守护者,在后台默默完成一些系统性的服务.当一个Java应用内只有守护线程时,Java虚拟机就会自然退出. 12345678910111213141516public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new DaemonDemo(); thread.setDaemon(true); thread.start(); Thread.sleep(2000); &#125; public static class DaemonDemo extends Thread&#123; @Override public void run() &#123; while(true)&#123; System.out.println("I am alive."); &#125; &#125; &#125;&#125; 5. 线程优先级直接看例子. 注意: 高优先级也可能抢占失败,这只是一个概率问题. 123456789101112131415161718192021222324252627282930313233343536373839404142public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new HighPriority(); Thread t2 = new LowPriority(); t1.setPriority(Thread.MAX_PRIORITY); t2.setPriority(Thread.MIN_PRIORITY); t2.start(); t1.start(); &#125; public static class HighPriority extends Thread&#123; int count = 0; @Override public void run() &#123; while (true)&#123; synchronized (Test.class)&#123; count++; if(count &gt; 10000000)&#123; System.out.println("HighPriority is completed"); break; &#125; &#125; &#125; &#125; &#125; public static class LowPriority extends Thread&#123; int count = 0; @Override public void run() &#123; while (true)&#123; synchronized (Test.class)&#123; count++; if(count &gt; 10000000)&#123; System.out.println("LowPriority is completed"); break; &#125; &#125; &#125; &#125; &#125;&#125; 6. 参考链接&lt;&lt; Java高并发程序设计 &gt;&gt;(葛一鸣 郭超) Java高并发程序设计]]></content>
      <categories>
        <category>高并发程序设计</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
        <tag>并发设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高并发程序设计(一)--走入并行世界]]></title>
    <url>%2F2019%2F02%2F20%2FJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E4%B8%80)--%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[1. 前言这部分主要记录几个概念. 2. 临界区临界区用来表示一种公共资源或者说是共享数据,可以被多个线程使用.但是每一次,只能有一个线程使用它,一旦临界区资源被占用,其他线程想要使用这个资源,就必须等待. 比如打印机. 在并行程序中,临界区资源是保护的对象. 3. 阻塞和非阻塞阻塞(Blocking)非阻塞(Non-Blocking) 阻塞和非阻塞通常用来形容多线程间的相互影响.比如一个线程占用了临界区资源,那么其他所有需要这个资源的线程就必须在这个临界区中进行等待.等待会导致线程挂起,这种情况就是阻塞.此时,如果占用资源的线程一直不愿意释放资源,那么其他所有阻塞在这个临界区上的线程都不能工作. 非阻塞的意思与之相反,它强调没有一个线程可以妨碍其他线程执行.所有的线程都会尝试不断前向执行. 4. 死锁,饥饿和活锁死锁(Deadlock)饥饿(Starvation)活锁(Livelock) 都属于多线程的活跃性问题.如果发生上述情况,那么相关线程可能不再活跃. 死锁:彼此占有对方需要的资源,都不释放;饥饿:线程因种种原因无法获取所需资源,一直无法执行(比如线程优先级可能太低,而高优先级的线程不断抢占它需要的资源,导致低优先级线程无法工作.再比如某一个线程一直占着关键资源不放,导致其他需要这个资源的线程无法正常执行);活锁:彼此占有对方需要的资源,都主动释放,但是没有一个线程同时拿到所有资源而正常执行,出现资源不断在两个线程之间跳动. 5. 两个重要定律5.1 Amdahl定律(阿姆达尔定律)阿姆达尔定律是计算机并行重要的定律. 定义了串行系统并行化后的加速比的计算公式和理论上限. 加速比 = 优化之前系统耗时 / 优化后系统耗时 假设有n个处理器,t1表示优化前耗时,tn表示经过n个处理器优化后的耗时,f是程序中只能串行执行的比例. 我们可以分析出, 串行比例越低且处理器越多,加速比越高,程序优化效率越高. 如果串行比例占2/3,则无论处理器再多,最大加速比也只能达到1.5. 理想效果是,全部并行,最大加速比为 n.可以根据增加处理器无上限增强程序效率. 5.2 Gustafson定律(古斯塔夫森定律)古斯塔夫森定律也是在表明处理器个数,并行比例和加速比之间的关系. 执行时间: 串行时间a + 并行时间b优化后时间： a + nb加速比： (a + nb) / (a + b)f串行比例 ： a / (a + b) 如果串行比例很小,那个加速比就是处理器的个数. 6. JMMJava内存模型(JMM) 6.1 原子性(Atomicity)原子性是指一个操作是不可中断的.即使是在多个线程一起执行的时候,一个操作一旦开始,就不会被其他线程干扰. 6.2 可见性(Visibility)可见性是指当一个线程修改了某一个共享变量的值,其他线程是否能够立即知道这个修改. 6.3 有序性(Ordering)指令重排保证串行语义一致,但无法保证多线程间语义一致. 指令重排是出于性能考虑(流水线技术). 7. 参考文献&lt;&lt; Java高并发程序设计 &gt;&gt;(葛一鸣 郭超)]]></content>
      <categories>
        <category>高并发程序设计</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
        <tag>并发设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java RMI]]></title>
    <url>%2F2019%2F02%2F20%2FJava%20RMI%2F</url>
    <content type="text"><![CDATA[1. 基本使用1.1 服务端1.首先我们先创建一个实体类,这个类需要实现Serializable接口,用于信息的传输. 1234567891011121314151617import java.io.Serializable;public class Student implements Serializable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 2.定义一个接口,这个接口需要继承Remote接口,这个接口中的方法必须声明RemoteException异常. 123456import java.rmi.Remote;import java.rmi.RemoteException;import java.util.List;public interface StudentService extends Remote &#123; List&lt;Student&gt; getList() throws RemoteException;&#125; 3.创建一个类,并实现步骤2中的接口,但还需要继承UnicastRemoteObject类和显示写出无参的构造函数. 123456789101112131415161718192021import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;import java.util.ArrayList;import java.util.List; public class StudentServiceImpl extends UnicastRemoteObject implements StudentService &#123; public StudentServiceImpl() throws RemoteException &#123; &#125; public List&lt;Student&gt; getList() throws RemoteException &#123; List&lt;Student&gt; list=new ArrayList&lt;Student&gt;(); Student s1=new Student(); s1.setName("张三"); s1.setAge(15); Student s2=new Student(); s2.setName("李四"); s2.setAge(20); list.add(s1); list.add(s2); return list; &#125;&#125; 4.创建服务并启动服务 1234567891011121314import java.rmi.Naming;import java.rmi.registry.LocateRegistry;public class SetService &#123; public static void main(String[] args) &#123; try &#123; StudentService studentService=new StudentServiceImpl(); LocateRegistry.createRegistry(5008);//定义端口号 Naming.rebind("rmi://127.0.0.1:5008/StudentService", studentService); System.out.println("服务已启动"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1.2 客户端1.首先我们先创建一个实体类,这个类需要实现Serializable接口,用于信息的传输. 2.定义一个接口,这个接口需要继承Remote接口,这个接口中的方法必须声明RemoteException异常. 上面两步与服务端的操作一致. 3.创建一个客户程序进行RMI调用. 123456789101112131415import java.rmi.Naming;import java.util.List;public class GetService &#123; public static void main(String[] args) &#123; try &#123; StudentService studentService=(StudentService) Naming.lookup("rmi://127.0.0.1:5008/StudentService"); List&lt;Student&gt; list = studentService.getList(); for (Student s : list) &#123; System.out.println("姓名："+s.getName()+",年龄："+s.getAge()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1.3 调用发生ClassCastException的处理方法主要原因:是服务器端的包结构和客户端的包结构不同,这就造成了实际上你的服务器端的Interface的名字和你客户端的Interface名称不同,所以当然会造成转型异常了. 解决方法:把自己客户端涉及到RMI部分调整和服务器端完全一致.可能你的系统客户端包为com.xxx.client,而服务器端的包为com.xxx.server.你只需要将服务器端和客户端的包都改成同一个包名即可.例如都改成com.xxx.rmi. 2. 定义和基本认识Java RMI: Java远程方法调用,即Java RMI(Java Remote Method Invocation)是Java编程语言里,一种用于实现远程过程调用的应用程序编程接口.它使客户机上运行的程序可以调用远程服务器上的对象.远程方法调用特性使Java编程人员能够在网络环境中分布操作.RMI全部的宗旨就是尽可能简化远程接口对象的使用. RMI(Remote Method Invocation)为远程方法调用,是允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上的对象的方法. 这两个虚拟机可以是运行在相同计算机上的不同进程中,也可以是运行在网络上的不同计算机中. RMI能让一个Java程序去调用网络中另一台计算机的Java对象的方法,那么调用的效果就像是在本机上调用一样.通俗的讲:A机器上面有一个class, 通过远程调用, B机器调用这个class 中的方法. RMI的基础是接口,RMI构架基于一个重要的原理:定义接口和定义接口的具体实现是分开的. 3. 参考链接Java学习之路-RMI学习Java学习笔记（十六）——Java RMIJava RMI调用发生ClassCastException的处理方法]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之MVC模式]]></title>
    <url>%2F2019%2F02%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BMVC%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 什么是MVC模式MVC 模式代表 Model-View-Controller(模型-视图-控制器)模式. 这种模式用于应用程序的分层开发. Model(模型) - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。View(视图) - 视图代表模型包含的数据的可视化。Controller(控制器) - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。 2. 示例UML图 3. 示例代码地址https://github.com/ganlu19940318/Head-First/tree/master/Model-View-Controller 4. 参考链接&lt;&lt; Head First 设计模式 &gt;&gt;MVC 模式|菜鸟教程]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之代理模式]]></title>
    <url>%2F2019%2F02%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 什么是代理模式代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问. 通过代理模式,创建代表对象,让代表对象控制某对象的访问,被代理的对象可以是远程的对象,创建开销大的对象或需要安全控制的对象. 2. 示例UML图 3. 示例代码地址https://github.com/ganlu19940318/Head-First/tree/master/Proxy%20Pattern 4. 参考链接&lt;&lt; Head First 设计模式 &gt;&gt;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之状态模式]]></title>
    <url>%2F2019%2F02%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 什么是状态模式状态模式允许对象在内部状态改变时改变它的行为,对象看起来好像修改了它的类. 2. 示例UML图 3. 示例代码地址https://github.com/ganlu19940318/Head-First/tree/master/State%20Pattern 4. 参考链接&lt;&lt; Head First 设计模式 &gt;&gt;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之组合模式]]></title>
    <url>%2F2019%2F02%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 什么是组合模式组合模式允许你将对象组合成树形结构来表现”整体/部分”层次结构.组合能让客户以一致的方式处理个别对象以及对象组合. 2. 示例UML图 3. 示例代码地址https://github.com/ganlu19940318/Head-First/tree/master/Composite%20Pattern 4. 参考链接&lt;&lt; Head First 设计模式 &gt;&gt;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之迭代器模式]]></title>
    <url>%2F2019%2F02%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 什么是迭代器模式迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素,而又不暴露其内部的表示. 2. 示例UML图 3. 示例代码地址https://github.com/ganlu19940318/Head-First/tree/master/Iterator%20Pattern 4. 参考链接&lt;&lt; Head First 设计模式 &gt;&gt;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之模板方法模式]]></title>
    <url>%2F2019%2F02%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 什么是模板方法模式模板方法模式在一个方法中定义一个算法的骨架,而将一些步骤延迟到子类中.模板方法使得子类可以在不改变算法结构的情况下,重新定义算法中的某些步骤. 我觉得 模板方法模式 与 工厂方法模式or抽象工厂模式or策略模式 的区别在于模板方法, 就是说, 父类中是否存在一个方法里面定义有一系列步骤,并且这些步骤的实现将在子类中. 2. 示例UML图 3. 示例代码地址https://github.com/ganlu19940318/Head-First/tree/master/Template%20Pattern 4. 参考链接&lt;&lt; Head First 设计模式 &gt;&gt;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之外观模式]]></title>
    <url>%2F2019%2F02%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 什么是外观模式外观模式提供了一个统一的接口,用来访问子系统中的一群接口.外观定义了一个高层接口,让子系统更容易使用. 2. 示例UML图 3. 示例代码地址https://github.com/ganlu19940318/Head-First/tree/master/Facade%20Pattern 4. 参考链接&lt;&lt; Head First 设计模式 &gt;&gt;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之适配器模式]]></title>
    <url>%2F2019%2F02%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 什么是适配器模式适配器模式将一个类的接口, 转换成客户期望的另一个接口. 适配器让原本接口不兼容的类可以合作无间. 2. 示例UML图 3. 示例代码地址https://github.com/ganlu19940318/Head-First/tree/master/Adapter%20Pattern 4. 参考链接&lt;&lt; Head First 设计模式 &gt;&gt;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之命令模式]]></title>
    <url>%2F2019%2F02%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 什么是命令模式命令模式将”请求”封装成对象,以便使用不同的请求,队列或者日志来参数化其他对象.命令模式也支持可撤销操作. 我觉得命令模式就是把 操作的调用者 与 操作的执行者 解耦. 2. 示例UML图 3. 示例代码地址https://github.com/ganlu19940318/Head-First/tree/master/Command%20Pattern 4. 参考链接&lt;&lt; Head First 设计模式 &gt;&gt;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F2018%2F11%2F29%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 什么是单例模式确保一个类只有一个实例,并提供全局访问点. 2. 示例代码3种单例模式代码. 12345678910111213141516// 方法一// 只有在类被使用的时候才会实例化, 每次getInstance都会产生大量额外开销, 所以getInstance的性能很差.public class SingletonOne &#123; private static SingletonOne uniqueInstance; private SingletonOne()&#123; &#125; public static synchronized SingletonOne getInstance()&#123; if(uniqueInstance == null)&#123; uniqueInstance = new SingletonOne(); &#125; return uniqueInstance; &#125;&#125; 123456789101112// 方法二// 在类被使用之前就创建好了实例, 其实我觉得, 一般情况下用这种就可以了.public class SingletonTwo &#123; private static SingletonTwo uniqueInstance = new SingletonTwo(); private SingletonTwo() &#123; &#125; public static SingletonTwo getInstance()&#123; return uniqueInstance; &#125;&#125; 12345678910111213141516171819// 方法三// 只有在类被使用的时候才会实例化, 每次getInstance都会产生非常小的额外开销(判断逻辑), 但是相对于方法一, 开销已经小很多了.public class SingletonThree &#123; private volatile static SingletonThree uniqueInstance; private SingletonThree() &#123; &#125; public static SingletonThree getInstance()&#123; if(uniqueInstance == null)&#123; synchronized (SingletonThree.class)&#123; if(uniqueInstance == null)&#123; uniqueInstance = new SingletonThree(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; 3. 参考链接&lt;&lt; Head First 设计模式 &gt;&gt;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之抽象工厂模式]]></title>
    <url>%2F2018%2F11%2F29%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 什么是抽象工厂模式提供一个接口, 用于创建相关或依赖对象的家族, 而不需要明确指定具体类. 其实我觉得, 工厂方法模式与抽象工厂模式, 都是负责创建对象的, 但是它们的本质区别在于, 工厂方法模式是通过继承实现的, 而抽象工厂模式是通过组合实现的. 2. 示例UML图 3. 示例代码地址https://github.com/ganlu19940318/Head-First/tree/master/Factory%20Pattern/Abstract%20Factory%20Pattern 4. 参考链接&lt;&lt; Head First 设计模式 &gt;&gt;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂方法模式]]></title>
    <url>%2F2018%2F11%2F29%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 什么是工厂方法模式定义了一个创建对象的接口,但由子类决定要实例化的类是哪一个,工厂方法让类把实例化推迟到子类. 2. 示例UML图 3. 示例代码地址https://github.com/ganlu19940318/Head-First/tree/master/Factory%20Pattern/Factory%20Method%20Pattern 4. 参考链接&lt;&lt; Head First 设计模式 &gt;&gt;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之装饰者模式]]></title>
    <url>%2F2018%2F11%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 什么是装饰者模式动态地将责任附加到对象上, 想要扩展功能, 装饰者提供有别于继承的另一种选择. 2. 示例UML图 3. 示例代码地址https://github.com/ganlu19940318/Head-First/tree/master/Decorator%20Pattern 4. 参考链接&lt;&lt; Head First 设计模式 &gt;&gt;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之观察者模式]]></title>
    <url>%2F2018%2F11%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 什么是观察者在对象之间定义一对多的依赖,这样一来,当一个对象改变状态,依赖它的对象都会收到通知,并自动更新. 2. 示例UML图 3. 示例代码地址https://github.com/ganlu19940318/Head-First/tree/master/Observer%20Pattern 4. 参考链接&lt;&lt; Head First 设计模式 &gt;&gt;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之策略模式]]></title>
    <url>%2F2018%2F11%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 什么是策略模式策略模式定义了算法族, 分别封装起来, 让它们之间可以互相替换, 此模式让算法的变化独立于使用算法的客户. 2. 示例UML图 3. 示例代码地址https://github.com/ganlu19940318/Head-First/tree/master/Strategy%20Pattern 4. 参考链接&lt;&lt; Head First 设计模式 &gt;&gt;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud微服务(八)--消息总线Spring Cloud Bus]]></title>
    <url>%2F2018%2F11%2F26%2FSpring%20Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1(%E5%85%AB)--%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BFSpring%20Cloud%20Bus%2F</url>
    <content type="text"><![CDATA[1. 前言本文是 &lt;&lt; Spring Cloud微服务实战 &gt;&gt; 学习笔记, 以便自己查阅. 2. 概述在微服务架构的系统中,我们通常会使用轻量级的消息代理来构建一个共用的消息主题让系统中所有微服务实例都连接上来,由于该主题中产生的消息会被所有实例监听和消费,所以我们称它为消息总线. Spring Cloud Bus本质上就是对消息代理的封装. 目前只支持RabbitMQ和Kafka. 3. 消息代理消息代理(Message Broker)是一种消息验证,传输,路由的架构模式.它在应用程序之间起到通信调度并最小化应用之间的依赖的作用,使得应用程序可以高效地解耦通信过程.消息代理是一个中间件产品,它的核心是一个消息的路由程序,用来实现接收和分发消息,并根据设定好的消息处理流来转发给正确的应用.它包括独立的通信和消息传递协议,能够实现组织内部和组织间的网络通信.设计代理的目的就是为了能够从应用程序中传入消息,并执行一些特别的操作,下面这些是在企业应用中,我们经常需要使用消息代理的场景: 将消息路由到一个或多个目的地. 消息转化为其他的表现方式. 执行消息的聚集,消息的分解,并将结果发送到它们的目的地,然后重新组合响应返回给消息用户. 调用Web服务来检索数据. 响应事件或错误. 使用发布－订阅模式来提供内容或基千主题的消息路由. 目前已经有非常多的开源产品可以供大家使用,比如: ActiveMQ, Kafka, RabbitMQ, RocketMQ等 4. 经典示例应用4.1 传统架构 通过这个架构, 实现了Git仓库配置更新的同时, 各个Service的配置也跟着更新. 4.2 架构调整既然SpringCloud Bus的/bus/refresh接口提供了针对服务和实例进行配置更新的参数,那么我们的架构也可以相应做出一些调整.在之前的架构中,服务的配置更新需要通过向具体服务中的某个实例发送请求,再触发对整个服务集群的配置更新.虽然能实现功能,但是这样的结果是,我们指定的应用实例会不同千集群中的其他应用实例,这样会增加集群内部的复杂度,不利于将来的运维工作.比如,需要对服务实例进行迁移,那么我们不得不修改Web Hook中的配置等.所以要尽可能地让服务集群中的各个节点是对等的. 因此,我们将之前的架构做了 一些调整,如下图所示: 5. 参考链接&lt;&lt; Spring Cloud微服务实战 &gt;&gt;SpringCloud之消息总线Spring Cloud Bus实例]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud微服务(七)--分布式配置中心Spring Cloud Config]]></title>
    <url>%2F2018%2F11%2F26%2FSpring%20Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1(%E4%B8%83)--%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83Spring%20Cloud%20Config%2F</url>
    <content type="text"><![CDATA[1. 前言本文是 &lt;&lt; Spring Cloud微服务实战 &gt;&gt; 学习笔记, 以便自己查阅. 2. 概述Spring Cloud Config是Spring Cloud团队创建的一个全新项目,用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持,它分为服务端与客户端两个部分. 其中服务端也称为分布式配置中心,它是一个独立的微服务应用,用来连接配置仓库并为客户端提供获取配置信息,加密/解密信息等访问接口; 而客户端则是微服务架构中的各个微服务应用或基础设施,它们通过指定的配置中心来管理应用资源与业务相关的配置内容,并在启动的时候从配置中心获取和加载配置信息. Spring Cloud Config实现了对服务端和客户端中环境变量和属性配置的抽象映射,所以它除了适用于Spring构建的应用程序之外,也可以在任何其他语言运行的应用程序中使用.由于Spring Cloud Config实现的配置中心默认采用Git来存储配置信息,所以使用Spring Cloud Config构建的配置服务器,天然就支持对微服务应用配置信息的版本管理,并且可以通过Git客户端工具来方便的管理和访问配置内容.当然它也提供了对其他存储方式的支持,比如:SVN仓库,本地化文件系统. 3. 服务端详解 客户端应用从配置管理中获取配置信息遵从下面的执行流程: 应用启动时,根据bootstrap.properties中配置的应用名(application},环境名(profile},分支名(label},向Config Server请求获取配置信息. Config Server根据自己维护的Git仓库信息和客户端传递过来的配置定位信息去查找配置信息. 通过git clone命令将找到的配置信息下载到Config Server的文件系统中. Config Server创建Spring的ApplicationContext实例,并从Git本地仓库中加载配置文件,最后将这些配置内容读取出来返回给客户端应用. 客户端应用在获得外部配置文件后加载到客户端的ApplicationContext实例,该配置内容的优先级高于客户端Jar包内部的配置内容,所以在Jar包中重复的内容将不再被加载. 4. 高可用问题4.1 传统作法通常在生产环境,Config Server与服务注册中心一样,我们也需要将其扩展为高可用的集群.在之前实现的config-server基础上来实现高可用非常简单,不需要我们为这些服务端做任何额外的配置,只需要遵守一个配置规则:将所有的Config Server都指向同一个Git仓库,这样所有的配置内容就通过统一的共享文件系统来维护,而客户端在指定Config Server位置时,只要配置Config Server外的均衡负载即可,就像如下图所示的结构: 4.2 注册为服务虽然通过服务端负载均衡已经能够实现,但是作为架构内的配置管理,本身其实也是可以看作架构中的一个微服务.所以,另外一种方式更为简单的方法就是把config-server也注册为服务,这样所有客户端就能以服务的方式进行访问.通过这种方法,只需要启动多个指向同一Git仓库位置的config-server就能实现高可用了. 5. 参考链接&lt;&lt; Spring Cloud微服务实战 &gt;&gt;Spring Cloud Config 服务端详解Spring Cloud构建微服务架构（四）分布式配置中心（续）]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud微服务(六)--API网关服务Spring Cloud Zuul]]></title>
    <url>%2F2018%2F11%2F26%2FSpring%20Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1(%E5%85%AD)--API%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1Spring%20Cloud%20Zuul%2F</url>
    <content type="text"><![CDATA[1. 前言本文是 &lt;&lt; Spring Cloud微服务实战 &gt;&gt; 学习笔记, 以便自己查阅. 2. 概述 我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现;而服务间通过Ribbon或Feign实现服务的消费以及均衡负载;通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理.为了使得服务集群更为健壮,使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延. 在该架构中,我们的服务集群包含:内部服务Service A和Service B,他们都会注册与订阅服务至Eureka Server,而Open Service是一个对外的服务,通过均衡负载公开至服务调用方.本文我们把焦点聚集在对外服务这块,这样的实现是否合理,或者是否有更好的实现方式呢? 先来说说这样架构需要做的一些事儿以及存在的不足: 首先,破坏了服务无状态特点.为了保证对外服务的安全性,我们需要实现对服务访问的权限控制,而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑,这会带来的最直接问题是,破坏了服务集群中REST API无状态的特点.从具体开发和测试的角度来说,在工作中除了要考虑实际的业务逻辑之外,还需要额外可续对接口访问的控制处理. 其次,无法直接复用既有接口.当我们需要对一个即有的集群内访问接口,实现外部服务访问时,我们不得不通过在原有接口上增加校验逻辑,或增加一个代理调用来实现权限控制,无法直接复用原有的接口. 面对类似上面的问题,我们要如何解决呢?下面进入本文的正题:服务网关! 为了解决上面这些问题,我们需要将权限控制这样的东西从我们的服务单元中抽离出去,而最适合这些逻辑的地方就是处于对外访问最前端的地方,我们需要一个更强大一些的均衡负载器,它就是本文将来介绍的:服务网关. 服务网关是微服务架构中一个不可或缺的部分.通过服务网关统一向外系统提供REST API的过程中,除了具备服务路由,均衡负载功能之外,它还具备了权限控制等功能.Spring Cloud Netflix中的Zuul就担任了这样的一个角色,为微服务架构提供了前门保护的作用,同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面,使得服务集群主体能够具备更高的可复用性和可测试性. 3. 参考链接&lt;&lt; Spring Cloud微服务实战 &gt;&gt;Spring Cloud构建微服务架构（五）服务网关]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud微服务(五)--声明式服务调用Spring Cloud Feign]]></title>
    <url>%2F2018%2F11%2F25%2FSpring%20Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1(%E4%BA%94)--%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8Spring%20Cloud%20Feign%2F</url>
    <content type="text"><![CDATA[1. 前言本文是 &lt;&lt; Spring Cloud微服务实战 &gt;&gt; 学习笔记, 以便自己查阅. 2. 概述Spring Cloud Feign是一套基于Netflix Feign实现的声明式服务调用客户端. 它使得编写Web服务客户端变得更加简单. 我们只需要通过创建接口并用注解来配置它既可完成对Web服务接口的绑定. 它具备可插拔的注解支持, 包括Feign注解, JAX-RS注解. 它也支持可插拔的编码器和解码器. Spring Cloud Feign还扩展了对Spring MVC注解的支持, 同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现, 说白了, Spring Cloud Feign = Spring Cloud Ribbon + Spring Cloud Hystrix + 其他扩展. 3. 示例个人觉得, Spring Cloud Feign最大的优点就是简化了服务调用的代码, 传统的服务调用, 需要通过RestTemplate操作, 无论是入参构造还是返回值的解析, 都是繁琐的重复过程, 而Spring Cloud Feign简化了这个过程. 示例代码引自网络. 3.1 引入依赖1234567&lt;dependencies&gt; ... &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.2 修改主类12345678@EnableFeignClients@EnableDiscoveryClient@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 3.3 创建Feign客户端123456@FeignClient("eureka-client")public interface DcClient &#123; @GetMapping("/dc") String consumer();&#125; 3.4 服务调用123456789101112@RestControllerpublic class DcController &#123; @Autowired DcClient dcClient; @GetMapping("/consumer") public String dc() &#123; return dcClient.consumer(); &#125;&#125; 4. 参考链接&lt;&lt; Spring Cloud微服务实战 &gt;&gt;Spring Cloud构建微服务架构：服务消费（Feign）【Dalston版】]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud微服务(四)--服务容错保护Spring Cloud Hystrix]]></title>
    <url>%2F2018%2F11%2F25%2FSpring%20Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1(%E5%9B%9B)--%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4Spring%20Cloud%20Hystrix%2F</url>
    <content type="text"><![CDATA[1. 前言本文是 &lt;&lt; Spring Cloud微服务实战 &gt;&gt; 学习笔记, 以便自己查阅. 2. 概述在微服务架构中,我们将系统拆分为很多个服务,各个服务之间通过注册与订阅的方式相互依赖,由于各个服务都是在各自的进程中运行,就有可能由于网络原因或者服务自身的问题导致调用故障或延迟,随着服务的积压,可能会导致服务崩溃.为了解决这一系列的问题,断路器等一系列服务保护机制出现了. 断路器本身是一种开关保护机制,用于在电路上保护线路过载,当线路中有电器发生短路时,断路器能够及时切断故障电路,防止发生过载,发热甚至起火等严重后果. 在分布式架构中,断路器模式的作用也是类似的. 针对上述问题,Spring Cloud Hystrix 实现了断路器,线路隔离等一系列服务保护功能.它也是基于 Netflix 的开源框架 Hystrix 实现的,该框架的目标在于通过控制那些访问远程系统,服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力.Hystrix 具备服务降级,服务熔断,线程和信号隔离,请求缓存,请求合并以及服务监控等强大功能. 3. 原理分析3.1 工作流程 3.1.1 构建一个HystrixCommand或者HystrixObservableCommand对象第一步就是构建一个HystrixCommand或者HystrixObservableCommand对象,该对象将代表你的一个依赖请求,向构造函数中传入请求依赖所需要的参数.如果构建HystrixCommand中的依赖返回单个响应,例如: 1HystrixCommand command = new HystrixCommand(arg1, arg2); 如果依赖需要返回一个Observable来发射响应, 就需要通过构建HystrixObservableCommand对象来完成,例如: 1HystrixObservableCommand command = new HystrixObservableCommand(arg1, arg2); 3.1.2 执行命令有4种方式可以执行一个Hystrix命令.execute()-该方法是阻塞的,从依赖请求中接收到单个响应(或者出错时抛出异常).queue()-从依赖请求中返回一个包含单个响应的Future对象.observe()-订阅一个从依赖请求中返回的代表响应的Observable对象.toObservable()-返回一个Observable对象,只有当你订阅它时,它才会执行Hystrix命令并发射响应. 1234K value = command.execute();Future&lt;K&gt; fValue = command.queue();Observable&lt;K&gt; ohValue = command.observe(); //hot observableObservable&lt;K&gt; ocValue = command.toObservable(); //cold observable 同步调用方法execute()实际上就是调用queue().get()方法,queue()方法的调用的是toObservable().toBlocking().toFuture().也就是说,最终每一个HystrixCommand都是通过Observable来实现的,即使这些命令仅仅是返回一个简单的单个值. 3.1.3 响应是否被缓存如果这个命令的请求缓存已经开启,并且本次请求的响应已经存在于缓存中,那么就会立即返回一个包含缓存响应的Observable. 3.1.4 断路器是否打开当命令执行执行时,Hystrix会检查断路器是否被打开.如果断路器被打开,那么Hystrix就不会再执行命名,而是直接路由到第8步,获取fallback方法,并执行fallback逻辑.如果断路器关闭,那么将进入第5步,检查是否有足够的容量来执行任务.(其中容量包括线程池的容量,队列的容量等等). 3.1.5 线程池,队列,信号量是否已满如果与该命令相关的线程池或者队列已经满了,那么Hystrix就不会再执行命令,而是立即跳到第8步,执行fallback逻辑. 3.1.6 HystrixObservableCommand.construct() 或者 HystrixCommand.run()在这里,Hystrix通过你写的方法逻辑来调用对依赖的请求,通过下列之一的调用: HystrixCommand.run()-返回单个响应或者抛出异常. HystrixObservableCommand.construct()-返回一个发射响应的Observable或者发送一个onError()的通知。. 如果执行run()方法或者construct()方法的执行时间大于命令所设置的超时时间值,那么该线程将会抛出一个TimeoutException异常(如果该命令没有运行在它自己的线程中,则会通过单独的计时线程来抛出),在这种情况下,Hystrix将会路由到第8步,执行fallback逻辑,并且如果run()或者construct()方法没有被取消或者中断,会丢弃这两个方法最终返回的结果. 如果命令最终返回了响应并且没有抛出任何异常,Hystrix在返回响应后会执行一些log和指标的上报,如果是调用run()方法,Hystrix会返回一个Observable,该Observable会发射单个响应并且会调用onCompleted方法来通知响应的回调,如果是调用construct()方法,Hystrix会通过construct()方法返回相同的Observable对象. 3.1.7 计算断路器的健康度Hystrix会报告成功,失败,拒绝和超时的指标给断路器,断路器包含了一系列的滑动窗口数据,并通过该数据进行统计.它使用这些统计数据来决定断路器是否应该熔断,如果需要熔断,将在一定的时间内不在请求依赖,直到恢复期结束. 3.1.8 fallback处理当命令执行失败的时候,Hystrix会进入fallback尝试回退处理, 我们通常也称为该操作为”服务降级”, 而能够引起服务降级处理的情况有以下几种: 命令处于”熔断”状态,即断路器是打开的. 当前命令的线程池,请求队列或者信号量被占满的时候. HystrixObservableCommand.construct() 或者 HystrixCommand.run()抛出异常的时候. 在服务降级逻辑中, 我们需要实现一个通用的响应结果, 并且该结果的处理逻辑应当是从缓存或是根据一些静态逻辑来获取,而不是依赖网络请求获取.如果一定要在降级逻辑中包含网络请求, 那么该请求也必须被包装在HystrixObservableCommand 或者 HystrixCommand 中, 从而形成级联的降级策略, 而最终的降级逻辑一定不是一个依赖网络请求的处理, 而是一个能够稳定地返回结果的处理逻辑. 3.1.9 返回成功的响应如果Hystrix命令执行成功,它将以Observable形式返回响应给调用者.根据你在第2步的调用方式不同,在返回Observable之前可能会做一些转换. 3.2 依赖隔离Hystrix则使用”舱壁隔离”模式实现线程池的隔离,它会为每一个Hystrix命令创建一个独立的线程池,这样就算某个在Hystrix命令包装下的依赖服务出现延迟过高的情况,也只是对该依赖服务的调用产生影响,而不会拖慢其他的服务. 通过对依赖服务的线程池隔离实现,可以带来如下优势: 应用自身得到完全的保护,不会受不可控的依赖服务影响.即便给依赖服务分配的线程池被填满,也不会影响应用自身的其余部分. 可以有效的降低接入新服务的风险,如果新服务接入后运行不稳定或存在问题,完全不会影响到应用其他的请求. 当依赖的服务从失效恢复正常后,它的线程池会被清理并且能够马上恢复健康的服务,相比之下容器级别的清理恢复速度要慢得多. 当依赖的服务出现配置错误的时候,线程池会快速的反应出此问题(通过失败次数,延迟,超时,拒绝等指标的增加情况).同时,我们可以在不影响应用功能的情况下通过实时的动态属性刷新来处理它. 当依赖的服务因实现机制调整等原因造成其性能出现很大变化的时候,此时线程池的监控指标信息会反映出这样的变化.同时,我们也可以通过实时动态刷新自身应用对依赖服务的阈值进行调整以适应依赖方的改变. 除了上面通过线程池隔离服务发挥的优点之外,每个专有线程池都提供了内置的并发实现,可以利用它为同步的依赖服务构建异步的访问. 总之,通过对依赖服务实现线程池隔离,让我们的应用更加健壮,不会因为个别依赖服务出现问题而引起非相关服务的异常.同时,也使得我们的应用变得更加灵活,可以在不停止服务的情况下,配合动态配置刷新实现性能配置上的调整. 4. 参考链接&lt;&lt; Spring Cloud微服务实战 &gt;&gt;]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud微服务(三)--客户端负载均衡Spring Cloud Ribbon]]></title>
    <url>%2F2018%2F11%2F23%2FSpring%20Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1(%E4%B8%89)--%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1Spring%20Cloud%20Ribbon%2F</url>
    <content type="text"><![CDATA[1. 前言本文是 &lt;&lt; Spring Cloud微服务实战 &gt;&gt; 学习笔记, 以便自己查阅. Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具,它基于Netflix Ribbon实现. 2. 客户端负载均衡负载均衡是对系统的高可用,网络压力的缓解和处理内容扩容的重要手段之一.负载均衡可以分为客户端负载均衡和服务端负载均衡.负载均衡按设备来分为硬件负载均衡和软件负载均衡,都属于服务端负载均衡. 硬件负载均衡主要通过在服务器节点之间安装专门用于负载均衡的设备,例如F5等.软件负载均衡通过在服务器上安装一些具有负载均衡功能或模块的软件来完成请求的转发工作,例如Nginx等. 硬件负载均衡和软件负载均衡都会维护一个可用的服务清单,然后通过心跳检测来剔除故障节点以保证服务清单中的节点都正常可用.当客户端发出请求时,负载均衡器会按照某种算法(线性轮询,按权重负载,按流量负载等)从服务清单中取出一台服务器的地址,然后将请求转发到该服务器上. 客户端负载均衡需要客户端自己维护自己要访问的服务实例清单,这些服务清单来源于注册中心(在使用Eureka进行服务治理时). 服务端负载均衡架构方式 3. 基于Spring Cloud Ribbon实现客户端负载均衡基于Spring Cloud Ribbon实现客户端负载均衡非常简单,主要由以下步骤: 服务提供者需要启动多个服务实例并注册到一个或多个相关联的服务注册中心上; 服务消费者直接通过带有@LoadBalanced注解的RestTemplate向服务提供者发送请求以实现客户端的负载均衡. 4. 原理使用被@LoadBalanced注解的RestTemplate发起请求时,会被LoadBalancerInterceptor拦截,然后借助负载均衡器LoadBalancerClient将逻辑服务名转换为host:port的具体的服务实例地址,在使用RibbonLoadBalancerClient(Ribbon实现的负载均衡器)时实际使用的是Ribbon中定义的ILoadBalancer,默认自动化配置的负载均衡器是ZoneAwareLoadBalancer. 5. 负载均衡策略这一部分主要引自外部, 我觉得负载均衡是理解这块必不可少的, 可以提前了解一下, 但是实际使用中, 应该还是得根据业务需求选择最合适的. 并且选择之后, 还是得看对应的源码部分, 以便了解这些策略下可能会出现什么问题. 所以这里的源码解读只作参考. 5.1 RandomRule该策略实现了从服务实例清单中随机选择一个服务实例的功能.下面先看一下源码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.netflix.loadbalancer;import java.util.List;import java.util.Random;import com.netflix.client.config.IClientConfig;public class RandomRule extends AbstractLoadBalancerRule &#123; Random rand; public RandomRule() &#123; rand = new Random(); &#125; @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE") public Server choose(ILoadBalancer lb, Object key) &#123; if (lb == null) &#123; return null; &#125; Server server = null; while (server == null) &#123; if (Thread.interrupted()) &#123; return null; &#125; List&lt;Server&gt; upList = lb.getReachableServers(); List&lt;Server&gt; allList = lb.getAllServers(); int serverCount = allList.size(); if (serverCount == 0) &#123; /* * No servers. End regardless of pass, because subsequent passes * only get more restrictive. */ return null; &#125; int index = rand.nextInt(serverCount); server = upList.get(index); if (server == null) &#123; /* * The only time this should happen is if the server list were * somehow trimmed. This is a transient condition. Retry after * yielding. */ Thread.yield(); continue; &#125; if (server.isAlive()) &#123; return (server); &#125; // Shouldn't actually happen.. but must be transient or a bug. server = null; Thread.yield(); &#125; return server; &#125; @Override public Server choose(Object key) &#123; return choose(getLoadBalancer(), key); &#125; @Override public void initWithNiwsConfig(IClientConfig clientConfig) &#123; // TODO Auto-generated method stub &#125;&#125; 分析源码可以看出,IRule接口中Server choose(Object key)函数的实现委托给了该类中的Server choose(ILoadBalancer lb, Object key)函数,该方法增加了一个负载均衡器参数.从具体的实现可以看出,它会使用负载均衡器来获得可用实例列表upList和所有的实例列表allList,并且使用rand.nextInt(serverCount)函数来获取一个随机数,并将该随机数作为upList的索引值来返回具体实例.同时,具体的选择逻辑在一个while(server == null)循环之内,而根据选择逻辑的实现,正常情况下每次都应该选出一个服务实例. 5.2 RoundRobinRule该策略实现了按照线性轮询的方式依次选择每个服务实例的功能.下面看一下源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.netflix.loadbalancer;import com.netflix.client.config.IClientConfig;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.List;import java.util.concurrent.atomic.AtomicInteger;public class RoundRobinRule extends AbstractLoadBalancerRule &#123; private AtomicInteger nextServerCyclicCounter; public Server choose(ILoadBalancer lb, Object key) &#123; if (lb == null) &#123; log.warn("no load balancer"); return null; &#125; Server server = null; int count = 0; while (server == null &amp;&amp; count++ &lt; 10) &#123; List&lt;Server&gt; reachableServers = lb.getReachableServers(); List&lt;Server&gt; allServers = lb.getAllServers(); int upCount = reachableServers.size(); int serverCount = allServers.size(); if ((upCount == 0) || (serverCount == 0)) &#123; log.warn("No up servers available from load balancer: " + lb); return null; &#125; int nextServerIndex = incrementAndGetModulo(serverCount); server = allServers.get(nextServerIndex); if (server == null) &#123; /* Transient. */ Thread.yield(); continue; &#125; if (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123; return (server); &#125; // Next. server = null; &#125; if (count &gt;= 10) &#123; log.warn("No available alive servers after 10 tries from load balancer: " + lb); &#125; return server; &#125; /** * Inspired by the implementation of &#123;@link AtomicInteger#incrementAndGet()&#125;. * * @param modulo The modulo to bound the value of the counter. * @return The next value. */ private int incrementAndGetModulo(int modulo) &#123; for (;;) &#123; int current = nextServerCyclicCounter.get(); int next = (current + 1) % modulo; if (nextServerCyclicCounter.compareAndSet(current, next)) return next; &#125; &#125;&#125; RoundRobinRule具体实现和RandomRule类似,但是循环条件和从可用列表获取实例的逻辑不同.循环条件中增加了一个count计数变量,该变量会在每次循环之后累加,如果循环10次还没获取到Server,就会结束,并打印一个警告信息No available alive servers after 10 tries from load balancer:… 线性轮询的实现是通过AtomicInteger nextServerCyclicCounter对象实现,每次进行实例选择时通过调用int incrementAndGetModulo(int modulo)方法来实现. 5.3 RetryRule该策略实现了一个具备重试机制的实例选择功能. 从源码中可以看出, 内部定义了一个IRule对象, 默认是RoundRobinRule实例, choose方法中则实现了对内部定义的策略进行反复尝试的策略, 若期间能够选择到具体的服务实例就返回, 若选择不到并且超过设置的尝试结束时间(maxRetryMillis参数定义的值 + choose方法开始执行的时间戳)就返回null. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.netflix.loadbalancer;import com.netflix.client.config.IClientConfig;public class RetryRule extends AbstractLoadBalancerRule &#123; IRule subRule = new RoundRobinRule(); long maxRetryMillis = 500; /* * Loop if necessary. Note that the time CAN be exceeded depending on the * subRule, because we're not spawning additional threads and returning * early. */ public Server choose(ILoadBalancer lb, Object key) &#123; long requestTime = System.currentTimeMillis(); long deadline = requestTime + maxRetryMillis; Server answer = null; answer = subRule.choose(key); if (((answer == null) || (!answer.isAlive())) &amp;&amp; (System.currentTimeMillis() &lt; deadline)) &#123; InterruptTask task = new InterruptTask(deadline - System.currentTimeMillis()); while (!Thread.interrupted()) &#123; answer = subRule.choose(key); if (((answer == null) || (!answer.isAlive())) &amp;&amp; (System.currentTimeMillis() &lt; deadline)) &#123; /* pause and retry hoping it's transient */ Thread.yield(); &#125; else &#123; break; &#125; &#125; task.cancel(); &#125; if ((answer == null) || (!answer.isAlive())) &#123; return null; &#125; else &#123; return answer; &#125; &#125;&#125; 5.4 WeightedResponseTimeRule该策略是对RoundRobinRule的扩展, 增加了根据实例的运行情况来计算权重, 并根据权重来挑选实例, 以达到更优的分配效果. 它的实现主要有三个核心内容. 5.4.1 定时任务WeightedResponseTimeRule策略在初始化的时候会通过serverWeightTimer.schedule(new DynamicServerWeightTask(), 0, serverWeightTaskTimerInterval)启动一个定时任务, 用来为每个服务实例计算权重,该任务默认30s执行一次. 5.4.2 权重计算在源码中我们可以轻松找到用于存储权重的对象private volatile List &lt; Double &gt; accumulatedWeights = new ArrayList();该List中每个权重值所处的位置对应了负载均衡器维护的服务实例清单中所有实例在清单中的位置. 下面看一下权重计算函数maintainWeights的源码: 123456789101112131415161718192021222324252627282930313233343536373839404142public void maintainWeights() &#123; ILoadBalancer lb = getLoadBalancer(); if (lb == null) &#123; return; &#125; if (!serverWeightAssignmentInProgress.compareAndSet(false, true)) &#123; return; &#125; try &#123; logger.info("Weight adjusting job started"); AbstractLoadBalancer nlb = (AbstractLoadBalancer) lb; LoadBalancerStats stats = nlb.getLoadBalancerStats(); if (stats == null) &#123; // no statistics, nothing to do return; &#125; double totalResponseTime = 0; // find maximal 95% response time for (Server server : nlb.getAllServers()) &#123; // this will automatically load the stats if not in cache ServerStats ss = stats.getSingleServerStat(server); totalResponseTime += ss.getResponseTimeAvg(); &#125; // weight for each server is (sum of responseTime of all servers - responseTime) // so that the longer the response time, the less the weight and the less likely to be chosen Double weightSoFar = 0.0; // create new list and hot swap the reference List&lt;Double&gt; finalWeights = new ArrayList&lt;Double&gt;(); for (Server server : nlb.getAllServers()) &#123; ServerStats ss = stats.getSingleServerStat(server); double weight = totalResponseTime - ss.getResponseTimeAvg(); weightSoFar += weight; finalWeights.add(weightSoFar); &#125; setWeights(finalWeights); &#125; catch (Exception e) &#123; logger.error("Error calculating server weights", e); &#125; finally &#123; serverWeightAssignmentInProgress.set(false); &#125;&#125; 该方法的实现主要分为两个步骤: 根据LoadBalancerStats中记录的每个实例的统计信息,累加所有实例的平均响应时间,得到总平均响应时间totalResponseTime,该值会用于后续的计算.为负载均衡器中维护的实例清单逐个计算权重(从第一个开始),计算规则为weightSoFar + totalResponseTime - 实例的平均响应时间,其中weightSoFar初始化为0,并且每计算好一个权重需要累加到weightSoFar上供下一次计算使用.通过概算计算出来的权重值只是代表了各实例权重区间的上限.下面图节选自&lt;&lt; Spring Cloud微服务实战 &gt;&gt;. 5.4.3 实例选择下面看一下Server choose(ILoadBalancer lb, Object key)如何选择Server的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public Server choose(ILoadBalancer lb, Object key) &#123; if (lb == null) &#123; return null; &#125; Server server = null; while (server == null) &#123; // get hold of the current reference in case it is changed from the other thread List&lt;Double&gt; currentWeights = accumulatedWeights; if (Thread.interrupted()) &#123; return null; &#125; List&lt;Server&gt; allList = lb.getAllServers(); int serverCount = allList.size(); if (serverCount == 0) &#123; return null; &#125; int serverIndex = 0; // last one in the list is the sum of all weights double maxTotalWeight = currentWeights.size() == 0 ? 0 : currentWeights.get(currentWeights.size() - 1); // No server has been hit yet and total weight is not initialized // fallback to use round robin if (maxTotalWeight &lt; 0.001d || serverCount != currentWeights.size()) &#123; server = super.choose(getLoadBalancer(), key); if(server == null) &#123; return server; &#125; &#125; else &#123; // generate a random weight between 0 (inclusive) to maxTotalWeight (exclusive) double randomWeight = random.nextDouble() * maxTotalWeight; // pick the server index based on the randomIndex int n = 0; for (Double d : currentWeights) &#123; if (d &gt;= randomWeight) &#123; serverIndex = n; break; &#125; else &#123; n++; &#125; &#125; server = allList.get(serverIndex); &#125; if (server == null) &#123; /* Transient. */ Thread.yield(); continue; &#125; if (server.isAlive()) &#123; return (server); &#125; // Next. server = null; &#125; return server;&#125; 下面我们看一下源码的主要步骤有： 首先先获取accumulatedWeights中最后一个权重,如果该权重小于0.001或者实例的数量不等于权重列表的数量,就采用父类的线性轮询策略.如果满足条件,就先产生一个[0,最大权重值)区间内的随机数.遍历权重列表,比较权重值与随机数的大小,如果权重值大于等于随机数,就拿当前权重列表的索引值去服务实例列表获取具体的实例. 5.5 ClientConfigEnabledRoundRobinRule该策略比较特殊,一般不直接使用它.因为他本身并没有实现特殊的处理逻辑,在他内部定义了一个RoundRobinRule策略,choose函数的实现其实就是采用了RoundRobinRule的线性轮询机制. 在实际开发中,我们并不会直接使用该策略,而是基于它做高级策略扩展. 5.6 BestAvailableRule该策略继承自ClientConfigEnabledRoundRobinRule,在实现中它注入了负载均衡器的统计对象LoadBalancerStats,同时在choose方法中利用LoadBalancerStats保存的实例统计信息来选择满足要求的服务实例. 当LoadBalancerStats为空时,会使用RoundRobinRule线性轮询策略,当有LoadBalancerStats时,会通过遍历负载均衡器中维护的所有服务实例,会过滤掉故障的实例,并找出并发请求数最小的一个. 该策略的特性是可以选出最空闲的服务实例. 5.7 PredicateBasedRule这是一个抽象策略,它继承了ClientConfigEnabledRoundRobinRule,从命名中可以猜出这是一个基于Predicate实现的策略,Predicate是Google Guava Collection工具对集合进行过滤的条件接口. 123456789public Server choose(Object key) &#123; ILoadBalancer lb = getLoadBalancer(); Optional&lt;Server&gt; server = getPredicate().chooseRoundRobinAfterFiltering(lb.getAllServers(), key); if (server.isPresent()) &#123; return server.get(); &#125; else &#123; return null; &#125;&#125; 在该源码中,它定义了一个抽象函数getPredicate来获取AbstractServerPredicate对象的实现,在choose方法中,通过AbstractServerPredicate的chooseRoundRobinAfterFiltering函数来选择具体的服务实例.从该方法的命名我们可以看出大致的逻辑:首先通过子类中实现的Predicate逻辑来过滤一部分服务实例,然后再以线性轮询的方式从过滤后的实例清单中选出一个. 在上面choose函数中调用的chooseRoundRobinAfterFiltering方法先通过内部定义的getEligibleServers函数来获取备选的实例清单(实现了过滤),如果返回的清单为空,则用Optional.absent来表示不存在,反之则以线性轮询的方式从备选清单中获取一个实例. 下面看一下getEligibleServers方法的源码: 12345678910111213public List&lt;Server&gt; getEligibleServers(List&lt;Server&gt; servers, Object loadBalancerKey) &#123; if (loadBalancerKey == null) &#123; return ImmutableList.copyOf(Iterables.filter(servers, this.getServerOnlyPredicate())); &#125; else &#123; List&lt;Server&gt; results = Lists.newArrayList(); for (Server server: servers) &#123; if (this.apply(new PredicateKey(loadBalancerKey, server))) &#123; results.add(server); &#125; &#125; return results; &#125;&#125; 上述源码的大致逻辑是遍历服务清单,使用this.apply方法来判断实例是否需要保留,如果是就添加到结果列表中. 实际上,AbstractServerPredicate实现了com.google.common.base.Predicate接口,apply方法是接口中的定义,主要用来实现过滤条件的判断逻辑,它输入的参数则是过滤条件需要用到的一些信息(比如源码中的new PredicateKey(loadBalancerKey, server)),传入了关于实例的统计信息和负载均衡器的选择算法传递过来的key. AbstractServerPredicate没有apply的实现,所以这里的chooseRoundRobinAfterFiltering方法只是定义了一个模板策略:先过滤清单,再轮询选择. 对于如何过滤,需要在AbstractServerPredicate的子类中实现apply方法来确定具体的过滤策略. 5.8 AvailabilityFilteringRule该类继承自PredicateBasedRule,遵循了先过滤清单,再轮询选择的基本处理逻辑,其中过滤条件使用了AvailabilityPredicate,下面看一下AvailabilityPredicate的源码: 12345678910111213141516171819202122232425262728package com.netflix.loadbalancer;import javax.annotation.Nullable;import com.netflix.client.config.IClientConfig;import com.netflix.config.ChainedDynamicProperty;import com.netflix.config.DynamicBooleanProperty;import com.netflix.config.DynamicIntProperty;import com.netflix.config.DynamicPropertyFactory;public class AvailabilityPredicate extends AbstractServerPredicate &#123; @Override public boolean apply(@Nullable PredicateKey input) &#123; LoadBalancerStats stats = getLBStats(); if (stats == null) &#123; return true; &#125; return !shouldSkipServer(stats.getSingleServerStat(input.getServer())); &#125; private boolean shouldSkipServer(ServerStats stats) &#123; if ((CIRCUIT_BREAKER_FILTERING.get() &amp;&amp; stats.isCircuitBreakerTripped()) || stats.getActiveRequestsCount() &gt;= activeConnectionsLimit.get()) &#123; return true; &#125; return false; &#125;&#125; 从上面的源码可以看出,主要过的过滤逻辑都是在boolean shouldSkipServer(ServerStats stats)方法中实现,该方法主要判断服务实例的两项内容: 是否故障,即断路由器是否生效已断开实例的并发请求数大于阀值,默认值2^32 - 1,该配置可以通过参数来修改 上面两项只要满足一项,apply方法就返回false,代表该服务实例可能存在故障或负载过高,都不满足就返回true. 在AvailabilityFilteringRule进行实例选择时做了小小的优化,它并没有向父类一样先遍历所有的节点进行过滤,然后在过滤后的集合中选择实例.而是先以线性的方式选择一个实例,接着使用过滤条件来判断该实例是否满足要求,若满足就直接使用该实例,若不满足要求就再选择下一个实例,检查是否满足要求,这个过程循环10次如果还没有找到合适的服务实例,就采用父类的实现方案. 该策略通过线性轮询的方式直接尝试寻找可用且比较空闲的实例来用,优化了每次都要遍历所有实例的开销. 5.9 ZoneAvoidanceRule该类也是PredicateBasedRule的子类,它的实现是通过组合过滤条件CompositePredicate,以ZoneAvoidancePredicate为主过滤条件,以AvailabilityPredicate为次过滤条件. ZoneAvoidanceRule的实现并没有像AvailabilityFilteringRule重写choose函数来优化,所以它遵循了先过滤清单再轮询选择的基本逻辑. 下面看一下CompositePredicate的源码 12345678910111213141516171819202122232425262728293031323334package com.netflix.loadbalancer;import java.util.Iterator;import java.util.List;import javax.annotation.Nullable;import com.google.common.base.Predicate;import com.google.common.base.Predicates;import com.google.common.collect.Lists;public class CompositePredicate extends AbstractServerPredicate &#123; private AbstractServerPredicate delegate; private List&lt;AbstractServerPredicate&gt; fallbacks = Lists.newArrayList(); private int minimalFilteredServers = 1; private float minimalFilteredPercentage = 0; @Override public boolean apply(@Nullable PredicateKey input) &#123; return delegate.apply(input); &#125; @Override public List&lt;Server&gt; getEligibleServers(List&lt;Server&gt; servers, Object loadBalancerKey) &#123; List&lt;Server&gt; result = super.getEligibleServers(servers, loadBalancerKey); Iterator&lt;AbstractServerPredicate&gt; i = fallbacks.iterator(); while (!(result.size() &gt;= minimalFilteredServers &amp;&amp; result.size() &gt; (int) (servers.size() * minimalFilteredPercentage)) &amp;&amp; i.hasNext()) &#123; AbstractServerPredicate predicate = i.next(); result = predicate.getEligibleServers(servers, loadBalancerKey); &#125; return result; &#125;&#125; 从源码中可以看出,CompositePredicate定义了一个主过滤条件delegate和一组过滤条件列表fallbacks,次过滤条件的过滤顺序是按存储顺序执行的. 在获取结果的getEligibleServers函数中的主要逻辑是: 使用主过滤条件对所有实例过滤并返回过滤后的实例清单每次使用次过滤条件过滤前,都要判断两个条件,一个是过滤后的实例总数 &gt;= 最小过滤实例数(minimalFilteredServers,默认值为1), 另一个是过滤后的实例比例 &gt; 最小过滤百分比(minimalFilteredPercentage，默认为0),只要有一个不符合就不再进行过滤, 将当前服务实例列表返回依次使用次过滤条件列表中的过滤条件对主过滤条件的过滤结果进行过滤. 6. 参考链接&lt;&lt; Spring Cloud微服务实战 &gt;&gt;客户端负载均衡Spring Cloud RibbonSpring Cloud Ribbon负载均衡策略]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud微服务(二)--服务治理Spring Cloud Eureka]]></title>
    <url>%2F2018%2F11%2F23%2FSpring%20Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1(%E4%BA%8C)--%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86Spring%20Cloud%20Eureka%2F</url>
    <content type="text"><![CDATA[1. 前言本文是 &lt;&lt; Spring Cloud微服务实战 &gt;&gt; 学习笔记, 以便自己查阅. 2. 服务治理随着微服务应用的不断增加,静态配置会越来越难以维护,并且随着业务的不断发展,集群规模,服务位置,服务命名都会发生变化,手动维护的方式极易发生错误或是命名冲突问题.因此需要服务治理框架对微服务实例进行管理,服务治理是微服务架构中最核心的功能和模块,主要用来各个微服务实例的自动化注册和发现. 2.1 服务注册在服务治理框架中,通常都会有一个服务注册中心.每一个微服务实例向注册中心登记自己提供的服务,将主机,端口号,版本号,通信协议等一些信息告知注册中心.注册中心按服务名分类组织服务清单. 服务注册中心需要以心跳的方式监测服务清单中的服务是否可用,如果不可用,需要将不可用的服务实例进行剔除. 2.2 服务发现服务间的调用通过向服务名发起请求调用实现.服务调用方在调用提供方的接口时,并不知道提供方的具体地址.服务调用方需要从注册中心获取所有服务的实例清单,才可以实现对具体服务实例的访问. 服务调用方在发起调用时,会以某种策略取出一个具体的服务实例进行服务调用(客户端负载均衡). 在实际的环境中,为了提高性能,并不会采用每次都向服务注册中心获取服务的方式进行服务的调用,并且不同的应用场景在缓存和服务剔除等机制上可以采用不同的实现策略. 3. Netflix EurekaSpring Cloud Eureka采用Netflix Eureka来实现服务注册与发现,包含客户端和服务端组件. 3.1 Eureka服务端(服务注册中心)支持高可用配置.依托于强一致性提供良好的服务实例可用性.服务注册中心之间可以通过异步模式互相复制各自的状态. 3.2 Eureka客户端主要用于服务的注册和发现.客户端可以通过注解和参数配置的方式实现注册与发现.Eureka客户端向注册中心注册自身提供的服务并周期性地发送心跳来更新它的服务租约.Eureka客户端从服务端查询当前注册的服务信息并把它们缓存到本地并周期性的刷新服务状态. 3.2.1 关于客户端的说明客户端其实分为两种, 一种是服务提供方, 一种是服务消费方, 服务提供方需要向注册中心注册自身提供的服务并周期性地发送心跳来更新它的服务租约. 而服务消费方从服务端查询当前注册的服务信息并把它们缓存到本地并周期性的刷新服务状态. 3.3 服务发现与消费服务消费者的主要目标是发现和消费服务.其中服务发现由Eureka客户端完成,服务消费由Ribbon完成. 4. Eureka详解4.1 基础结构服务注册中心: Eureka服务端, 提供服务注册和发现的功能.服务提供者: 提供服务的应用, 将自己提供的服务注册到Eureka, 供其他应用发现服务消费者: 消费者从注册中心发现服务列表, 然后调用对应的服务(Ribbon或Feign) 备注: 一般一个应用既是服务提供者也是服务消费者. 4.2 服务治理机制Eureka服务体系图 4.2.1 服务提供者4.2.1.1 服务注册服务提供者会以Rest请求的方式注册到注册中心上,在请求过程中会携带自身的一些元数据信息.注册中心在收到请求后,会将元数据信息保存到一个双层Map结构中,外层的key是服务名称,内层的key是具体的服务实例名称. eureka.client.register-with-eureka,如果该参数的值等于false,不会进行注册. 4.2.1.2 服务同步如果两个服务注册在两个不同的注册中心上,两个注册中心互相注册成为服务(集群),此时,当服务提供者向其中一个注册中心发起请求时,该注册中心会将请求准发给集群中的其他注册中心,从而实现注册中心之间的服务同步. 由于服务同步的存在,服务提供者的信息可以在任意一台注册中心上获取. 4.2.1.3 服务续约在服务注册完成之后,服务提供者需要维护一个心跳来告知注册中心服务实例处于正常运行状态中,防止注册中心将正常的服务实例剔除出注册中心.上述操作就成为服务续约. 4.2.2 服务消费者4.2.2.1 获取服务启动服务消费者时,服务消费者会向注册中心发起一个Rest请求,来获取注册中心维护的服务实例清单.但是为了提高性能,注册中心会维护一份只读的服务清单返回给客户端,该缓存的服务清单会每隔30s刷新一次. eureka.client.fetch-registry,如果该参数被设置为false,无法向注册中心获取服务清单.eureka.client.registry-fetch-interval-seconds,缓存清单的刷新时间,默认30s. 4.2.2.2 服务调用服务消费者获得服务清单后,可以根据服务名获取具体服务实例列表(元数据信息),根据自己的策略选择具体的服务实例进行调用. Eureka有Region和Zone的概念,一个Region中会有多个Zone,每个客户端都需要注册到一个Zone中,所以客户端对应一个Region和一个Zone.在服务进行调用时,优先访问同一个Zone中的服务提供方,若访问不到,再访问其他Zone. 4.2.2.3 服务下线当服务实例正常关闭时,服务实例会发送一个服务下线的Rest请求给注册中心.注册中心在收到请求后,会将该服务实例的状态置为DOWN,并且将下线时间广播出去. 4.2.3 服务注册中心4.2.3.1 失效剔除当服务实例未正常下线时(内存溢出,网络故障),服务注册中心未能收到服务下线的Rest请求.注册中心在启动时会创建一个定时任务,默认每隔一段时间(60s)将当前清单中超时(服务失效时间,默认90s)没有续约的服务进行剔除. 4.2.3.2 自我保护注册中心在运行期间,会统计心跳失败比例在15分钟内是否低于85%,如果出现低于的情况,注册中心会将当前服务实例的注册信息保护起来,让这些实例不会过期.但是,在保护期时间内,如果实例出现问题,那么服务调用者很容易拿到该实例调用失败,所以服务调用者必须要有容错机制(请求重试,断路由器等). eureka.server.enable-self-preservation,如果该值设置为false,则不启用自我保护机制,默认值为true 5. 其他5.1 健康检测默认情况下,Eureka中各个服务实例的健康检测并不是通过spring-cloud-actuator模块的/actuator/health节点,而是依靠客户端的心跳来保持服务的存活. 默认的客户端心跳方式无法保证客户端提供正常的服务.比如微服务一般会有依赖的外部资源(如数据库,缓存,消息代理等),假如与这些外部资源无法联通,但是客户端心跳依旧存在,这就会导致调用出现问题. 使用spring-boot-actuator模块的/actuator/health端点,只需要两部曲: 在pom.xml文件中引入spring-boot-actuator依赖在配置文件中加入eureka.client.healthcheck.enabled=true 6. 参考链接&lt;&lt; Spring Cloud微服务实战 &gt;&gt;spring-cloud-eureka服务治理]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud微服务(一)--Spring Cloud基础]]></title>
    <url>%2F2018%2F11%2F19%2FSpring%20Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1(%E4%B8%80)--Spring%20Cloud%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. 前言本文是 &lt;&lt; Spring Cloud微服务实战 &gt;&gt; 学习笔记, 以便自己查阅. 2. 什么是微服务微服务是一种系统架构的设计风格,它主旨在于将一个原本独立的系统,拆分成多个独立运行的小型服务.不同服务之间通过Restful接口进行通讯协作. 拆分的小型服务围绕系统耦合度高的业务功能进行构建;每个服务都维护自身的数据存储,业务开发,测试,部署机制;由于是轻量级通讯协作,微服务可以使用不同语言来编写. 3. 如何实施微服务3.1 引入微服务(与单体应用对比)引发的问题运维:维护进程数增加,需要一定的开发能力来编排组织进程;接口:需要交互双方协调发布,完善接口和版本管理,保证接口的正确调用;分布式环境:拆分后服务只能通过通信来进行协作,所以要考虑分布式环境的因素(网络延迟,分布式事务,异步消息) 3.2 微服务特性为了解决前面的问题,以下是实施微服务一些原则: 3.2.1 服务组件化保证每个服务都独立开发,部署,避免一个服务修改引起整个系统的重新部署. 3.2.2 按业务组织团队以前按照技术层面将团队划分为DBA团队,运维团队,测试团队,后端,前端团队等等,若继续使用这种团队组织方式来实施对微服务架构的开发,当一个服务出现问题时,会引起团队的时间耗费和预算审批.所以在进行微服务架构的开发时,一般按业务线的方式进行拆分. 3.2.3 以产品态度对待服务对服务整个生命周期负责,持续关注服务的运作情况,并不断分析以帮助用户来改善业务功能. 3.2.4 智能端点与哑管道原则使用微服务不能简单将函数调用直接改成Restful/RPC调用(避免繁琐的通信), 微服务常用两种服务调用方式: 基于Http的Restful API(或其它轻量级的消息发送协议) - 请求响应模型,同步阻塞 基于轻量级消息总线(MQ) - 观察模型 关于智能端点与哑管道的概念 哑管道是指消息的通讯,管道是不会通知端点消息的内容,结构,仅提供一个可靠的信息交互功能,称为”哑”.智能端点是指端点要主动订阅管道的消息,去解析里面的内容,称为”智能”. 3.2.5 去中心化治理整个架构采用轻量级协议定义接口,各个组件根据具体业务特点进行技术选型. 3.2.6 去中心化管理数据每个服务管理其自有的数据库.(在改造过程中,将数据库的数据拆分到其它数据库中(Mysql,MongoDB,Redis)) 面临的新问题 分布式事务,所以尽量避免事务,保证各服务之间是”无事务”的调用;一致性问题,保证最终一致性; 3.2.7 基础设施自动化由于服务数量的增多,务必需要一个”持续交付”平台来支持实施.自动化测试与自动化部署. 3.2.8 容错设计微服务架构中,可能存在部分服务故障的情况,处理不好会出现故障蔓延的情况.(一个正常服务频繁调用故障服务,导致大量线程挂起等待超时,最后正常服务也出现了故障) 所以微服务架构中,应快速监测出故障源并尽可能恢复服务.(对每个组件的运行情况(服务状态,断路器状态,吞吐量,网络延迟等)实现监控和日志记录) 3.2.9 演进式设计实施微服务应该以演进的方式构建. 4. 参考链接《Spring Cloud微服务实战》读书笔记之基础知识1《微服务》九大特性重读笔记&lt;&lt; Spring Cloud微服务实战 &gt;&gt;]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot之Actuator]]></title>
    <url>%2F2018%2F11%2F18%2FSpring%20Boot%E4%B9%8BActuator%2F</url>
    <content type="text"><![CDATA[1. 前言本文是&lt;&lt; Spring Boot 实战 &gt;&gt;和&lt;&lt; Java EE开发的颠覆者 Spring Boot 实战 &gt;&gt;的学习笔记, 以便自己查阅. Sprng Boot 2 actuator变动加大, 网上很多资料都都已经过期, 所以记录一下. 2. 配置在 application.properties 配置文件, actuator 的设置项 management.endpoints(设置 actuator 全局级的属性) 和 management.endpoint(设置 具体endpoint 属性) 开头. 2.1 全局级的控制123456789101112#定制管理功能的 port, 如果端口为 -1 代表不暴露管理功能 over HTTPmanagement.server.port=8081# 设定 /actuator 入口路径management.endpoints.web.base-path=/actuator# 所有endpoint缺省为禁用状态management.endpoints.enabled-by-default=false# 暴露所有的endpoint, 但 shutdown 需要显示enable才暴露, * 表示全部, 如果多个的话,用逗号隔开management.endpoints.web.exposure.include=*# 排除暴露 loggers和beans endpointmanagement.endpoints.web.exposure.exclude=loggers,beans# 定制化 health 端点的访问路径management.endpoints.web.path-mapping.health=healthcheck 2.2 endpoint 级别的控制所有的endpoint都有 enabled 属性, 可以按需开启或关闭特定端点. 12#启用 shutdownmanagement.endpoint.shutdown.enabled=true 2.3 health端点配置12345management.endpoint.health.enabled=true#show-details属性的取值有: never/always/when-authorized, 默认值是 nevermanagement.endpoint.health.show-details=always #增加磁盘空间health 统计, 还有其他health indicatormanagement.health.diskspace.enabled=true 2.4 actuator 缺省的设置缺省 actuator 的根路径为 /actuator缺省仅开放 health 和 info, 其他都不开放.有些 endpoint 是GET, 有些是POST方法, 比如 health 为GET, shutdown 为 POST, 从SpringBoot程序启动日志中,可以看出到底有哪些endpoint被开启. 2.5 endpoint 清单actuator 支持的所有 endpoint, 可以查官网 https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html 下面是一些重要的端点,(以访问路径列出): 123456789/actuator: actuator 严格地说不能算 endpoint, /actuator 返回要给 endpoint 的清单./actuator/health: 展现系统运行状态, 在和spring cloud consul集成时候, 就使用该端点检查Spring应用的状态./actuator/metric/: 显示更全面的系统指标/actuator/configprops:展现 SpringBoot 配置项/actuator/env: 显示系统变量和SpringBoot应用变量, actuator 非常贴心, 如果属性名包含 password/secret/key 这些关键词, 对应的属性值将用 * 号代替./actuator/httptrace: 显示最近100条 request-response 信息/actuator/autoconfig: 生成Spring boot自动化配置报告, 该报告非常有用, 说明如下: Spring Boot项目倾向于使用很多auto config技术, 包括散落在很多config java类. 我们在开发过程中偶尔会遇到, 为什么我的配置没起作用这样的问题. 这时候查看 /actuator/autoconfig 的报告非常有用, 它会告诉你哪些自动化装配成功了,哪些没有成功. /actuator/beans: 该端点可以获取 application context 中创建的所有 bean, 并列出它们的scope 和 type 等详细信息/actuator/mappings: 该端点列出了所有 controller 的路由信息. 3. 使用在pom文件导入依赖即可. 12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.1 其他说明actuator的UI显示不好,所以网上有很多结合actuator使用的UI界面. 不过日常一般也不会去用这个actuator, 只是spring cloud里面会有需要. 4. 参考链接&lt;&lt; Spring Boot 实战 &gt;&gt;(Craig Walls 著, 丁雪丰 译)&lt;&lt; Java EE开发的颠覆者 Spring Boot 实战 &gt;&gt;SpringBoot系列: Actuator监控]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot基本认识]]></title>
    <url>%2F2018%2F11%2F18%2FSpring%20Boot%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1. 前言本文是&lt;&lt; Spring Boot 实战 &gt;&gt;和&lt;&lt; Java EE开发的颠覆者 Spring Boot 实战 &gt;&gt;的学习笔记, 以便自己查阅. 2. 什么是Spring Boot2.1 Spring Boot本质简单的说,spring boot就是整合了很多优秀的框架,不用我们自己手动的去写一堆xml配置然后进行配置. 从本质上来说,Spring Boot就是Spring,它做了那些没有它你也会去做的Spring Bean配置.它使用”习惯优于配置”(项目中存在大量的配置,此外还内置了一个习惯性的配置,让你无需手动进行配置)的理念让你的项目快速运行起来.使用Spring Boot很容易创建一个独立运行(运行jar,内嵌Servlet容器),准生产级别的基于Spring框架的项目,使用Spring Boot你可以不用或者只需要很少的Spring配置. 2.2 Spring Boot精要Spring将很多魔法带入了Spring应用程序的开发之中,其中最重要的是以下四个核心. 自动配置: 针对很多Spring应用程序常见的应用功能, Spring Boot能自动提供相关配置;(简化配置) 起步依赖: 告诉Spring Boot需要什么功能, 它就能引入需要的库.(简化导入依赖) 命令行界面: 这是Spring Boot的可选特性, 借此你只需写代码就能完成完整的应用程序, 无需传统项目构建.(感觉没啥用) Actuator: 让你能够深入运行中的Spring Boot应用程序, 一探究竟.(监控) 3. 参考链接&lt;&lt; Spring Boot 实战 &gt;&gt;(Craig Walls 著, 丁雪丰 译)&lt;&lt; Java EE开发的颠覆者 Spring Boot 实战 &gt;&gt;]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Maven搭建多模块Spring Boot项目]]></title>
    <url>%2F2018%2F11%2F18%2F%E4%BD%BF%E7%94%A8Maven%E6%90%AD%E5%BB%BA%E5%A4%9A%E6%A8%A1%E5%9D%97Spring%20Boot%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[项目地址: https://github.com/ganlu19940318/maven-parent]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC]]></title>
    <url>%2F2018%2F11%2F16%2FSpring%20MVC%2F</url>
    <content type="text"><![CDATA[1. 前言本文是&lt;&lt;精通Spring 4.x 企业应用开发实战&gt;&gt;学习笔记, 以便自己查阅. 2. Spring MVC核心流程 SpringMVC 框架中,DispatcherServlet 处于核心位置,它负责协调和组织不同组件已完成请求处理并返回响应的工作.和大多数Web MVC 框架一样,SpringMVC 通过一个前端的Servlet 接收所有的请求,并将具体工作委托给其他的组件进行处理,DispatcherServlet 就是Spring MVC 的前端Servlet. Spring MVC 处理请求的整体过程如下: 整个过程始于客户端发出的一个HTTP 请求, Web 应用服务器接收到这个请求, 如果匹配 DispatcherServlet 的请求映射路径(在web.xml中指定), Web容器就将该请求转交给DispatcherServlet 处理. DispatcherServlet 接收到这个请求后, 将根据请求的信息(包括URL,HTTP方法,请求报文头,请求参数,coookie等)及HandlerMapping的配置找到处理请求的处理器(Handler). 可将 HandlerMapping看成路由控制器, 将 Handler 看成目标主机.值得注意的是:Spring MVC 中并没有定义一个Handler 接口,实际上任何一个 Object 都可以成为请求处理器. 当DispatcherServlet 根据 HandlerMapping 得到对应当前请求的 Handler 后,通过HandlerAdapter 对 Handler 进行封装,再以统一的适配器接口调用 Handler. HandlerAdapter 是SpringMvc 框架级接口,顾名思义, HandlerAdapter 是一个适配器, 它用统一的接口对各种Handler 方法进行调用. 处理器完成业务逻辑的处理后将返回一个 ModelAndView 给 DispatcherServlet, ModelAndView 包含了视图逻辑名和模型数据信息. ModelAndView 中包含的是”逻辑视图名”而非真正的视图对象,DispatcherServlet 借由ViewResolver 完成逻辑视图名到真实视图对象的解析工作. 当得到真实的视图对象View 后, DispatcherServlet 就使用这个View 对象对ModelAndView中的模型数据进行视图渲染. 最终客户端得到的响应消息可能是一个HTML页面, 也可能是一个XML或JSON串, 甚至是一张图片或者一个PDF文档等不同的媒体形式. 3. 参考链接Spring MVC 教程,快速入门,深入分析深入理解Spring MVC 思想&lt;&lt;精通Spring 4.x 企业应用开发实战&gt;&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring事务管理]]></title>
    <url>%2F2018%2F11%2F16%2FSpring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 前言本文是&lt;&lt;精通Spring 4.x 企业应用开发实战&gt;&gt;学习笔记, 以便自己查阅. 2. 核心接口Spring事务管理的实现有许多细节,如果对整个接口框架有个大体了解会非常有利于我们理解事务,下面通过讲解Spring的事务接口来了解Spring实现事务的具体策略.Spring事务管理涉及的接口的联系如下: 3. 事务管理器Spring并不直接管理事务,而是提供了多种事务管理器,他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现.Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager,通过这个接口,Spring为各个平台如JDBC,Hibernate等都提供了对应的事务管理器,但是具体的实现就是各个平台自己的事情了.此接口的内容如下: 12345678Public interface PlatformTransactionManager()...&#123; // 由TransactionDefinition得到TransactionStatus对象 TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; // 提交 Void commit(TransactionStatus status) throws TransactionException; // 回滚 Void rollback(TransactionStatus status) throws TransactionException; &#125; 从这里可知具体的具体的事务管理机制对Spring来说是透明的,它并不关心那些,那些是对应各个平台需要关心的,所以Spring事务管理的一个优点就是为不同的事务API提供一致的编程模型,如JTA,JDBC,Hibernate,JPA.下面分别介绍各个平台框架实现事务管理的机制. 3.1 JDBC事务如果应用程序中直接使用JDBC来进行持久化,DataSourceTransactionManager会为你处理事务边界.为了使用DataSourceTransactionManager,你需要使用如下的XML将其装配到应用程序的上下文定义中: 123&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt; 实际上,DataSourceTransactionManager是通过调用java.sql.Connection来管理事务,而后者是通过DataSource获取到的.通过调用连接的commit()方法来提交事务,同样,事务失败则通过调用rollback()方法进行回滚. 3.2 Hibernate事务如果应用程序的持久化是通过Hibernate实现的,那么你需要使用HibernateTransactionManager.对于Hibernate3,需要在Spring上下文定义中添加如下的 &lt; bean &gt; 声明: 123&lt;bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory" /&gt;&lt;/bean&gt; sessionFactory属性需要装配一个Hibernate的session工厂,HibernateTransactionManager的实现细节是它将事务管理的职责委托给org.hibernate.Transaction对象,而后者是从Hibernate Session中获取到的.当事务成功完成时,HibernateTransactionManager将会调用Transaction对象的commit()方法,反之,将会调用rollback()方法. 3.3 Java持久化API事务(JPA)Hibernate多年来一直是事实上的Java持久化标准,但是现在Java持久化API作为真正的Java持久化标准进入大家的视野.如果你计划使用JPA的话,那你需要使用Spring的JpaTransactionManager来处理事务.你需要在Spring中这样配置JpaTransactionManager: 123&lt;bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory" /&gt;&lt;/bean&gt; JpaTransactionManager只需要装配一个JPA实体管理工厂(javax.persistence.EntityManagerFactory接口的任意实现).JpaTransactionManager将与由工厂所产生的JPA EntityManager合作来构建事务. 3.4 Java原生API事务如果你没有使用以上所述的事务管理,或者是跨越了多个事务管理源(比如两个或者是多个不同的数据源),你就需要使用JtaTransactionManager: 123&lt;bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager"&gt; &lt;property name="transactionManagerName" value="java:/TransactionManager" /&gt;&lt;/bean&gt; JtaTransactionManager将事务管理的责任委托给javax.transaction.UserTransaction和javax.transaction.TransactionManager对象,其中事务成功完成通过UserTransaction.commit()方法提交,事务失败通过UserTransaction.rollback()方法回滚. 4. 基本事务属性的定义上面讲到的事务管理器接口PlatformTransactionManager通过getTransaction(TransactionDefinition definition)方法来得到事务,这个方法里面的参数是TransactionDefinition类,这个类就定义了一些基本的事务属性. 那么什么是事务属性呢?事务属性可以理解成事务的一些基本配置,描述了事务策略如何应用到方法上.事务属性包含了5个方面,如图所示: 而TransactionDefinition接口内容如下: 123456public interface TransactionDefinition &#123; int getPropagationBehavior(); // 返回事务的传播行为 int getIsolationLevel(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据 int getTimeout(); // 返回事务必须在多少秒内完成 boolean isReadOnly(); // 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的&#125; 我们可以发现TransactionDefinition正好用来定义事务属性,下面详细介绍一下各个事务属性. 4.1 传播行为不展开,下面单独列一章介绍. 4.2 隔离级别事务的第二个维度就是隔离级别(isolation level).隔离级别定义了一个事务可能受其他并发事务影响的程度. 并发事务引起的问题 在典型的应用程序中,多个事务并发运行,经常会操作相同的数据来完成各自的任务.并发虽然是必须的,但可能会导致以下的问题. 123脏读（Dirty reads）——脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。不可重复读（Nonrepeatable read）——不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。幻读（Phantom read）——幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。 隔离级别 隔离级别 含义 ISOLATION_DEFAULT 使用后端数据库默认的隔离级别 ISOLATION_READ_UNCOMMITTED 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读 ISOLATION_READ_COMMITTED 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生 ISOLATION_REPEATABLE_READ 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生 ISOLATION_SERIALIZABLE 最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的 4.3 只读事务的第三个特性是它是否为只读事务.如果事务只对后端的数据库进行该操作,数据库可以利用事务的只读特性来进行一些特定的优化.通过将事务设置为只读,你就可以给数据库一个机会,让它应用它认为合适的优化措施. 4.4 事务超时为了使应用程序很好地运行,事务不能运行太长的时间.因为事务可能涉及对后端数据库的锁定,所以长时间的事务会不必要的占用数据库资源.事务超时就是事务的一个定时器,在特定时间内事务如果没有执行完毕,那么就会自动回滚,而不是一直等待其结束. 4.5 回滚规则事务五边形的最后一个方面是一组规则,这些规则定义了哪些异常会导致事务回滚而哪些不会.默认情况下,事务只有遇到运行期异常时才会回滚,而在遇到检查型异常时不会回滚(这一行为与EJB的回滚行为是一致的),但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚.同样,你还可以声明事务遇到特定的异常不回滚,即使这些异常是运行期异常. 5. 事务状态上面讲到的调用PlatformTransactionManager接口的getTransaction()的方法得到的是TransactionStatus接口的一个实现,这个接口的内容如下: 1234567public interface TransactionStatus&#123; boolean isNewTransaction(); // 是否是新的事物 boolean hasSavepoint(); // 是否有恢复点 void setRollbackOnly(); // 设置为只回滚 boolean isRollbackOnly(); // 是否为只回滚 boolean isCompleted; // 是否已完成&#125; 可以发现这个接口描述的是一些处理事务提供简单的控制事务执行和查询事务状态的方法,在回滚或提交的时候需要应用对应的事务状态. 6. 事务传播行为事务的第一个方面是传播行为(propagation behavior).当事务方法被另一个事务方法调用时,必须指定事务应该如何传播.例如:方法可能继续在现有事务中运行,也可能开启一个新事务,并在自己的事务中运行.Spring定义了七种传播行为: 传播行为 含义 PROPAGATION_REQUIRED 表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务 PROPAGATION_SUPPORTS 表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行 PROPAGATION_MANDATORY 表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常 PROPAGATION_REQUIRED_NEW 表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager PROPAGATION_NOT_SUPPORTED 表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager PROPAGATION_NEVER 表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常 PROPAGATION_NESTED 表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务 6.1 PROPAGATION_REQUIRED假如当前正要运行的事务不在另外一个事务里, 那么就起一个新的事务, 比方说, ServiceB.methodB的事务级别定义为PROPAGATION_REQUIRED, 那么因为执行ServiceA.methodA的时候, ServiceA.methodA已经起了事务. 这时调用ServiceB.methodB, ServiceB.methodB看到自己已经执行在ServiceA.methodA的事务内部. 就不再起新的事务. 而假如ServiceA.methodA执行的时候发现自己没有在事务中, 他就会为自己分配一个事务. 这样, 在ServiceA.methodA或者在ServiceB.methodB内的不论什么地方出现异常. 事务都会被回滚. 即使ServiceB.methodB的事务已经被提交, 可是ServiceA.methodA在接下来fail要回滚, ServiceB.methodB也要回滚. 6.2 PROPAGATION_SUPPORTS假设当前在事务中. 即以事务的形式执行. 假设当前不再一个事务中, 那么就以非事务的形式执行. 6.3 PROPAGATION_MANDATORY必须在一个事务中执行. 也就是说, 他仅仅能被一个父事务调用. 否则,他就要抛出异常. 6.4 PROPAGATION_REQUIRES_NEW这个就比較绕口了. 比方我们设计ServiceA.methodA的事务级别为PROPAGATION_REQUIRED, ServiceB.methodB的事务级别为PROPAGATION_REQUIRES_NEW. 那么当运行到ServiceB.methodB的时候, ServiceA.methodA所在的事务就会挂起. ServiceB.methodB会起一个新的事务. 等待ServiceB.methodB的事务完毕以后, 他才继续运行. 他与PROPAGATION_REQUIRED 的事务差别在于事务的回滚程度了. 由于ServiceB.methodB是新起一个事务, 那么就是存在两个不同的事务. 假设ServiceB.methodB已经提交, 那么ServiceA.methodA失败回滚. ServiceB.methodB是不会回滚的. 假设ServiceB.methodB失败回滚, 假设他抛出的异常被ServiceA.methodA捕获, ServiceA.methodA事务仍然可能提交. 6.5 PROPAGATION_NOT_SUPPORTED当前不支持事务.比方ServiceA.methodA的事务级别是PROPAGATION_REQUIRED.而ServiceB.methodB的事务级别是PROPAGATION_NOT_SUPPORTED,那么当执行到ServiceB.methodB时.ServiceA.methodA的事务挂起.而他以非事务的状态执行完,再继续ServiceA.methodA的事务. 6.6 PROPAGATION_NEVER不能在事务中执行.如果ServiceA.methodA的事务级别是PROPAGATION_REQUIRED.而ServiceB.methodB的事务级别是PROPAGATION_NEVER,那么ServiceB.methodB就要抛出异常了. 6.7 PROPAGATION_NESTED理解Nested的关键是savepoint.他与PROPAGATION_REQUIRES_NEW的差别是,PROPAGATION_REQUIRES_NEW另起一个事务.将会与他的父事务相互独立.而Nested的事务和他的父事务是相依的,他的提交是要等和他的父事务一块提交的.也就是说,假设父事务最后回滚.他也要回滚的.而Nested事务的优点是他有一个savepoint. 7. 参考链接Spring事务管理（详解+实例）浅析Spring事务传播行为和隔离级别&lt;&lt;精通Spring 4.x 企业应用开发实战&gt;&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring DAO]]></title>
    <url>%2F2018%2F11%2F16%2FSpring%20DAO%2F</url>
    <content type="text"><![CDATA[1. 前言本文是&lt;&lt;精通Spring 4.x 企业应用开发实战&gt;&gt;学习笔记, 以便自己查阅. 2. 概述近几年持久化技术领域异常喧嚣,各种框架雨后春笋般地冒出,Sun也连接不断地颁布几个持久化规范.Spring对多个持久化技术提供了集成的支持,包括 Hibernate, iBatis, JDO, JPA, TopLink, 此外, 还通过Spring JDBC框架对JDBC API进行简化. Spring面向DAO制定了一个通用的异常体系, 屏蔽具体持久化技术的异常, 使业务层和具体的持久化技术达到解耦. 此外, Spring 提供了模板类简化各种持久化技术的使用. 通用的异常体系及模板类是Spring整合各种五花八门持久化技术的不二法门, Spring不但借此实现了对多种持久化技术的整合, 还可以不费吹灰之力整合潜在的各种持久化框架, 体现了”开-闭原则”的经典应用. 3. Spring的DAO理念DAO(Data Access Object)是用于访问数据的对象, 虽然我们在大多数情况下, 将数据保存在数据库中, 但这并不是唯一的选择, 你也可以将数据存储到文件中或LDAP中. DAO不但屏蔽了数据存储的最终介质的不同, 也屏蔽了具体的实现技术的不同.早期, JDBC是访问数据库的主流选择,近几年,数据持久技术获得了长足的发展,Hibernate,iBatis,JPA,JDO成为持久层中争放异彩的实现技术.只要为数据访问定义好DAO接口,并使用具体的技术实现DAO接口的功能,你就可以在不同的实现技术间平滑的切换. 图1 业务层通过DAO接口访问数据 在UserDao中定义访问User数据对象的接口方法,业务层通过UserDao操作数据,并使用具体持久技术实现UserDao接口方法,这样业务层和具体持久化技术就实现了解耦.提供DAO层的抽象可以带来一些好处,首先,我们可以很容易地构造模拟对象,方便单元测试的开展,其次在使用切面时,我们有更多的选择:既可以使用JDK动态代理也可以使用CGLib动态代理.Spring本质上希望以统一的方式整合底层的持久化技术:以统一的方式进行调用及事务管理,避免让具体的实现侵入到业务层的代码中.由于每个持久化实现技术都有各自的异常体系,所以Spring提供了统一的异常体系,使不同异常体系的阻抗得以弥消,方便定义出和具体实现技术无关的DAO接口,以及整合到相同的事务管理体系中. 图2 统一的异常体系 4. 统一的异常体系统一的异常体系是整合不同的持久化实现技术的关键,Spring提供了一套和实现技术无关的,面向于DAO层次语义的异常体系,并通过转换器将不同的持久化技术异常转换成Spring的异常. 4.1 Spring的DAO异常体系在很多正统API或框架中, 检查型异常被过多的使用, 以至在使用API时, 代码里充斥着大量的try/catch样板式的代码.在很多情况下, 除了在 try/catch中记录异常信息以外, 我们并没有做多少实质性的工作. 引发异常的问题往往是不可恢复的, 如数据连接失败, SQL语句存在语法错误, 强制捕捉的检查型异常除了限制开发人员的自由度以外, 并没有提供什么有意义的作用. 因此, Spring的异常体系都是建立在运行期异常的基础上, 开发者可以根据需要捕捉感兴趣的异常.JDK很多API之所以难用, 一个很大的原因就是检查型异常的泛滥, 如JavaMail, EJB以及JDBC等等, 使用这些API, 一堆堆异常处理的代码喧宾夺主式地侵入业务代码中, 破坏了代码的整洁和优雅.Spring在org.springframework.dao包中提供了一套完备优雅的DAO异常体系, 这些异常都继承于DataAccessException, 而DataAccessException本身又继承于 NestedRuntimeException,NestedRuntimeException异常以嵌套的方式封装了源异常.因为虽然不同持久化技术的特定异常被转换到Spring的DAO异常体系中, 原始的异常信息并不会丢失, 只要你愿意, 就可以方便地通过getCause()方法获取原始的异常信息.Spring的DAO异常体系并不和具体的实现技术相关,它从DAO概念的抽象层面定义了异常的目录树.在所有的持久化框架中,我们并没有发现拥有如此丰富语义异常体系的框架,Spring这种设计无疑是独具匠心的,它使得开发人员关注某一特定语义的异常变得容易.在JDBC中的SQLException 中,你必须通过异常的getErrorCode()或getSQLState()获取错误代码,直接根据这些代码判断是错误的类型,这种过于底层的API 不但带来了代码编写上的难度,而且也使代码的移植变得困难,因为getErrorCode()是数据库相关的.Spring以分类手法建立了异常分类目录,对于大部分应用来说,这个异常分类目录对异常类型的划分具有适当的颗粒度.一方面,使开发者从底层细如针麻的技术细节中脱身出来,另一方面,可以从这个语义丰富的异常体系中选择感兴趣的异常加以处理.上面图2中列出了那些位于Spring DAO异常体系第一层次的异常类,每个异常类下还可能拥有众多的子异常. 5. 参考链接Spring DAO层的设计思想&lt;&lt;精通Spring 4.x 企业应用开发实战&gt;&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring AOP]]></title>
    <url>%2F2018%2F11%2F16%2FSpring%20AOP%2F</url>
    <content type="text"><![CDATA[1. 前言本文是&lt;&lt;精通Spring 4.x 企业应用开发实战&gt;&gt;学习笔记, 以便自己查阅. 2. AOP 产生的背景“存在即合理”, 任何一种理论或技术的产生, 必然有它的原因. 了解它产生的背景, 为了解决的问题有助于我们更好地把握AOP的概念. 软件开发一直在寻求一种高效开发, 扩展, 维护的方式. 从面向过程的开发实践中, 前人将关注点抽象出来, 对行为和属性进行聚合, 形成了面向对象的开发思想, 其在一定程度上影响了软件开发的过程. 鉴于此, 我们在开发的过程中会对软件开发进行抽象, 分割成各个模块或对象. 例如, 我们会对API进行抽象成四个模块: Controller, Service, Gateway, Command. 这很好地解决了业务级别的开发, 但对于系统级别的开发我们很难聚焦. 比如, 对于每一个模块需要进行打日志, 代码监控, 异常处理. 以打日志为例, 我只能将日志代码嵌套在各个对象上, 而无法关注日志本身, 而这种现象又偏离了OOP思想. 为了能够更好地将系统级别的代码抽离出来, 去掉与对象的耦合, 就产生了面向AOP(面向切面). 如上图所示, OOP属于一种横向扩展, AOP是一种纵向扩展. AOP依托于OOP, 进一步将系统级别的代码抽象出来, 进行纵向排列, 实现低耦合. 3. AOP 的家庭成员3.1 PointCut即在哪个地方进行切入,它可以指定某一个点,也可以指定多个点.比如类A的methord函数,当然一般的AOP与语言(AOL)会采用多用方式来定义PointCut,比如说利用正则表达式,可以同时指定多个类的多个函数. 3.2 Advice在切入点干什么,指定在PointCut地方做什么事情(增强),打日志,执行缓存,处理异常等等. 3.3 Advisor/AspectPointCut + Advice 形成了切面Aspect,这个概念本身即代表切面的所有元素.但到这一地步并不是完整的,因为还不知道如何将切面植入到代码中,解决此问题的技术就是PROXY 3.4 ProxyProxy 即代理,其不能算做AOP的家庭成员,更相当于一个管理部门,它管理了AOP的如何融入OOP.之所以将其放在这里,是因为Aspect虽然是面向切面核心思想的重要组成部分,但其思想的践行者却是Proxy,也是实现AOP的难点与核心所在. 4. AOP的技术实现ProxyAOP仅仅是一种思想,那为了让这种思想发光,必然脱离语言本身的技术支持,Java在实现该技术时就是采用的代理Proxy,那我们就去了解一下,如何通过代理实现面向切面. 4.1 静态代理就像我们去买二手房要经过中介一样,房主将房源委托给中介,中介将房源推荐给买方.中间的任何手续的承办都由中介来处理,不需要我们和房主直接打交道.无论对买方还是卖房都都省了很多事情,但同时也要付出代价,对于买房当然是中介费,对于代码的话就是性能.下面我们来介绍实现AOP的三种代理方式.下面我就以买房的过程中需要打日志为例介绍三种代理方式静态和动态是由代理产生的时间段来决定的.静态代理产生于代码编译阶段,即一旦代码运行就不可变了.下面我们来看一个例子. 123public interface IPerson &#123; public void doSomething();&#125; 12345public class Person implements IPerson &#123; public void doSomething()&#123; System.out.println("I want wo sell this house"); &#125;&#125; 123456789101112131415161718public class PersonProxy &#123; private IPerson iPerson; private final static Logger logger = LoggerFactory.getLogger(PersonProxy.class); public PersonProxy(IPerson iPerson) &#123; this.iPerson = iPerson; &#125; public void doSomething() &#123; logger.info("Before Proxy"); iPerson.doSomething(); logger.info("After Proxy"); &#125; public static void main(String[] args) &#123; PersonProxy personProxy = new PersonProxy(new Person()); personProxy.doSomething(); &#125;&#125; 通过代理类我们实现了将日志代码集成到了目标类,但从上面我们可以看出它具有很大的局限性:需要固定的类编写接口(或许还可以接受,毕竟有提倡面向接口编程),需要实现接口的每一个函数(不可接受)同样会造成代码的大量重复,将会使代码更加混乱. 4.2 动态代理那能否通过实现一次代码即可将logger织入到所有函数中呢,答案当然是可以的,此时就要用到java中的反射机制. 1234567891011121314151617181920212223242526public class PersonProxy implements InvocationHandler&#123; private Object delegate; private final Logger logger = LoggerFactory.getLogger(this.getClass()); public Object bind(Object delegate) &#123; this.delegate = delegate; return Proxy.newProxyInstance(delegate.getClass().getClassLoader(), delegate.getClass().getInterfaces(), this); &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null; try &#123; logger.info("Before Proxy"); result = method.invoke(delegate, args); logger.info("After Proxy"); &#125; catch (Exception e) &#123; throw e; &#125; return result; &#125; public static void main(String[] args) &#123; PersonProxy personProxy = new PersonProxy(); IPerson iperson = (IPerson) personProxy.bind(new Person()); iperson.doSomething(); &#125;&#125; 它的好处理时可以为我们生成任何一个接口的代理类,并将需要增强的方法织入到任意目标函数.但它仍然具有一个局限性,就是只有实现了接口的类,才能为其实现代理. 4.3 CGLIBCGLIB解决了动态代理的难题,它通过生成目标类子类的方式来实现来实现代理,而不是接口,规避了接口的局限性.CGLIB是一个强大的高性能代码生成包,其在运行时期(非编译时期)生成被代理对象的子类,并重写了被代理对象的所有方法,从而作为代理对象. 12345678910111213141516171819public class PersonProxy implements MethodInterceptor &#123; private Object delegate; private final Logger logger = LoggerFactory.getLogger(this.getClass()); public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; logger.info("Before Proxy"); Object result = methodProxy.invokeSuper(method, args); logger.info("After Proxy"); return result; &#125; public static Person getProxyInstance() &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(Person.class); enhancer.setCallback(new PersonProxy()); return (Person) enhancer.create(); &#125;&#125; 当然CGLIB也具有局限性,对于无法生成子类的类(final类),肯定是没有办法生成代理子类的. 以上就是三种代理的实现方式,但千成别被迷惑了,在Spring AOP中这些东西已经被封装了,不需要我们自己实现.要不然得累死,但了解AOP的实现原理(即基于代理)还是很有必要的. 5. 参考链接Spring-aop 全面解析（从应用到原理）&lt;&lt;精通Spring 4.x 企业应用开发实战&gt;&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中Bean的作用域与生命周期]]></title>
    <url>%2F2018%2F11%2F15%2FSpring%E4%B8%ADBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[1. 前言本文是&lt;&lt;精通Spring 4.x 企业应用开发实战&gt;&gt;学习笔记, 以便自己查阅. 2. 概述在Spring中, 那些组成应用程序的主体及由Spring IoC容器所管理的对象, 被称之为Bean. 简单地讲, Bean就是由IoC容器初始化, 装配及管理的对象, 除此之外, Bean就与应用程序中的其他对象没有什么区别了. 而Bean的定义以及Bean相互间的依赖关系将通过配置元数据来描述. Spring中的bean默认都是单例的, 这些单例Bean在多线程程序下如何保证线程安全呢?例如对于Web应用来说, Web容器对于每个用户请求都创建一个单独的Sevlet线程来处理请求, 引入Spring框架之后, 每个Action都是单例的, 那么对于Spring托管的单例Service Bean, 如何保证其安全呢? Spring的单例是基于BeanFactory也就是Spring容器的, 单例Bean在此容器内只有一个, Java的单例是基于JVM, 每个JVM内只有一个实例. 3. Bean的作用域创建一个Bean定义, 其实质是用该bean定义对应的类来创建真正实例的”配方”. 把bean定义看成一个配方很有意义, 它与class很类似, 只根据一张”处方”就可以创建多个实例. 不仅可以控制注入到对象中的各种依赖和配置值, 还可以控制该对象的作用域. 这样可以灵活选择所建对象的作用域, 而不必在Java Class级定义作用域. Spring Framework支持五种作用域, 分别阐述如下表. 五种作用域中, request, session和global session三种作用域仅在基于web的应用中使用(不必关心你所采用的是什么web应用框架), 只能用在基于web的Spring ApplicationContext环境. 当一个bean的作用域为Singleton, 那么Spring IoC容器中只会存在一个共享的bean实例, 并且所有对bean的请求, 只要id与该bean定义相匹配, 则只会返回bean的同一实例. Singleton是单例类型, 就是在创建起容器时就同时自动创建了一个bean的对象, 不管你是否使用, 他都存在了, 每次获取到的对象都是同一个对象. 注意, Singleton作用域是Spring中的缺省作用域, 要在XML中将bean定义成singleton, 可以这样配置: 1&lt;bean id="ServiceImpl" class="cn.csdn.service.ServiceImpl" scope="singleton"&gt; 当一个bean的作用域为Prototype, 表示一个bean定义对应多个对象实例. Prototype作用域的bean会导致在每次对该bean请求(将其注入到另一个bean中, 或者以程序的方式调用容器的getBean()方法)时都会创建一个新的bean实例.Prototype是原型类型, 它在我们创建容器的时候并没有实例化, 而是当我们获取bean的时候才会去创建一个对象, 而且我们每次获取到的对象都不是同一个对象. 根据经验, 对有状态的bean应该使用prototype作用域, 而对无状态的bean则应该使用singleton作用域. 在XML中将bean定义成prototype, 可以这样配置: 123&lt;bean id="account" class="com.foo.DefaultAccount" scope="prototype"/&gt; 或者&lt;bean id="account" class="com.foo.DefaultAccount" singleton="false"/&gt; 当一个bean的作用域为Request, 表示在一次HTTP请求中, 一个bean定义对应一个实例; 即每个HTTP请求都会有各自的bean实例, 它们依据某个bean定义创建而成. 该作用域仅在基于web的Spring ApplicationContext情形下有效. 考虑下面bean定义: 1&lt;bean id="loginAction" class=cn.csdn.LoginAction" scope="request"/&gt; 针对每次HTTP请求, Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例, 且该loginAction bean实例仅在当前HTTP request内有效, 因此可以根据需要放心的更改所建实例的内部状态, 而其他请求中根据loginAction bean定义创建的实例, 将不会看到这些特定于某个请求的状态变化. 当处理请求结束, request作用域的bean实例将被销毁. 当一个bean的作用域为Session, 表示在一个HTTP Session中, 一个bean定义对应一个实例. 该作用域仅在基于web的Spring ApplicationContext情形下有效. 考虑下面bean定义： 1&lt;bean id="userPreferences" class="com.foo.UserPreferences" scope="session"/&gt; 针对某个HTTP Session, Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例, 且该userPreferences bean仅在当前HTTP Session内有效. 与request作用域一样, 可以根据需要放心的更改所创建实例的内部状态, 而别的HTTP Session中根据userPreferences创建的实例, 将不会看到这些特定于某个HTTP Session的状态变化. 当HTTP Session最终被废弃的时候, 在该HTTP Session作用域内的bean也会被废弃掉. 当一个bean的作用域为Global Session, 表示在一个全局的HTTP Session中, 一个bean定义对应一个实例. 典型情况下, 仅在使用portlet context的时候有效. 该作用域仅在基于web的Spring ApplicationContext情形下有效. 考虑下面bean定义: 1&lt;bean id="user" class="com.foo.Preferences "scope="globalSession"/&gt; global session作用域类似于标准的HTTP Session作用域, 不过仅仅在基于portlet的web应用中才有意义. Portlet规范定义了全局Session的概念, 它被所有构成某个portlet web应用的各种不同的portlet所共享. 在global session作用域中定义的bean被限定于全局portlet Session的生命周期范围内. 4. bean的生命周期Spring中bean的实例化过程 与上图类似,bean的生命周期流程图 Bean实例生命周期的执行过程如下:Spring对bean进行实例化,默认bean是单例;Spring对bean进行依赖注入;如果bean实现了BeanNameAware接口,spring将bean的id传给setBeanName()方法;;如果bean实现了BeanFactoryAware接口,spring将调用setBeanFactory方法,将BeanFactory实例传进来;如果bean实现了ApplicationContextAware接口,它的setApplicationContext()方法将被调用,将应用上下文的引用传入到bean中;如果bean实现了BeanPostProcessor接口,它的postProcessBeforeInitialization方法将被调用;如果bean实现了InitializingBean接口,spring将调用它的afterPropertiesSet接口方法,类似的如果bean使用了init-method属性声明了初始化方法,该方法也会被调用;如果bean实现了BeanPostProcessor接口,它的postProcessAfterInitialization接口方法将被调用;此时bean已经准备就绪,可以被应用程序使用了,他们将一直驻留在应用上下文中,直到该应用上下文被销毁;若bean实现了DisposableBean接口,spring将调用它的distroy()接口方法.同样的,如果bean使用了destroy-method属性声明了销毁方法,则该方法被调用; 5. 不同作用域下的bean的生命周期细节如果bean的scope设为prototype时, 当容器关闭时, destroy方法不会被调用. 对于prototype作用域的bean, 有一点非常重要, 那就是Spring不能对一个prototype bean的整个生命周期负责:容器在初始化,配置,装饰或者是装配完一个prototype实例后, 将它交给客户端, 随后就对该prototype实例不闻不问了. 不管何种作用域, 容器都会调用所有对象的初始化生命周期回调方法. 但对prototype而言, 任何配置好的析构生命周期回调方法都将不会被调用. 清除prototype作用域的对象并释放任何prototype bean所持有的昂贵资源, 都是客户端代码的职责(让Spring容器释放被prototype作用域bean占用资源的一种可行方式是, 通过使用bean的后置处理器, 该处理器持有要被清除的bean的引用).谈及prototype作用域的bean时, 在某些方面你可以将Spring容器的角色看作是Java new操作的替代者, 任何迟于该时间点的生命周期事宜都得交由客户端来处理. Spring容器可以管理singleton作用域下bean的生命周期,在此作用域下,Spring能够精确地知道bean何时被创建,何时初始化完成,以及何时被销毁.而对于prototype作用域的bean,Spring只负责创建,当容器创建了bean的实例后,bean的实例就交给了客户端的代码管理,Spring容器将不再跟踪其生命周期,并且不会管理那些被配置成prototype作用域的bean的生命周期. 6. 参考链接Spring中bean的作用域与生命周期&lt;&lt;精通Spring 4.x 企业应用开发实战&gt;&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IoC容器]]></title>
    <url>%2F2018%2F11%2F15%2FSpring%20IoC%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. 前言本文是&lt;&lt;精通Spring 4.x 企业应用开发实战&gt;&gt;学习笔记, 以便自己查阅. 2. IoC容器的概念IoC容器就是具有依赖注入功能的容器, IoC容器负责实例化, 定位, 配置应用程序中的对象及建立这些对象间的依赖. 应用程序无需直接在代码中new相关的对象, 应用程序由IoC容器进行组装. 在Spring中BeanFactory是IoC容器的实际代表者. Spring IoC容器如何知道哪些是它管理的对象呢? 这就需要配置文件, Spring IoC容器通过读取配置文件中的配置元数据, 通过元数据对应用中的各个对象进行实例化及装配. 一般使用基于xml配置文件进行配置元数据, 而且Spring与配置文件完全解耦的, 可以使用其他任何可能的方式进行配置元数据, 比如注解, 基于java文件的, 基于属性文件的配置都可以. 那Spring IoC容器管理的对象叫什么呢? 3. Bean的概念由IoC容器管理的那些组成你应用程序的对象我们就叫它Bean, Bean就是由Spring容器初始化,装配及管理的对象, 除此之外, bean就与应用程序中的其他对象没有什么区别了. 那IoC怎样确定如何实例化Bean, 管理Bean之间的依赖关系以及管理Bean呢? 这就需要配置元数据. 4. 详解IoC容器在Spring Ioc容器的代表就是org.springframework.beans包中的BeanFactory接口, BeanFactory接口提供了IoC容器最基本功能; 而org.springframework.context包下的ApplicationContext接口扩展了BeanFactory, 还提供了与Spring AOP集成, 国际化处理, 事件传播及提供不同层次的context实现 (如针对web应用的WebApplicationContext). 简单说, BeanFactory提供了IoC容器最基本功能, 而 ApplicationContext 则增加了更多支持企业级功能支持. ApplicationContext完全继承BeanFactory, 因而BeanFactory所具有的语义也适用于ApplicationContext. 让我们来看下IoC容器到底是如何工作. 在此我们以xml配置方式来分析一下: 准备配置文件: 在配置文件中声明Bean定义也就是为Bean配置元数据. 由IoC容器进行解析元数据: IoC容器的Bean Reader读取并解析配置文件, 根据定义生成BeanDefinition配置元数据对象, IoC容器根据BeanDefinition进行实例化, 配置及组装Bean. 实例化IoC容器: 由客户端实例化容器, 获取需要的Bean. 执行过程如图. 5. 参考链接【第二章】 IoC 之 2.2 IoC 容器基本原理 ——跟我学Spring3&lt;&lt;精通Spring 4.x 企业应用开发实战&gt;&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IoC和DI]]></title>
    <url>%2F2018%2F11%2F15%2FSpring%20IoC%E5%92%8CDI%2F</url>
    <content type="text"><![CDATA[1. 前言本文是&lt;&lt;精通Spring 4.x 企业应用开发实战&gt;&gt;学习笔记, 以便自己查阅. 2. IoC是什么IoC—Inversion of Control, 即”控制反转”, 不是什么技术, 而是一种设计思想. 在Java开发中, Ioc意味着将你设计好的对象交给容器控制, 而不是传统的在你的对象内部直接控制. 如何理解好Ioc呢? 理解好Ioc的关键是要明确”谁控制谁, 控制什么, 为何是反转(有反转就应该有正转了), 哪些方面反转了”. 2.1 谁控制谁,控制什么传统Java SE程序设计, 我们直接在对象内部通过new进行创建对象, 是程序主动去创建依赖对象; 而IoC是有专门一个容器来创建这些对象, 即由Ioc容器来控制对象的创建; 谁控制谁?当然是IoC 容器控制了对象; 控制什么? 那就是主要控制了外部资源获取(不只是对象包括比如文件等). 2.2 为何是反转,哪些方面反转了有反转就有正转, 传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象, 也就是正转; 而反转则是由容器来帮忙创建及注入依赖对象; 为何是反转? 因为由容器帮我们查找及注入依赖对象, 对象只是被动的接受依赖对象, 所以是反转; 哪些方面反转了? 依赖对象的获取被反转了. 用图例说明一下,传统程序设计如图,都是主动去创建相关对象然后再组合起来: 当有了IoC/DI的容器后, 在客户端类中不再主动去创建这些对象了, 如图所示: 3. IoC能做什么IoC不是一种技术, 只是一种思想, 一个重要的面向对象编程的法则, 它能指导我们如何设计出松耦合, 更优良的程序. 传统应用程序都是由我们在类内部主动创建依赖对象, 从而导致类与类之间高耦合, 难于测试; 有了IoC容器后, 把创建和查找依赖对象的控制权交给了容器, 由容器进行注入组合对象, 所以对象与对象之间是松散耦合, 这样也方便测试, 利于功能复用, 更重要的是使得程序的整个体系结构变得非常灵活.其实IoC对编程带来的最大改变不是从代码上, 而是从思想上, 发生了”主从换位”的变化. 应用程序原本是老大, 要获取什么资源都是主动出击, 但是在IoC/DI思想中, 应用程序就变成被动的了, 被动的等待IoC容器来创建并注入它所需要的资源了.IoC很好的体现了面向对象设计法则之一:好莱坞法则:”别找我们,我们找你”; 即由IoC容器帮对象找相应的依赖对象并注入, 而不是由对象主动去找. 4. IoC和DIDI–Dependency Injection, 即”依赖注入”:是组件之间依赖关系由容器在运行期决定, 形象的说, 即由容器动态的将某个依赖关系注入到组件之中. 依赖注入的目的并非为软件系统带来更多功能, 而是为了提升组件重用的频率, 并为系统搭建一个灵活, 可扩展的平台. 通过依赖注入机制, 我们只需要通过简单的配置, 而无需任何代码就可指定目标需要的资源, 完成自身的业务逻辑, 而不需要关心具体的资源来自何处, 由谁实现. 理解DI的关键是:”谁依赖谁,为什么需要依赖,谁注入谁,注入了什么”, 那我们来深入分析一下: 谁依赖于谁: 当然是应用程序依赖于IoC容器; 为什么需要依赖:应用程序需要IoC容器来提供对象需要的外部资源; 谁注入谁: 很明显是IoC容器注入应用程序某个对象, 应用程序依赖的对象; 注入了什么: 就是注入某个对象所需要的外部资源(包括对象,资源,常量数据). IoC和DI由什么关系呢?其实它们是同一个概念的不同角度描述, 由于控制反转概念比较含糊(可能只是理解为容器控制对象这一个层面,很难让人想到谁来维护对象关系), 所以2004年大师级人物Martin Fowler又给出了一个新的名字:”依赖注入”, 相对IoC 而言, “依赖注入” 明确描述了”被注入对象依赖IoC容器配置依赖对象”. 5. 参考链接【第二章】 IoC 之 2.1 IoC基础 ——跟我学Spring3&lt;&lt;精通Spring 4.x 企业应用开发实战&gt;&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven实战(五)--聚合和继承]]></title>
    <url>%2F2018%2F10%2F12%2FMaven%E5%AE%9E%E6%88%98(%E4%BA%94)--%E8%81%9A%E5%90%88%E5%92%8C%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[1. 前言Java开发过程中, 使用Maven管理依赖. 这是Maven系列文章, 主要记录&lt;&lt;Maven实战&gt;&gt;的学习过程和一些重要知识点, 以方便自己查阅. 2. 基本概述Maven的聚合特性能够把项目的各个模块聚合在一起构建, 而继承特性则能够帮助抽取各模块相同的依赖和插件等配置, 在简化POM的同时, 还能促进各个模块配置的一致性. 3. 聚合Maven聚合也称多模块, 能够一次构建多个模块. 聚合模块本身是一个Maven项目, 所以也有自己的POM文件, 该POM文件的packaging为pom, 并且含有modules和module元素. 123456789101112131415&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.glennlgan&lt;/groupId&gt; &lt;artifactId&gt;springboot.demo&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;springboot-mybatis&lt;/module&gt; &lt;module&gt;springboot-web&lt;/module&gt; &lt;module&gt;springboot-quickstart&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 这里每个module的值都是一个当前POM的相对目录, 一般而言, 为了方便快速定位内容, 模块所处的目录名称应该与其artifactId一致, 不过这不是Maven的要求. 因此, 聚合模块与其他模块的目录结构并非一定要父子关系, 通过修改module的值, 也能更改为平级关系: 1&lt;module&gt;../springboot-quickstart&lt;/module&gt; Maven首先会解析聚合模块的POM, 分析要构建的模块, 并计算出一个反应堆构建顺序, 然后根据这个顺序依次构建各个模块. 反应堆包含了模块之间继承和依赖的关系. 模块间的依赖关系会将反应堆构成一个有向非循环图. 4. 继承继承解决的是对重复依赖和插件配置的抽取. 通过定义一个父模块, 将其他模块相同的配置抽离到父模块中, 然后继承父模块, 并且父模块也是一个Maven项目, 其POM文件的packaging为pom. 子模块需要增加parent元素配置: 123456&lt;parent&gt; &lt;artifactId&gt;springboot.demo&lt;/artifactId&gt; &lt;groupId&gt;com.glennlgan&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt;&lt;/parent&gt; relativePath定义了父模块POM文件的位置. 默认值为../pom.xml, Maven默认父POM在上一层目录下. POM文件可被继承的元素有: 12345678910111213141516171819groupId:项目组ID,项目坐标的核心元素version:项目版本,项目坐标的核心元素description:项目的描述信息organization:项目所在组织机构信息inceptionYear:项目的创始年份url:项目的URL地址developers:项目的开发者信息contributors:项目的贡献者信息distributionManagement:项目的部署配置issueManagement:项目的缺陷跟着系统信息ciManagement:项目的持续集成系统信息scm:项目的版本控制系统信息mailingLists:项目的邮件列表信息properties:自定义的Maven属性dependencies:项目的依赖配置dependencyManagement:项目的依赖管理配置repositories:项目的仓库配置build:项目的源码目录配置,输出目录配置,插件配置,插件配置管理等reporting:项目的报告输出目录配置,报告插件配置等 5. 依赖管理子模块继承父模块时, 也会继承父模块的依赖配置, 假设添加一个util的子模块, 该模块只提供一些简单的帮助工具, 与springframework完全无关, 难道也让它依赖spring-core,spring-beans,spring-context么?这显然是不合理的. Maven提供的dependencyManagement元素既能让子模块继承父模块的依赖配置, 又能保证子模块依赖使用的灵活性. 在dependencyManagement元素下声明的依赖不会引入实际的依赖, 不过它能够约束dependencies下的依赖使用. 在父POM使用dependencyManagement声明的依赖能够统一项目范围中依赖的版本, 在子模块使用依赖的时候就不需要版本了, 只需要简单的配置groupId和artifactId就能获得对应的依赖信息, 从而引进正确的依赖. 如果子模块不声明依赖的使用, 即使该依赖已经在父POM的dependencyManagement中声明了, 也不会产生实际的效果. 如, 在父POM定义如下dependencyManagement: 123456789&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.14.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在子模块使用时, 只需要: 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;&lt;/dependency&gt; 对于子模块而言, 可以按需添加依赖, 对于整个项目而言, 可以规范对依赖的版本号管理. 6. 参考链接&lt;&lt;Maven实战&gt;&gt;(许晓斌)]]></content>
      <categories>
        <category>Maven基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven实战(四)--生命周期和插件]]></title>
    <url>%2F2018%2F10%2F12%2FMaven%E5%AE%9E%E6%88%98(%E5%9B%9B)--%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1. 前言Java开发过程中, 使用Maven管理依赖. 这是Maven系列文章, 主要记录&lt;&lt;Maven实战&gt;&gt;的学习过程和一些重要知识点, 以方便自己查阅. 2. 生命周期概述Maven的生命周期是对所有构建过程的抽象和统一. 包含了项目的清理, 初始化, 编译, 测试, 打包, 集成测试, 验证, 部署和站点生成等几乎所有构建步骤. Maven的生命周期是抽象的, 其实际行为是由插件来完成的, 生命周期和插件两者协同合作, 密不可分. 这种思想与设计模式中的模板方法非常相似. 模板方法模式在父类定义算法的整体结构, 子类通过实现或者重写父类的方法来控制实际行为, 这样既能保证算法有足够的可扩展性, 又能严格控制算法的整体结构. 3. 生命周期详解Maven拥有3套独立的生命周期:clean, default, site. clean生命周期的目的是清理项目. default生命周期的目的是构建项目. site生命周期的目的是建立项目站点. 每个生命周期包含一些阶段(phase), 这些阶段是有序的, 后面的阶段会依赖于前面的阶段. 3.1 clean生命周期clean生命周期的3个阶段: pre-clean:执行一些清理前需要完成的动作 clean:清理上一次构建生成的文件 post-clean:执行一些清理后需要完成的动作 3.2 default生命周期 validate initialize generate-sources process-sources 处理项目主资源文件, 一般来说. 是对src/main/resources目录的内容进行变量替换等工作, 复制到项目输出的主classpath目录中. generate-resources process-resources compile 编译项目的主源码到主classpath目录中. process-classes generate-test-sources process-test-sources 处理项目测试资源文件, 一般来说, 是对src/test/resources目录的内容进行变量替换等工作, 复制到项目输出的测试classpath目录中. generate-test-resources process-test-resources test-compile编译项目的测试源码到测试classpath目录中. process-test-classes test使用单元测试框架进行测试, 测试代码不会被打包或部署 prepare-package package 将编译好的代码, 打包成可发布的格式, 如jar pre-integration-test integration-test post-integration-test verify install 将包安装到Maven本地仓库, 供本地其他Maven项目使用 deploy 将最终的包复制到远程仓库, 供其他开发人员和Maven项目使用 3.3 site生命周期site生命周期的目的是建立和发布项目站点, Maven能够基于POM所包含的信息, 自动生成一个友好的站点, 方便团队交流和发布项目信息, 含如下阶段: pre-site 执行一些在生成项目站点之前需要完成的工作 site 生成项目站点文档 post-site 执行一些在生成项目站点之后需要完成的工作 site-deploy 将生成的项目站点发布到服务器上 4. 插件目标对于一个插件, 为了复用代码, 它往往能够完成多个任务, 例如maven-dependency-plugin, 能够分析项目依赖; 列出项目依赖树; 列出项目已解析的依赖, 为这样每个功能独立编写一个插件, 显然是不可取的, 因为这些功能背后有相同的代码, 因此将这些功能聚集在一个插件里, 每个功能就是一个插件目标. 5. 插件绑定Maven的生命周期与插件相互绑定, 用于完成实际的构建任务, 具体而言, 是生命周期的阶段与插件的目标相互绑定, 以完成某个具体的构建任务. 5.1 内置绑定下面是一些内置的绑定: 5.2 自定义绑定除了内置绑定外, 用户能够自己选择将某个插件目标绑定到生命周期的某个阶段上, 以便在项目构建过程中执行更丰富的任务. 1234567891011121314&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-source&lt;/id&gt; &lt;phase&gt;verify&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 除了基本的插件坐标配置, executions元素下的每个execution元素用来配置执行一个任务. 有时候, 即使不配置phase阶段, 插件目标也能绑定到生命周期中去, 这是因为很多插件的目标在编写时已经定义了默认的绑定阶段, 可以通过maven-help-plugin查看插件的详细信息:mvn help:describe –Dplugin=org.apache.maven.plugins:maven-source-plugin:2.1.1 -Ddetail 如果多个目标被绑定到同一个阶段, 它们的执行顺序会是怎样?这些插件声明的先后顺序决定了目标的执行顺序. 6. 插件解析机制为了方便用户使用和配置插件, Maven不需要用户提供完整的插件坐标信息, 就可以解析得到正确的插件. 与依赖构件一样, 插件构件同样基于坐标存储在Maven仓库中, 但Maven会区别对待依赖的远程仓库与插件的远程仓库. 通过repositories及其子元素repository可以配置依赖的远程仓库;插件的远程仓库需要使用pluginRepositories和pluginRepository进行配置. 1234567891011121314&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven plugin&lt;/name&gt; &lt;url&gt;htpp://repo1.maven.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/pluginRepository&gt;&lt;/pluginRepositories&gt; 默认情况下, 如果该插件是Maven官方插件, 则可以省略groupId(org.apache.maven.plugins), Maven在解析该插件的时候, 会自动将groupId补上. 当插件没有添加版本号时, 若该插件是核心插件, 则在超级POM已经定义了版本号, 若不是核心插件, Maven会遍历本地仓库和远程仓库, 计算出latest和release的值, Maven 2使用latest, 但因为latest可能是快照版本, Maven 3更改为使用release. 7. 参考链接&lt;&lt;Maven实战&gt;&gt;(许晓斌)]]></content>
      <categories>
        <category>Maven基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven实战(三)--Maven仓库]]></title>
    <url>%2F2018%2F10%2F12%2FMaven%E5%AE%9E%E6%88%98(%E4%B8%89)--Maven%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[1. 前言Java开发过程中, 使用Maven管理依赖. 这是Maven系列文章, 主要记录&lt;&lt;Maven实战&gt;&gt;的学习过程和一些重要知识点, 以方便自己查阅. 2. 仓库概述Maven坐标是一个构件的逻辑表示, 构件的物理表示是文件, Maven通过仓库来统一管理这些文件. 得益于坐标机制, Maven项目能够以统一的方式来使用任何构件, 在此基础上, Maven可以在某个位置统一存储所有Maven项目共享的构建, 这个统一位置就是仓库. 3. 仓库分类Maven中的仓库分为: 本地仓库和远程仓库. Maven根据坐标寻找构件时, 先查看本地仓库是否存在该构件, 存在则直接使用; 否则就查找远程仓库, 找到之后就下载到本地仓库; 本地和远程都没找到, 直接报错. 中央仓库是Maven核心自带的远程仓库, 含绝大多数开源的构件; 私服是在局域网搭建的仓库服务器, 用于代理外部的远程仓库, 可以节省带宽和时间, 内部的项目还能部署到私服供其他项目使用; 使用私服可以加速Maven构建以及提高稳定性, 内网访问不需要依赖于网络. 其他公共服, 如阿里云等. 本地仓库: 通过修改settings.xml来配置, 默认是${user.home}/.m2/repository. 12345&lt;!-- localRepository | The path to the local repository maven will use to store artifacts | Default: $&#123;user.home&#125;/.m2/repository&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;--&gt; 构件进入本地仓库有两种方式: Maven从远程仓库下载到本地仓库; 通过在项目执行mvn install安装到本地. 对Maven而言, 用户的本地仓库只有一个, 但可以配置访问很多远程仓库. 而中央仓库是默认的远程仓库, 在$M2_HOME/lib/maven-model-builder-{version}.jar的org/apache/maven/model/pom-4.0.0.xml文件定义了, 该POM也被称为超级POM. 4. 仓库的布局构件在Maven仓库里的存储路径为:{groupId}/{artifactId}/{version}/{artifactId-version.packaging} 5. 远程仓库的配置通过POM文件可以配置远程仓库. 1234567891011121314&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jboss&lt;/id&gt; &lt;name&gt;jboss repository&lt;/name&gt; &lt;url&gt;http://repository.jboss.com/maven2/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt;&lt;/repositories&gt; 仓库id必须唯一!!!不唯一则会覆盖!!!release的enable值为true表示开启JBoss仓库的发布版本下载支持.snapshots的enable值为false表示关闭JBoos仓库的快照版本下载支持.layout元素值为default,表示仓库的布局是Maven2和Maven3的默认布局, 而不是Maven1的布局. 对于release和snapshot来说, 除了enable, 它们还包括另外两个子元素updatePolicy和checksumPolicy. 12345&lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;daily&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;ignore&lt;/checksumPolicy&gt;&lt;/snapshots&gt; updatePolicy配置Maven从远程仓库检查更新的频率,默认是daily.checksumPolicy配置Maven检查检验和文件的策略. 5.1 远程仓库认证通过修改settings.xml配置远程仓库认证. 123456789101112&lt;settings&gt; ... &lt;!--配置远程仓库认证信息--&gt; &lt;servers&gt; &lt;server&gt; &lt;id&gt;jboss&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; ...&lt;/settings&gt; 6. 部署构件至远程仓库123456789101112&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt; &lt;name&gt;public&lt;/name&gt; &lt;url&gt;http://127.0.0.1:8081/nexus/content/repositories/releases&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;name&gt;Snapshots&lt;/name&gt; &lt;url&gt;http://127.0.0.1:8081/nexus/content/repositories/snapshots&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; distributionManagement包含repository和snapshotRepository子元素, 前者表示发布版本(稳定版本)构件的仓库,后者表示快照版本(开发测试版本)的仓库. 这两个元素都需要配置id, name和url, id为远程仓库的唯一标识, name是为了方便人阅读, 关键的url表示该仓库的地址. 往远程仓库部署构件的时候, 往往需要认证, 配置认证的方式同上. 配置正确后, 运行命令mvn clean deploy, Maven就会将项目构建输出的构件部署到配置对应的远程仓库, 如果项目当前的版本是快照版本, 则部署到快照版本的仓库地址, 否则就部署到发布版本的仓库地址. Maven会根据模块的版本号(pom文件中的version)中是否带有-SNAPSHOT来判断是快照版本还是正式版本. 7. 从仓库解析依赖的机制当本地仓库没有依赖构件的时候, maven会自动从远程仓库下载; 当依赖版本为快照版本的时候Maven会自动找到最新的快照. 这背后的依赖解析机制可以概括如下: 当依赖的范围是system的时候Maven直接从本地文件系统解析构件. 根据依赖坐标计算仓库路径后, 尝试直接从本地仓库寻找构件, 如果发现相应构件则解析成功. 在本地仓库不存在相应构件的情况下, 如果依赖的版本显示的发布版本构件, 如1.2,2.1-beta-1等, 则遍历所有的远程仓库, 发现后下载并解析使用. 如果依赖的版本是RELEASE或者LATEST, 则基于更新策略读取所有远程仓库的元数据groupId/artifactId/maven-metadata.xml,将其与本地仓库对应元数据合并后计算出RELEASE或者LATEST真实的值, 然后基于这个真实的值检查本地和远程仓库如步骤2和3. 如果依赖的版本是SNAPSHOT, 则基于更新策略读取所有远程仓库的元数据groupId/artifactId/version/maven-metadata.xml, 将其与本地仓库对应元数据合并后得到最新快照版本的值, 然后基于该值检查本地仓库或者从远程仓库下载. 如果最后解析得到的构件版本时间是时间戳格式的快照, 如1.4.1-20091104.121450-121, 则复制其时间戳格式的文件至非时间戳格式, 如SNAPSHOT, 并使用该非时间戳格式的构件. 8. 镜像如果仓库X可以提供仓库Y存储的所有内容, 那么就可以认为X是Y的一个镜像. 换句话说, 任何一个可以从仓库Y获得的构件, 都能够从它的镜像中获取. 举个例子, http://maven.oschina.net/content/groups/public/ 是中央仓库http://repo1.maven.org/maven2/ 在中国的镜像, 由于地理位置的因素, 该镜像往往能够提供比中央仓库更快的服务. 因此, 可以配置Maven使用该镜像来替代中央仓库, 编辑settings.xml, 代码如下: 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;maven.oschina.net&lt;/id&gt; &lt;name&gt;maven mirror in China&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 该例中, mirrorOf的值为central, 表示该配置为中央仓库的镜像, 任何对于中央仓库的请求都会转至该镜像, 用户也可以使用同样的方法配置其他仓库的镜像.id表示镜像的唯一标识符, name表示镜像的名称, url表示镜像的地址. 关于镜像的一个更为常见的用法是结合私服. 由于私服可以代理任何外部的公共仓库(包括中央仓库), 因此, 对于组织内部的Maven用户来说, 使用一个私服地址就等于使用了所有需要的外部仓库, 这可以将配置集中到私服, 从而简化Maven本身的配置. 在这种情况下, 任何需要的构件都可以从私服获得, 私服就是所有仓库的镜像. 这时, 可以配置这样的一个镜像: 123456789&lt;!--配置私服镜像--&gt;&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;internal nexus repository&lt;/name&gt; &lt;url&gt;http://192.168.0.1:8081/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 8.1 特别强调需要注意的是, 由于镜像仓库完全屏蔽了被镜像仓库, 当镜像仓库不稳定或者停止服务的时候, Maven仍将无法访问被镜像仓库, 因而将无法下载构件. 9. 参考链接&lt;&lt;Maven实战&gt;&gt;(许晓斌)]]></content>
      <categories>
        <category>Maven基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven实战(二)--Maven坐标和依赖]]></title>
    <url>%2F2018%2F10%2F11%2FMaven%E5%AE%9E%E6%88%98(%E4%BA%8C)--Maven%E5%9D%90%E6%A0%87%E5%92%8C%E4%BE%9D%E8%B5%96%2F</url>
    <content type="text"><![CDATA[1. 前言Java开发过程中, 使用Maven管理依赖. 这是Maven系列文章, 主要记录&lt;&lt;Maven实战&gt;&gt;的学习过程和一些重要知识点, 以方便自己查阅. 2. 坐标详解1234&lt;groupId&gt;com.hust.schedule&lt;/groupId&gt;&lt;artifactId&gt;schedule-calculation&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt; groupId: 定义当前Maven项目隶属的实际项目, 比如com.hust.schedule就是指华中科技大学的一个schedule项目. artifactId: 该元素定义实际项目中的一个Maven项目(模块), 比如schedule-calculation就是schedule项目中的calculation模块. artifactId的规范的做法是使用项目名作为前缀,模块名作为后缀, 用-分割. version: 定义Maven项目当前所处的版本. packaging: 定义Maven项目的打包方式. 3. 依赖配置123456789101112131415&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;...&lt;/groupId&gt; &lt;artifactId&gt;...&lt;/artifactId&gt; &lt;version&gt;...&lt;/version&gt; &lt;type&gt;...&lt;/type&gt; &lt;scope&gt;...&lt;/scope&gt; &lt;optional&gt;...&lt;/optional&gt; &lt;exclusions&gt; &lt;exclusion&gt; ... &lt;exclusion&gt; &lt;exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; groupId, artifactId, version: 作为依赖的基本坐标, 用于定位依赖type: 依赖的类型, 对应于packaging, 默认为jarscope: 依赖的范围optional: 标记依赖是否可选exclusions: 用来排除传递性依赖 4. 依赖范围 Maven在编译项目主代码的时候需要使用一套classpath; Maven在编译和执行测试的时候, 会使用另外一套classpath. 实际运行Maven项目的时候, 又会使用一套classpath. 依赖范围就是用来控制依赖与这三种classpath(编译classpath, 测试classpath, 运行classpath)的关系. 依赖的范围通过scope指定. 4.1 Maven依赖范围compile: 编译依赖范围, 默认值. 使用此依赖范围的依赖对于编译, 测试, 运行三种classpath都有效.test: 测试依赖范围, 使用此依赖范围的依赖只对于测试classpath有效. 典型的就是Junit依赖一般声明为测试依赖范围.provided: 已提供依赖范围, 使用此依赖范围的依赖, 对于编译和测试classpath有效, 但在运行时无效, 典型的例子是servlet-api, 编译和测试的时候需要, 但运行时由容器提供.runtime: 运行时依赖范围, 使用此依赖范围的依赖, 对于测试和运行classpath有效, 但在编译主代码是无效. 典型的例子是JDBC驱动实现, 项目主代码的编译仅需要JDK的JDBC接口, 只有在测试和运行时才需要实现.system: 系统依赖范围, 该依赖与三种classpath的关系与provided依赖范围完全一致, 但是使用system依赖范围的依赖必须通过systemPath元素显式的指定依赖文件的路径.由于此类依赖不是通过Maven仓库解析, 而且往往与本机系统绑定, 因此需要谨慎使用. 比如 1234567&lt;dependency&gt; &lt;groupId&gt;javax.sql&lt;/groupId&gt; &lt;artifactId&gt;jdbc-stdext&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;java.home&#125;/lib/rt.jar&lt;/systemPath&gt;&lt;/dependency&gt; import: 导入依赖范围, 该依赖范围不会对三种classpath产生实际影响. 这里具体看依赖管理. 5. 传递性依赖Maven的传递性依赖是指不需要考虑你依赖的库文件所需要依赖的库文件, 能够将依赖模块的依赖自动的引入. 依赖的范围不仅可以控制依赖与三种classpath的关系, 还会对传递性依赖产生影响. 假设A依赖于B, B依赖于C, 则说A对于B是第一直接依赖, B对C是第二直接依赖, A对于C是传递依赖. 第一直接依赖范围和第二直接依赖范围决定了传递性依赖的范围, 其结果如下: 6. 依赖调解一般情况下, 只关心项目的直接依赖, 而不关心直接依赖引入的传递性依赖, 但当传递性依赖出现问题时, 需要知道该传递性依赖是怎么引进来的. Maven依赖调解第一原则: 路径最近者优先, 如：A-&gt;B-&gt;C-&gt;X(1.0), A-&gt;D-X(2.0), 则X的2.0版本会被解析使用;Maven依赖调解第二原则: 第一声明者优先, 如: A-&gt;B-&gt;X(1.0)、A-&gt;D-&gt;X(2.0), 若B的依赖声明在D之前, 则使用X的1.0版本, 否则使用X的2.0版本. 7. 可选依赖假设有下面的依赖关系:A-&gt;B、B-&gt;X(可选), B-&gt;Y(可选), 由于X和Y是可选的, 所以依赖不会传递, X和Y不会对A有任何影响. 可选依赖的必要性:项目B实现2种特性, 特性一依赖于X, 特性二依赖于Y, 而且这两个特性是互斥的, 用户不可能同时适用这两个特性, 这时候可选依赖就有用了. 原则上说, 是不应该使用可选依赖的, 根据面向对象的单一职责性原则, 该原则同样适用于Maven项目的规划. 8. 最佳实践8.1 排除依赖传递性依赖会给项目隐式的引入很多依赖, 这极大的简化了项目依赖的管理, 但是有时某些依赖会带来问题, 这时需要把带来问题的依赖排除掉. 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.cc.maven&lt;/groupId&gt; &lt;artifactId&gt;project-b&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.cc.maven&lt;/groupId&gt; &lt;artifactId&gt;project-c&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 8.2 归类依赖来自同一个项目的不同模块, 其版本号应该是相同的, 如springframework项目有spring-core、spring-beans模块, 对这些模块的版本号通过属性定义, 再进行引用, 这样可以进行版本的整体升级: 123456789101112131415&lt;properties&gt; &lt;springframework.version&gt;4.3.13.RELEASE&lt;/springframework.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 8.3 优化依赖去掉多余的依赖, 显示声明某些必要的依赖.通过mvn dependency:list 查看项目已解析的依赖通过mvn dependency:tree 查看项目的依赖树通过mvn dependency:analyze工具可以帮助分析当前项目的依赖 9. 参考链接&lt;&lt;Maven实战&gt;&gt;(许晓斌)Maven的排除依赖、归类依赖、优化依赖Maven实战读书笔记（三）：Maven依赖]]></content>
      <categories>
        <category>Maven基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven实战(一)--Maven配置和使用]]></title>
    <url>%2F2018%2F10%2F11%2FMaven%E5%AE%9E%E6%88%98(%E4%B8%80)--Maven%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 前言Java开发过程中, 使用Maven管理依赖. 这是Maven系列文章, 主要记录&lt;&lt;Maven实战&gt;&gt;的学习过程和一些重要知识点, 以方便自己查阅. 2. Maven的安装基于Windows 10系统安装和配置Maven. 安装JDK JDK的安装不做过多赘述. 下载Maven link: http://maven.apache.org/download.cgi 配置环境变量 解压并配置环境变量.新建环境变量M2_HOME, 值为Maven安装目录, 比如, 我的安装目录是D:\Software\Maven\apache-maven-3.5.4在环境变量Path里面添加新的值, %M2_HOME%\bin 测试配置 在命令行输入mvn -v 版本升级 解压并修改M2_HOME的值即可. 3. ~/.m2目录解读~是指代用户目录. 比如windows 10下, 我的~目录就是C:\Users\ganlu ~/.m2/repository是仓库位置 一般情况下, 需要复制M2_HOME/conf/settings.xml文件到~/.m2目录下, 作为当前用户的Maven配置文件 4. 设置HTTP代理修改settings.xml文件 12345678910111213141516&lt;settings&gt; ... &lt;proxies&gt; &lt;proxy&gt; &lt;id&gt;my-proxy&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;host&gt;100.10.10.10&lt;/host&gt; &lt;port&gt;3333&lt;/port&gt; &lt;username&gt;ganlu&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;nonProxyHosts&gt;repository.mycom.com|*.google.com&lt;/nonProxyHosts&gt; &lt;/proxy&gt; &lt;/proxies&gt; ...&lt;/settings&gt; activate表示激活该代理;protocol表示所使用的代理协议;nonProxyHosts用来设置不需要使用代理的域名. 5. 参考链接&lt;&lt;Maven实战&gt;&gt;(许晓斌)]]></content>
      <categories>
        <category>Maven基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一致性Hash算法]]></title>
    <url>%2F2018%2F09%2F24%2F%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 前言后台开发过程中, 一致性Hash算法也是基础, 不做过多特殊说明, 这篇文章记录一致性Hash算法相关知识. 2. 历史演进2.1 Redis集群的使用我们在使用Redis的时候, 为了保证Redis的高可用, 提高Redis的读写性能, 最简单的方式我们会做主从复制, 组成Master-Master或者Master-Slave的形式, 或者搭建Redis集群, 进行数据的读写分离, 类似于数据库的主从复制和读写分离. 如下所示:同样类似于数据库, 当单表数据大于500W的时候需要对其进行分库分表, 当数据量很大的时候(标准可能不一样, 要看Redis服务器容量)我们同样可以对Redis进行类似的操作, 就是分库分表.假设, 我们有一个社交网站, 需要使用Redis存储图片资源, 存储的格式为键值对, key值为图片名称, value为该图片所在文件服务器的路径, 我们需要根据文件名查找该文件所在文件服务器上的路径, 数据量大概有2000W左右, 按照我们约定的规则进行分库, 规则就是随机分配, 我们可以部署8台缓存服务器, 每台服务器大概含有500W条数据, 并且进行主从复制, 示意图如下:由于规则是随机的, 所有我们的一条数据都有可能存储在任何一组Redis中, 例如上图我们用户查找一张名称为”a.png”的图片, 由于规则是随机的, 我们不确定具体是在哪一个Redis服务器上的, 因此我们需要进行1, 2, 3, 4, 4次查询才能够查询到(也就是遍历了所有的Redis服务器), 这显然不是我们想要的结果, 有了解过的小伙伴可能会想到, 随机的规则不行, 可以使用类似于数据库中的分库分表规则: 按照Hash值, 取模, 按照类别, 按照某一个字段值等等常见的规则就可以出来了, 好, 按照我们的主题, 我们就使用Hash的方式. 2.2 为Redis集群使用Hash可想而知, 如果我们使用Hash的方式, 每一张图片在进行分库的时候都可以定位到特定的服务器, 示意图如下:上图中, 假设我们查找的是”a.png”, 由于有4台服务器(排除从库), 因此公式为hash(a.png) % 4 = 2 , 可知定位到了第2号服务器, 这样的话就不会遍历所有的服务器, 大大提升了性能. 2.3 使用Hash的问题上述的方式虽然提升了性能, 我们不再需要对整个Redis服务器进行遍历, 但是, 使用上述Hash算法进行缓存时, 会出现一些缺陷, 主要体现在服务器数量变动的时候, 所有缓存的位置都要发生改变.试想一下, 如果4台缓存服务器已经不能满足我们的缓存需求, 那么我们应该怎么做呢?很简单, 多增加几台缓存服务器不就行了. 假设: 我们增加了一台缓存服务器, 那么缓存服务器的数量就由4台变成了5台. 那么原本hash(a.png) % 4 = 2 的公式就变成了hash(a.png) % 5 = ? , 可想而知这个结果肯定不是2的, 这种情况带来的结果就是当服务器数量变动时, 所有缓存的位置都要发生改变. 换句话说, 当服务器数量发生改变时, 所有缓存在一定时间内是失效的, 当应用无法从缓存中获取数据时, 则会向后端数据库请求数据.同样的, 假设4台缓存中突然有一台缓存服务器出现了故障, 无法进行缓存, 那么我们则需要将故障机器移除, 但是如果移除了一台缓存服务器, 那么缓存服务器数量从4台变为3台, 也是会出现上述的问题.所以, 我们应该想办法不让这种情况发生, 但是由于上述Hash算法本身的缘故, 使用取模法进行缓存时, 这种情况是无法避免的, 为了解决这些问题, Hash一致性算法(一致性Hash算法)诞生了. 3. 一致性Hash算法3.1 一致性Hash算法的神秘面纱一致性Hash算法也是使用取模的方法, 只是, 刚才描述的取模法是对服务器的数量进行取模, 而一致性Hash算法是对2^32取模, 什么意思呢? 简单来说, 一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环, 如假设某哈希函数H的值空间为0-2^32-1(即哈希值是一个32位无符号整形), 整个哈希环如下:整个空间按顺时针方向组织, 圆环的正上方的点代表0, 0点右侧的第一个点代表1, 以此类推, 2, 3, 4, 5, 6……直到2^32-1, 也就是说0点左侧的第一个点代表2^32-1, 0和2^32-1在零点中方向重合, 我们把这个由2^32个点组成的圆环称为Hash环.下一步将各个服务器使用Hash进行一个哈希, 具体可以选择服务器的IP或主机名作为关键字进行哈希, 这样每台机器就能确定其在哈希环上的位置, 这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下:接下来使用如下算法定位数据访问到相应服务器: 将数据key使用相同的函数Hash计算出哈希值, 并确定此数据在环上的位置, 从此位置沿环顺时针”行走”, 第一台遇到的服务器就是其应该定位到的服务器.例如我们有Object A, Object B, Object C, Object D四个数据对象, 经过哈希计算后, 在环空间上的位置如下:根据一致性Hash算法, 数据A会被定为到Node A上, B被定为到Node B上, C被定为到Node C上, D被定为到Node D上. 3.2 一致性Hash算法的容错性和可扩展性现假设Node C不幸宕机, 可以看到此时对象A, B, D不会受到影响, 只有C对象被重定位到Node D. 一般的, 在一致性Hash算法中, 如果一台服务器不可用, 则受影响的数据仅仅是此服务器到其环空间中前一台服务器(即沿着逆时针方向行走遇到的第一台服务器)之间数据, 其它不会受到影响, 如下所示:下面考虑另外一种情况, 如果在系统中增加一台服务器Node X, 如下图所示:此时对象Object A, B, D不受影响, 只有对象C需要重定位到新的Node X. 一般的, 在一致性Hash算法中, 如果增加一台服务器, 则受影响的数据仅仅是新服务器到其环空间中前一台服务器(即沿着逆时针方向行走遇到的第一台服务器)之间数据, 其它数据也不会受到影响.综上所述, 一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据, 具有较好的容错性和可扩展性. 3.3 Hash环的数据倾斜问题一致性Hash算法在服务节点太少时, 容易因为节点分部不均匀而造成数据倾斜(被缓存的对象大部分集中缓存在某一台服务器上)问题, 例如系统中只有两台服务器, 其环分布如下: 此时必然造成大量数据集中到Node A上, 而只有极少量会定位到Node B上. 为了解决这种数据倾斜问题, 一致性Hash算法引入了虚拟节点机制, 即对每一个服务节点计算多个哈希, 每个计算结果位置都放置一个此服务节点, 称为虚拟节点. 具体做法可以在服务器IP或主机名的后面增加编号来实现.例如上面的情况, 可以为每台服务器计算三个虚拟节点, 于是可以分别计算”Node A#1”, “Node A#2”, “Node A#3”, “Node B#1”, “Node B#2”, “Node B#3”的哈希值, 于是形成六个虚拟节点:同时数据定位算法不变, 只是多了一步虚拟节点到实际节点的映射, 例如定位到”Node A#1”, “Node A#2”, “Node A#3”三个虚拟节点的数据均定位到Node A上. 这样就解决了服务节点少时数据倾斜的问题. 在实际应用中, 通常将虚拟节点数设置为32甚至更大, 因此即使很少的服务节点也能做到相对均匀的数据分布. 4. 参考链接面试必备：什么是一致性Hash算法？]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>解决方案</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2018%2F09%2F24%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. 前言后台开发过程中, Linux的熟练使用有助于提高开发效率, 自动化部署等. 这篇文章主要是记录工作中会遇到的一些有用的命令, 持续更新. 2. 常用命令2.1 网络流量监控1dstat -nf 2.2 查看端口被占用方法一: 1lsof -i:8080 方法二: 1netstat -anlp | grep 8080 2.3 生成指定大小的文件12// 生成100M的文件dd if=/dev/zero of=filename bs=1M count=100]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>解决方案</tag>
        <tag>收藏夹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java字符串小数点处理]]></title>
    <url>%2F2018%2F09%2F24%2FJava%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B0%8F%E6%95%B0%E7%82%B9%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 前言今天帮同学做题的时候涉及到利用小数点切分字符串, 感觉以后在后台开发中可能会遇到这个问题, 所以记录一下. 2. 概述错误的处理方式, 编译能通过, 运行时且不会报错, 但是输出结果是0, 123String input = "hello.java";String[] outputs = input.split(".");System.out.println(outputs.length); 正确的处理方式 123String input = "hello.java";String[] outputs = input.split("\\.");System.out.println(outputs.length); 3. 解释首先抛出来2个问题:问题1: 小数点不是转义字符, 为什么不能直接用split(.)?问题2: 为什么非要加2个反斜杠, 只加1个不行吗? 下面给出解释解答问题1: split里面的参数是正则表达式, 在正则表达式中, 小数点表示可以匹配任意字符, 所以不能直接用小数点.解答问题2: 由于问题1已经解决, 很自然的想法就是加上反斜杠来进行转义, 而且这个转义语法其实只有正则表达式能够识别, Java语言中并不支持这种转义, 所以只加一个反斜杠是不行的, 再通俗点说就是, 我要告诉正则表达式2个字符, 一个是反斜杠, 一个是小数点, 反斜杠由于是特殊字符, 所以我要通过转义了告诉正则表达式, 而小数点不是特殊字符, 所以我可以直接告诉正则表达式, 最后的结果就是两个反斜杠+小数点.]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java本地方法]]></title>
    <url>%2F2018%2F09%2F24%2FJava%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 前言之前在公司开发的时候, 需要用到内部的组件, 尽管提供了jar包, 但是jar包底层是通过Java本地方法实现的, 所以仅仅导入jar包并不能正常使用, 还需要安装内部组件的环境. 所以写这篇文章记录Java本地方法的使用, 帮助自己熟悉这块的使用. 2. 基础使用基于Linux环境, 这个章节简单介绍如何实现一个Java本地方法. 第一步: 建立一个普通的java类, 添加一个方法, 在方法返回值前加 native 1234public class ClassMethod &#123; //本地方法可以是静态的也可以是非静态的； public static native void greeting();&#125; 第二步: 编译这个java类, 得到ClassMethod.class文件 1javac ClassMethod.java 第三步: 找到当前类编译的.class文件, 使用命令行生成.h文件 1javah ClassMethod 第四步: 查看ClassMethod.h 123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class ClassMethod */#ifndef _Included_ClassMethod#define _Included_ClassMethod#ifdef __cplusplusextern "C" &#123;#endif/* * Class: ClassMethod * Method: greeting * Signature: ()V */JNIEXPORT void JNICALL Java_ClassMethod_greeting (JNIEnv *, jclass);#ifdef __cplusplus&#125;#endif#endif 第五步: 新建cpp文件, 并写逻辑代码(我这边命名为main.cpp,其实是可以随意命名的) 12345#include "ClassMethod.h"#include &lt;stdio.h&gt;JNIEXPORT void JNICALL Java_ClassMethod_greeting(JNIEnv *, jclass)&#123; printf("hello world!");&#125; 第六步: 将main.cpp文件和ClassMethod.h放到一个目录下, 并执行指令生成动态链接库.so文件 1gcc -fPIC -I /home/ganlu/java/jdk1.8.0_144/include/ -I /home/ganlu/java/jdk1.8.0_144/include/linux/ -shared -o libHello.so main.cpp 第七步: 将动态链接库复制到java项目中 123456789101112public class ClassMethod &#123; static &#123; System.load("/home/ganlu/java/workplace/libHello.so"); &#125; //本地方法可以是静态的也可以是非静态的； public static native void greeting(); public static void main(String args[])&#123; greeting(); &#125;&#125; 第八步: 重新编译ClassMethod.java并执行 12javac ClassMethod.javajava ClassMethod 运行结果: 1hello world! 3. 几个问题3.1 动态链接库我这边动态链接库的加载是通过绝对路径的指定来实现的, 而实际中, 这种绝对路径的指定肯定是不好的. 1System.load("/home/ganlu/java/workplace/libHello.so"); 网上流传比较多的一种做法是如下(这里要注意, .so文件的命名一定要规范, 以lib开头, 以.so结尾): 1System.loadLibrary("Hello"); 但是用这种方法直接运行, 会报错. 12345Exception in thread "main" java.lang.UnsatisfiedLinkError: no Hello in java.library.path at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1867) at java.lang.Runtime.loadLibrary0(Runtime.java:870) at java.lang.System.loadLibrary(System.java:1122) at ClassMethod.&lt;clinit&gt;(ClassMethod.java:4) 3.1.1 解决方法一:通过Java运行参数指定java.library.path1java -Djava.library.path=. ClassMethod 3.1.2 解决方法二:通过配置 LD_LIBRARY_PATH 环境变量123sudo gedit /etc/profileexport LD_LIBRARY_PATH=/home/ganlu/java/workplace 3.2 工作流程图 3.3 常见异常如果出现以下异常, 则说明.so文件不对, 是因为java 程序在调用.so时候, 不能找到native method 方法的实现.主要是因为在.so中, 可能xxx.h头文件中的接口名和xxx.cpp源文件中的实现函数名不一致导致的. 123Exception in thread "main" java.lang.UnsatisfiedLinkError: test.ClassMethod.greeting()V at test.ClassMethod.greeting(Native Method) at test.ClassMethod.main(ClassMethod.java:11) 4. 参考链接Java native 本地方法调用java 本地方法（JNI）Exception in thread “main” java.lang.UnsatisfiedLinkError: xxx()V]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java程序启动时指定外部依赖jar包]]></title>
    <url>%2F2018%2F09%2F24%2FJava%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%97%B6%E6%8C%87%E5%AE%9A%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96jar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[1. 前言Java程序启动, 经常会遇到需要指定外部依赖jar包的情况, 在学校开发的时候, 不需要考虑那么多, 一般是通过修改配置文件实现的, 但是这种做法是可能会对服务器上运行的其他程序造成影响的, 所以写这篇博客, 记录一下常用做法. 2. 常用做法2.1 方法一: 使用Bootstrap Classloader来加载我们可以在运行时使用如下参数： -Xbootclasspath:完全取代系统Java classpath.最好不用.-Xbootclasspath/a: 在系统class加载后加载. 一般用这个.-Xbootclasspath/p: 在系统class加载前加载,注意使用, 和系统类冲突就不好了. 1java -Xbootclasspath/a: some.jar:some2.jar: -jar test.jar 我个人并不推荐这个做法, 因为当jar包很多的时候, 这个得一个个指定, 并不好用. 2.2 方法二: 使用Extension Classloader来加载首先介绍下java.ext.dirs参数的使用和环境变量:java中系统属性java.ext.dirs指定的目录由ExtClassLoader加载器加载如果您的程序没有指定该系统属性(-Djava.ext.dirs=sss/lib), 那么该加载器默认加载\$JAVA_HOME/lib/ext目录下的所有jar文件但如果你手动指定系统属性且忘了把\$JAVA_HOME/lib/ext路径给加上, 那么ExtClassLoader不会去加载\$JAVA_HOME/lib/ext下面的jar文件, 这意味着你将失去一些功能, 例如java自带的加解密算法实现. 一般命令行如下: 1java -Djava.ext.dirs=$JAVA_HOME/jre/lib/ext:/home/ganlu/dir -jar test.jar 我一般用这种方式. 并且一定要记得加上\$JAVA_HOME/jre/lib/ext 3. 说明网上流传的还有诸如把jar包放到环境变量下, 或者修改环境变量, 个人并不倾向于使用, 因为会对其他应用程序造成影响. 4. 参考链接java -jar命令运行jar包时指定外部依赖jar包]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REST服务与RESTful风格]]></title>
    <url>%2F2018%2F09%2F24%2FREST%E6%9C%8D%E5%8A%A1%E4%B8%8ERESTful%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[1. 前言进行后台开发的时候, 我们经常说, 我们的接口是Restful的风格, 那Restful到底是什么呢?Restful风格有哪些特点呢?REST又跟Restful有什么关系?这篇文章主要是记录Restful API风格及其相关的一些知识点. 2. 什么是RESTREST: representational state transfer 表述性状态转移, 是一种架构风格.它是轻量级,跨平台,跨语言的架构设计; 它是一种设计风格,不是一种标准, 是一种思想. 3. REST原则 网络上的所有事物都被抽象为资源 每个资源都有一个唯一的资源标识符 同一个资源具有多种表现形式(xml,json等) 对资源的各种操作不会改变资源标识符 所有的操作都是无状态的 4. 关于RESTfulRESTful: 遵守了REST原则的web服务理解: REST与RESTful相比, 多了一个ful, 就英语层面来说是一个形容词, RESTful翻译为中文为: “REST式的”.是REST式的是什么意思呢?意思是 是REST式的应用, REST风格的web服务也是REST式的应用, REST式的web服务是一种ROA(The Resource-Oriented Architecture)(面向资源的架构). 5. 为什么会出现RESTful 在RESTful之前的操作:http://127.0.0.1/user/query/1 GET 根据用户id查询用户数据http://127.0.0.1/user/save POST 新增用户http://127.0.0.1/user/update POST 修改用户信息http://127.0.0.1/user/delete GET/POST 删除用户信息RESTful用法:http://127.0.0.1/user/1 GET 根据用户id查询用户数据http://127.0.0.1/user POST 新增用户http://127.0.0.1/user PUT 修改用户信息http://127.0.0.1/user DELETE 删除用户信息 之前的操作是没有问题的,大神认为是有问题的,有什么问题呢?你每次请求的接口或者地址,都在做描述,例如查询的时候用了query,新增的时候用了save,其实完全没有这个必要,我使用了get请求,就是查询.使用post请求,就是新增的请求,我的意图很明显,完全没有必要做描述,这就是为什么有了RESTful. 6. 如何设计Restful风格的API6.1 路径设计在RESTdul架构中, 每个网址代表一种资源(resource), 所以网址中不能有动词, 只能有名词, 而且所用的名词往往与数据库的表名对应, 一般来说, 数据库中的表都是同种记录的”集合”(collection), 所以API中的名词也应该使用复数.举例来说, 有一个API提供动物园(zoo)的信息, 还包括各种动物和雇员的信息, 则它的路径应该设计成下面这样. 123https://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/employees 6.2 HTTP动词设计对于资源的具体操作类型, 由HTTP动词表示, 常用的HTTP动词如下: 请求方式 含义 GET 获取资源（一项或多项） POST 新建资源 PUT 更新资源（客户端提供改变后的完整资源） DELETE 删除资源 如何通过路径和http动词获悉要调用的功能: 请求方式 含义 GET /zoos 列出所有动物园 POST /zoos 新建一个动物园 GET /zoos/ID 获取某个指定动物园的信息 PUT /zoos/ID 更新某个指定动物园的信息（提供该动物园的全部信息） DELETE /zoos/ID 删除某个动物园 GET /zoos/ID/animals 列出某个指定动物园的所有动物 DELETE /zoos/ID/animals/ID 删除某个指定动物园的指定动物 6.3 常用状态码123456789101112200 OK - [GET]: 服务器成功返回用户请求的数据, 该操作是幂等的.201 CREATED - [POST/PUT/PATCH]: 用户新建或修改数据成功.202 Accepted - [*]:表示一个请求已经进入后台排队(异步任务)204 NO CONTENT - [DELETE]: 用户删除数据成功.400 INVALID REQUEST - [POST/PUT/PATCH]: 用户发出的请求有错误, 服务器没有进行新建或修改数据的操作.401 Unauthorized - [*]: 表示用户没有权限(令牌, 用户名, 密码错误).403 Forbidden - [*]: 表示用户得到授权(与401错误相对), 但是访问是被禁止的.404 NOT FOUND - [*]: 用户发出的请求针对的是不存在的记录, 服务器没有进行操作, 该操作是幂等的.406 Not Acceptable - [GET]: 用户请求的格式不可得(比如用户请求JSON格式, 但是只有XML格式).410 Gone -[GET]: 用户请求的资源被永久删除, 且不会再得到的.422 Unprocesable entity - [POST/PUT/PATCH]: 当创建一个对象时, 发生一个验证错误.500 INTERNAL SERVER ERROR - [*]: 服务器发生错误, 用户将无法判断发出的请求是否成功. 6.4 版本号应该将API的版本号放入URL 1如: https://api.example.com/v1/ 另一种做法是, 将版本号放在HTTP头信息中, 但不如放入URL方便和直观. Github采用这种做法. 6.5 其他服务器返回的数据格式, 应该尽量使用JSON, 避免使用XML. 7. 参考链接什么是rest？什么是restful？它们之间是什么关系【Restful】三分钟彻底了解Restful最佳实践理解并设计rest/restful风格接口]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字面量, 符号引用与直接引用]]></title>
    <url>%2F2018%2F09%2F24%2F%E5%AD%97%E9%9D%A2%E9%87%8F%2C%20%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E4%B8%8E%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 前言学习JVM的时候, 总碰到字面量, 符号引用与直接引用这几个词, 理解的迷迷糊糊的. 这里总结一下. 2. 字面量百度百科解释: 在计算机科学中, 字面量(literal)是用于表达源代码中一个固定值的表示法(notation). 几乎所有计算机编程语言都具有对基本值的字面量表示, 诸如: 整数, 浮点数以及字符串; 而有很多也对布尔类型和字符类型的值也支持字面量表示; 还有一些甚至对枚举类型的元素以及像数组, 记录和对象等复合类型的值也支持字面量表示法.很抽象, 举个例子就明白了. 12int i = 1;把整数1赋值给int型变量i，整数1就是Java字面量，String s = "abc";中的abc也是字面量。 3. 符号引用符号引用以一组符号来描述所引用的目标, 符号可以是任何形式的字面量, 只要使用时能够无歧义的定位到目标即可. 例如, 在Java中, 一个Java类将会编译成一个class文件. 在编译时, Java类并不知道所引用的类的实际地址, 因此只能使用符号引用来代替. 比如org.simple.People类引用了org.simple.Language类, 在编译时People类并不知道Language类的实际内存地址, 因此只能使用符号org.simple.Language来表示Language类的地址. 4. 直接引用直接引用可以是: 直接指向目标的指针.(个人理解为: 指向方法区中类对象, 类变量和类方法的指针) 相对偏移量. (指向实例的变量, 方法的指针) 一个间接定位到对象的句柄. 我觉得直接引用说白了, 就是程序运行时可以定位到引用的东西(类, 对象, 变量或者方法等)的地址. 5. 参考链接java – JVM的符号引用和直接引用Java字面量（Java直接量）和符号引用走进java_符号引用与直接引用]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS]]></title>
    <url>%2F2018%2F09%2F24%2FHTTPS%2F</url>
    <content type="text"><![CDATA[1. 前言超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息, HTTP协议以明文方式发送内容, 不提供任何方式的数据加密, 如果攻击者截取了Web浏览器和网站服务器之间的传输报文, 就可以直接读懂其中的信息, 因此, HTTP协议不适合传输一些敏感信息, 比如: 信用卡号, 密码等支付信息.为了解决HTTP协议的这一缺陷, 需要使用另一种协议: 安全套接字层超文本传输协议HTTPS, 为了数据传输的安全, HTTPS在HTTP的基础上加入了SSL协议, SSL依靠证书来验证服务器的身份, 并为浏览器和服务器之间的通信加密. 2. 基本概念HTTP: 是互联网上应用最为广泛的一种网络协议, 是一个客户端和服务器端请求和应答的标准(TCP), 用于从WWW服务器传输超文本到本地浏览器的传输协议, 它可以使浏览器更加高效, 使网络传输减少.HTTPS: 是以安全为目标的HTTP通道, 简单讲是HTTP的安全版, 即HTTP下加入SSL层, HTTPS的安全基础是SSL, 因此加密的详细内容就需要SSL.HTTPS协议的主要作用可以分为两种: 一种是建立一个信息安全通道, 来保证数据传输的安全; 另一种就是确认网站的真实性. 3. HTTP与HTTPS的区别HTTP协议传输的数据都是未加密的, 也就是明文的, 因此使用HTTP协议传输隐私信息非常不安全, 为了保证这些隐私数据能加密传输, 于是网景公司设计了SSL(Secure Sockets Layer)协议用于对HTTP协议传输的数据进行加密, 从而就诞生了HTTPS. 简单来说, HTTPS协议是由SSL+HTTP协议构建的可进行加密传输, 身份认证的网络协议, 要比http协议安全.HTTPS和HTTP的区别主要如下: https协议需要到ca申请证书, 一般免费证书较少, 因而需要一定费用. http是超文本传输协议, 信息是明文传输, https则是具有安全性的ssl加密传输协议. http和https使用的是完全不同的连接方式, 用的端口也不一样, 前者是80, 后者是443. http的连接很简单, 是无状态的; HTTPS协议是由SSL+HTTP协议构建的可进行加密传输, 身份认证的网络协议, 比http协议安全. 4. HTTPS的工作原理我们都知道HTTPS能够加密信息, 以免敏感信息被第三方获取, 所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议.客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤, 如图所示. 客户使用https的URL访问Web服务器, 要求与Web服务器建立SSL连接. Web服务器收到客户端请求后, 会将网站的证书信息(证书中包含公钥)传送一份给客户端. 客户端的浏览器与Web服务器开始协商SSL连接的安全等级, 也就是信息加密的等级. 客户端的浏览器根据双方同意的安全等级, 创建会话密钥, 然后利用网站的公钥将会话密钥加密, 并传送给网站. Web服务器利用自己的私钥解密出会话密钥. Web服务器利用会话密钥加密与客户端之间的通信. 5. HTTPS的优点尽管HTTPS并非绝对安全, 掌握根证书的机构, 掌握加密算法的组织同样可以进行中间人形式的攻击, 但HTTPS仍是现行架构下最安全的解决方案, 主要有以下几个好处: 使用HTTPS协议可认证用户和服务器, 确保数据发送到正确的客户机和服务器; HTTPS协议是由SSL+HTTP协议构建的可进行加密传输, 身份认证的网络协议, 要比http协议安全, 可防止数据在传输过程中不被窃取, 改变, 确保数据的完整性. HTTPS是现行架构下最安全的解决方案, 虽然不是绝对安全, 但它大幅增加了中间人攻击的成本. 谷歌曾在2014年8月份调整搜索引擎算法, 并称”比起同等HTTP网站, 采用HTTPS加密的网站在搜索结果中的排名将会更高”. 6. HTTPS的缺点虽然说HTTPS有很大的优势, 但其相对来说, 还是存在不足之处的: HTTPS协议握手阶段比较费时, 会使页面的加载时间延长近50%, 增加10%到20%的耗电; HTTPS连接缓存不如HTTP高效, 会增加数据开销和功耗, 甚至已有的安全措施也会因此而受到影响; SSL证书需要钱, 功能越强大的证书费用越高, 个人网站, 小网站没有必要一般不会用. SSL证书通常需要绑定IP, 不能在同一IP上绑定多个域名, IPv4资源不可能支撑这个消耗. HTTPS协议的加密范围也比较有限, 在黑客攻击, 拒绝服务攻击, 服务器劫持等方面几乎起不到什么作用. 最关键的, SSL证书的信用链体系并不安全, 特别是在某些国家可以控制CA根证书的情况下, 中间人攻击一样可行. 7. 参考链接HTTP与HTTPS的区别【HTTP】HTTPS 原理详解]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVCC多版本并发控制]]></title>
    <url>%2F2018%2F09%2F24%2FMVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1. 前言学习数据库事务的时候, 提到MVCC, 通过MVCC可以在无锁的情况下, 避免不可重复读, 这篇文章主要是介绍MVCC的原理. 2. MVCC简介MVCC(Multiversion Concurrency Control),即多版本并发控制技术,它使得大部分支持行锁的事务引擎,不再单纯的使用行锁来进行数据库的并发控制,取而代之的是,把数据库的行锁与行的多个版本结合起来,只需要很小的开销,就可以实现非锁定读,从而大大提高数据库系统的并发性能. 3. 实现原理MVCC可以提供基于某个时间点的快照,使得对于事务看来,总是可以提供与事务开始时刻相一致的数据,而不管这个事务执行的时间有多长.所以在不同的事务看来,同一时刻看到的相同行的数据可能是不一样的,即一个行可能有多个版本.是否听起来不可思议呢?原来,为了实现MVCC, innodb对每一行都加上了两个隐含的列,其中一列存储行被更新的”时间”,另外一列存储行被删除的”时间”. 但是innodb存储的并不是绝对的时间,而是与时间对应的数据库系统的版本号,每当一个事务开始的时候,innodb都会给这个事务分配一个递增的版本号,所以版本号也可以被认为是事务号.对于每一个”查询”语句,innodb都会把这个查询语句的版本号同这个查询语句遇到的行的版本号进行对比,然后结合不同的事务隔离等级,来决定是否返回该行.下面分别以select, delete, insert, update语句来说明: SELECT对于select语句, 只有同时满足了下面两个条件的行, 才能被返回:a. 行的被修改版本号小于或者等于该事务号b. 行的被删除版本号要么没有被定义,要么大于事务的版本号:行的删除版本号如果没有被定义,说明该行没有被删除过;如果删除版本号大于当前事务的事务号,说明该行是被该事务后面启动的事务删除的,由于是repeatable read隔离等级,后开始的事务对数据的影响不应该被先开始的事务看见,所以该行应该被返回. INSERT对新插入的行,行的更新版本被修改为该事务的事务号 DELETE对于删除,innodb直接把该行的被删除版本号设置为当前的事务号,相当于标记为删除,而不是实际删除 UPDATE在更新行的时候,innodb会把原来的行复制一份到回滚段中,并把当前的事务号作为该行的更新版本 4. MVCC的优缺点上述策略的结果就是,在读取数据的时候,innodb几乎不用获得任何锁, 每个查询都通过版本检查,只获得自己需要的数据版本,从而大大提高了系统的并发度.这种策略的缺点是,为了实现多版本,innodb必须对每行增加相应的字段来存储版本信息,同时需要维护每一行的版本信息,而且在检索行的时候,需要进行版本的比较,因而降低了查询的效率;innodb还必须定期清理不再需要的行版本,及时回收空间,这也增加了一些开销. 5. 参考链接深入理解MVCC多版本并发控制]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库事务]]></title>
    <url>%2F2018%2F09%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[1. 前言后台开发过程中, 与数据库打交道是日常操作, 为了提高代码质量和程序性能, 数据库事务是必须理解深刻的, 这篇文章主要是记录数据库事务相关的概念和知识. 2. 事务2.1 什么是事务事务就是DBMS当中用户程序的任何一次执行, 事务是DBMS能看到的基本修改单元.事务是指对系统进行的一组操作, 为了保证系统的完整性, 事务需要具有ACID特性. 2.2 为什么要有事务事务的产生,其实是为了当应用程序访问数据库的时候,事务能够简化我们的编程模型,不需要我们去考虑各种各样的潜在错误和并发问题.可以想一下当我们使用事务时,要么提交,要么回滚,我们不会去考虑网络异常了,服务器宕机了,同时更改一个数据怎么办对吧?因此事务本质上是为了应用层服务的.而不是伴随着数据库系统天生就有的. 2.3 ACID特性2.3.1 原子性(Atomic)事务是一个完整的操作. 事务的各步操作是不可分的(原子的); 要么都执行,要么都不执行. 2.3.2 一致性(Consistency)当事务完成时, 数据必须处于一致状态. 即应用系统从一个正确的状态到另一个正确的状态. 2.3.3 隔离性(Isolation)对数据进行修改的所有并发事务是彼此隔离的, 这表明事务必须是独立的, 它不应以任何方式依赖于或影响其他事务. 2.3.4 持久性(Durability)事务完成后, 它对数据库的修改被永久保持, 事务日志能够保持事务的永久性. 2.4 隔离性详解2.4.1 隔离级别事务的隔离级别从低到高有:Read Uncommitted: 最低的隔离级别, 什么都不需要做, 一个事务可以读到另一个事务未提交的结果. 所有的并发事务问题都会发生.Read Committed: 只有在事务提交后, 其更新结果才会被其他事务看见. 可以解决脏读问题.Repeated Read: 在一个事务中, 对于同一份数据的读取结果总是相同的, 无论是否有其他事务对这份数据进行操作, 以及这个事务是否提交. 可以解决脏读, 不可重复读.Serialization: 事务串行化执行, 隔离级别最高, 牺牲了系统的并发性. 可以解决并发事务的所有问题.通常, 在工程实践中, 为了性能的考虑会对隔离性进行折中.其中只有serialization实现隔离性所有要求, 真正实现事务的隔离性.但考虑到实践, 为了性能, 数据库厂商做出了这方面的妥协, 让使用者可以选择隔离的级别.不同的隔离级别可以解决不同阶段的问题, 是层层递进, 逐渐增强的关系. 2.4.2 隔离性要解决的问题隔离性为了解决的问题主要有三个(将事务的隔离级别和问题联系在一起理解): 脏读(Drity Read): 事务A修改了一个数据, 但未提交, 事务B读到了事务A未提交的更新结果, 如果事务A提交失败, 事务B读到的就是脏数据. Read Committed可以解决脏读问题, 但仍存在以下两种问题. 不可重复读(Non-repeatable read): 在同一个事务中, 对于同一份数据读取到的结果不一致. 比如, 事务B在事务A提交前读到的结果, 和提交后读到的结果可能不同. 不可重复读出现的原因就是事务并发修改记录, 要避免这种情况, 最简单的方法就是对要修改的记录加锁, 这导致锁竞争加剧, 影响性能.(另一种方法是通过MVCC可以在无锁的情况下, 避免不可重复读.) Repeated Read可以解决不可重复读问题和脏读问题, 但仍无法解决下面的问题. 幻读(Phantom Read): 在同一个事务中, 同一个查询多次返回的结果不一致. 事务A新增了一条记录, 事务B在事务A提交前后各执行了一次查询操作, 发现后一次比前一次多了一条记录. 幻读仅指由于并发事务增加记录导致的问题, 这个不能像不可重复读通过记录加锁解决, 因为对于新增的记录根本无法加锁. 需要将事务串行化, 才能避免幻读. Serialization解决了以上所有问题, 但是性能效率较低. 通常来说, 事务隔离级别越低, 所需持有锁的时间也就越短, 并发性能也就越好. 3.参考链接如何理解数据库事务中的一致性的概念？事务的特性：事务必须具备以下四个属性，简称ACID事务的隔离性理解]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并行和并发的区别]]></title>
    <url>%2F2018%2F09%2F24%2F%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1. 前言并行和并发的区别, 一张图足以说明问题.concurrent: 并发parallel: 并行 2. 并行和并发的区别什么是并发?并发:指应用能够交替执行不同的任务,例:吃完饭-&gt;喝水 喝完水-&gt;睡觉 一觉醒来-&gt;吃饭……什么是并行?并行:指应用能够同时执行不同的任务,例:吃饭的时候可以边吃饭边打电话,这两件事情可以同时执行两者区别:一个是交替执行,一个是同时执行. 3. 参考链接什么是并行、并发,两者区别]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2018%2F09%2F24%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[1. 前言作为一名后台开发人员, 提供服务给用户或者作为用户去请求服务是日常操作, 而其中用的最多的协议也是HTTP协议. 这篇文章主要是记录HTTP协议相关的内容. 2. HTTP协议2.1 什么是HTTP协议?协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则, 超文本传输协议(HTTP)是一种通信协议, 它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器目前我们使用的是HTTP/1.1 版本 2.2 URLURL(Uniform Resource Locator) 地址用于描述一个网络上的资源, 基本格式如下: 1234567schema://host[:port#]/path/.../[?query-string][#anchor]scheme 指定低层使用的协议(例如：http, https, ftp)host HTTP服务器的IP地址或者域名port# HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如http://www.cnblogs.com:8080/path 访问资源的路径query-string 发送给http服务器的数据anchor 锚 实例 123456http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuffSchema: httphost: www.mywebsite.compath: /sj/test/test.aspxQuery String: name=sviergn&amp;x=trueAnchor: stuff 2.3 HTTP协议是无状态的HTTP协议是无状态的, 同一个客户端的这次请求和上次请求是没有对应关系, 对http服务器来说, 它并不知道这两个请求来自同一个客户端. 为了解决这个问题, Web程序引入了Cookie机制来维护状态. 2.4 打开一个网页需要浏览器发送很多次Request 当你在浏览器输入URL http://www.cnblogs.com 的时候, 浏览器发送一个Request去获取 http://www.cnblogs.com 的html. 服务器把Response发送回给浏览器. 浏览器分析Response中的 HTML, 发现其中引用了很多其他文件, 比如图片, CSS文件, JS文件. 浏览器会自动再次发送Request去获取图片, CSS文件, 或者JS文件. 等所有的文件都下载成功后. 网页就被显示出来了. 2.5 HTTP消息的结构2.5.1 Request 消息的结构先看Request 消息的结构, Request 消息分为3部分, 第一部分叫Request line, 第二部分叫Request header, 第三部分是body. header和body之间有个空行, 结构如下图.第一行中的Method表示请求方法,比如”POST”,”GET”, Path-to-resoure表示请求的资源, Http/version-number 表示HTTP协议的版本号当使用的是”GET” 方法的时候, body是为空的比如我们打开博客园首页的request 如下 12GET http://www.cnblogs.com/ HTTP/1.1Host: www.cnblogs.com 2.5.2 Response 消息的结构再看Response消息的结构, 和Request消息的结构基本一样. 同样也分为三部分, 第一部分叫Response line, 第二部分叫Response header, 第三部分是body. header和body之间也有个空行, 结构如下图.HTTP/version-number表示HTTP协议的版本号 2.5.3 GET和POST方法的区别Http协议定义了很多与服务器交互的方法, 最基本的有4种, 分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源, 而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查, 改, 增, 删4个操作. 我们最常见的就是GET和POST了. GET一般用于获取/查询资源信息, 而POST一般用于更新资源信息.我们看看GET和POST的区别: GET提交的数据会放在URL之后, 以?分割URL和传输数据, 参数之间以&amp;相连, 如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中. GET提交的数据大小有限制(因为浏览器对URL的长度有限制), 而POST方法提交的数据没有限制. GET方式需要使用Request.QueryString来取得变量的值, 而POST方式通过Request.Form来获取变量的值. GET方式提交数据, 会带来安全问题, 比如一个登录页面, 通过GET方式提交数据时, 用户名和密码将出现在URL上, 如果页面可以被缓存或者其他人可以访问这台机器, 就可以从历史记录获得该用户的账号和密码. 2.5.4 状态码Response 消息中的第一行叫做状态行, 由HTTP协议版本号, 状态码, 状态消息 三部分组成.状态码用来告诉HTTP客户端, HTTP服务器是否产生了预期的Response.HTTP/1.1中定义了5类状态码, 状态码由三位数字组成, 第一个数字定义了响应的类别1XX 提示信息 - 表示请求已被成功接收, 继续处理2XX 成功 - 表示请求已被成功接收, 理解, 接受3XX 重定向 - 要完成请求必须进行更进一步的处理4XX 客户端错误 - 请求有语法错误或请求无法实现5XX 服务器端错误 - 服务器未能实现合法的请求 2.6 HTTP Request header2.6.1 Cache 头域If-Modified-Since作用: 把浏览器端缓存页面的最后修改时间发送到服务器去, 服务器会把这个时间与服务器上实际文件的最后修改时间进行对比. 如果时间一致, 那么返回304, 客户端就直接使用本地缓存文件. 如果时间不一致, 就会返回200和新的文件内容. 客户端接到之后, 会丢弃旧文件, 把新文件缓存起来, 并显示在浏览器中.例如：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMTIf-None-Match作用: If-None-Match和ETag一起工作, 工作原理是在HTTP Response中添加ETag信息. 当用户再次请求该资源时, 将在HTTP Request 中加入If-None-Match信息(ETag的值). 如果服务器验证资源的ETag没有改变(该资源没有更新), 将返回一个304状态告诉客户端使用本地缓存文件. 否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能例如: If-None-Match: “03f2b33c0bfcc1:0”Pragma作用: 防止页面被缓存, 在HTTP/1.1版本中, 它和Cache-Control:no-cache作用一模一样Pargma只有一个用法, 例如: Pragma: no-cache注意: 在HTTP/1.0版本中, 只实现了Pragema:no-cache, 没有实现Cache-ControlCache-Control作用: 这个是非常重要的规则. 这个用来指定Response-Request遵循的缓存机制. 各个指令含义如下:Cache-Control:Public 可以被任何缓存所缓存Cache-Control:Private 内容只缓存到私有缓存中Cache-Control:no-cache 所有内容都不会被缓存 2.6.2 Client 头域Accept作用: 浏览器端可以接受的媒体类型例如: Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档如果服务器无法返回text/html类型的数据,服务器应该返回一个406错误(non acceptable)通配符 代表任意类型例如 Accept: /* 代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个Accept-Encoding作用: 浏览器申明自己接收的编码方法, 通常指定压缩方法, 是否支持压缩, 支持什么压缩方法(gzip，deflate), (注意: 这不是只字符编码);例如: Accept-Encoding: gzip, deflateAccept-Language作用: 浏览器申明自己接收的语言.语言跟字符集的区别:中文是语言, 中文有多种字符集, 比如big5, gb2312, gbk等等;例如: Accept-Language: en-usUser-Agent作用: 告诉HTTP服务器, 客户端使用的操作系统和浏览器的名称和版本.我们上网登陆论坛的时候, 往往会看到一些欢迎信息, 其中列出了你的操作系统的名称和版本, 你所使用的浏览器的名称和版本, 这往往让很多人感到很神奇, 实际上, 服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统, 浏览器和其它属性告诉服务器.例如: User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E)Accept-Charset作用: 浏览器申明自己接收的字符集, 这就是本文前面介绍的各种字符集和字符编码, 如gb2312, utf-8(通常我们说Charset包括了相应的字符编码方案); 2.6.3 Cookie/Login 头域Cookie作用: 最重要的header, 将cookie的值发送给HTTP 服务器 2.6.4 Entity头域Content-Length作用: 发送给HTTP服务器数据的长度.例如: Content-Length: 38Content-Type例如：Content-Type: application/x-www-form-urlencoded 2.6.5 Miscellaneous 头域Referer作用: 提供了Request的上下文信息的服务器, 告诉服务器我是从哪个链接过来的, 比如从我主页上链接到一个朋友那里, 他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站.例如: Referer:http://translate.google.cn/?hl=zh-cn&amp;tab=wT 2.6.6 Transport 头域Connection例如: Connection: keep-alive当一个网页打开完成后, 客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭, 如果客户端再次访问这个服务器上的网页, 会继续使用这一条已经建立的连接例如: Connection: close代表一个Request完成后, 客户端和服务器之间用于传输HTTP数据的TCP连接会关闭, 当客户端再次发送Request, 需要重新建立TCP连接.Host(发送请求时，该报头域是必需的)作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号, 它通常从HTTP URL中提取出来的例如: 我们在浏览器中输入: http://www.guet.edu.cn/index.html浏览器发送的请求消息中, 就会包含Host请求报头域, 如下:Host: http://www.guet.edu.cn此处使用缺省端口号80, 若指定了端口号, 则变成: Host: 指定端口号 2.7 HTTP Response header2.7.1 Cache 头域Date作用: 生成消息的具体时间和日期例如: Date: Sat, 11 Feb 2012 11:35:14 GMTExpires作用: 浏览器会在指定过期时间内使用本地缓存例如: Expires: Tue, 08 Feb 2022 11:35:14 GMTVary例如: Vary: Accept-Encoding 2.7.2 Cookie/Login 头域P3P作用: 用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题例如: P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP CORSet-Cookie作用: 非常重要的header, 用于把cookie 发送到客户端浏览器, 每一个写入cookie都会生成一个Set-Cookie.例如: Set-Cookie: sc=4c31523a; path=/; domain=.acookie.taobao.com 2.7.3 Entity头域ETag作用: 和If-None-Match 配合使用例如: ETag: “03f2b33c0bfcc1:0”Last-Modified作用: 用于指示资源的最后修改日期和时间.例如: Last-Modified: Wed, 21 Dec 2011 09:09:10 GMTContent-Type作用:WEB服务器告诉浏览器自己响应的对象的类型和字符集,例如:Content-Type: text/html; charset=utf-8Content-Type:text/html;charset=GB2312Content-Type: image/jpegContent-Length指明实体正文的长度, 以字节方式存储的十进制数字来表示. 在数据下行的过程中, Content-Length的方式要预先在服务器中缓存所有数据, 然后所有数据再一股脑儿地发给客户端.例如: Content-Length: 19847Content-EncodingWEB服务器表明自己使用了什么压缩方法(gzip，deflate)压缩响应中的对象.例如: Content-Encoding: gzipContent-Language作用: WEB服务器告诉浏览器自己响应的对象的语言者例如: Content-Language:da 2.7.4 Miscellaneous 头域Server作用: 指明HTTP服务器的软件信息例如:Server: Microsoft-IIS/7.5X-AspNet-Version作用: 如果网站是用ASP.NET开发的, 这个header用来表示ASP.NET的版本例如: X-AspNet-Version: 4.0.30319X-Powered-By作用: 表示网站是用什么技术开发的例如: X-Powered-By: ASP.NET 2.7.5 Transport头域Connection例如: Connection: keep-alive 当一个网页打开完成后, 客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭, 如果客户端再次访问这个服务器上的网页, 会继续使用这一条已经建立的连接例如: Connection: close 代表一个Request完成后, 客户端和服务器之间用于传输HTTP数据的TCP连接会关闭, 当客户端再次发送Request, 需要重新建立TCP连接 2.7.6 Location头域Location作用: 用于重定向一个新的位置, 包含新的URL地址 2.8 HTTP协议是无状态的和Connection: keep-alive的区别无状态是指协议对于事务处理没有记忆能力, 服务器不知道客户端是什么状态.从另一方面讲, 打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系HTTP是一个无状态的面向连接的协议, 无状态不代表HTTP不能保持TCP连接, 更不能代表HTTP使用的是UDP协议(无连接)从HTTP/1.1起, 默认都开启了Keep-Alive, 保持连接特性, 简单地说, 当一个网页打开完成后, 客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭, 如果客户端再次访问这个服务器上的网页,会继续使用这一条已经建立的连接Keep-Alive不会永久保持连接, 它有一个保持时间, 可以在不同的服务器软件(如Apache)中设定这个时间 3. 参考链接HTTP协议详解]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理服务器]]></title>
    <url>%2F2018%2F09%2F24%2F%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. 前言在公司里开发, 一般是在内网环境中, 所以经常会遇到一些网络相关的问题以及代理服务器的配置, 这篇文章主要是记录代理服务器及其相关的知识. 2. 代理服务器2.1 什么是代理服务器?代理服务器(Proxy Server)是互联网上提供转接功能的服务器, 在一般情况下, 我们使用网络浏览器直接去连接其他Internet站点取得网络信息时, 是直接联系到目的站点服务器, 然后由目的站点服务器把信息传送回来. 代理服务器是介于客户端和Web服务器之间的另一台服务器, 有了它之后, 浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求, 信号会先送到代理服务器, 由代理服务器来取回浏览器所需要的信息并传送给你的浏览器.比如你想访问的目的网站是A, 由于某种原因你不能访问到网站A或者你不想直接访问网站A(这样通过代理服务器网站A, 对网站A而言可以隐藏你自己的身份, 也就是不知道是谁访问的网站, 而认为是代理服务器访问的), 此时你就可以使用代理服务器, 在实际访问网站的时候, 你在浏览器的地址栏内和你以前一样输入你要访问的网站, 浏览器会自动先访问代理服务器, 然后代理服务器会自动给你转接到你的目标网站. 2.2 代理服务器的工作原理当用户在浏览器中设置好Proxy Server后, 你使用浏览器访问所有WWW站点的请求都不会直接发给目的主机, 而是先发给代理服务器, 代理服务器接受了客户的请求以后, 由代理服务器向目的主机发出请求, 并接受目的主机的数据, 存于代理服务器的硬盘中, 然后再由代理服务器将客户要求的数据发给客户. 2.3 代理服务器的角色和工作过程代理服务器是为了减少长距离的传送而诞生的. 它不仅可以代理客户端向服务器端提出请求, 也可以代理服务器传给客户端所需要的数据。当客户端对服务器端提出请求时, 此请求会被送到代理服务器, 然后代理服务器会检查本身是否有客户端所需要的数据. 如果有, 代理服务器便代替服务器将数据传给客户端. 而代理服务器一般都是设置距自己传输距离较近的某台代理服务器, 所以它传数据给客户端的速度会比从远程服务器传数据要快.如果代理服务器没有客户端所请求的数据, 它会去服务器获取所需的数据. 在代理服务器从服务器端取得数据传给客户端时, 自己保存一份, 待下次如果有用户提出相同的请求时, 便可以将数据直接传过去, 而不需要再去服务器端获取了. 2.4 代理分类(基于用途)代理的分类有很多, 说白了就是基于不同的协议和具体实现, 有不同类型的代理, 但是从本质上看, 原理和工作过程是类似的.Http代理: 代理客户机的http访问, 主要代理浏览器访问网页, 它的端口一般为80, 8080, 3128等.SSL代理: 支持最高128位加密强度的http代理, 可以作为访问加密网站的代理. 加密网站是指以https://开始的网站. ssl的标准端口为443.HTTP CONNECT代理: 允许用户建立TCP连接到任何端口的代理服务器, 这种代理不仅可用于HTTP, 还包括FTP, IRC, RM流服务等.FTP代理: 代理客户机上的ftp软件访问ftp服务器, 其端口一般为21, 2121.POP3代理: 代理客户机上的邮件软件用pop3方式收邮件, 其端口一般为110.Telnet代理: 能够代理通信机的telnet, 用于远程控制, 入侵时经常使用. 其端口一般为23.Socks代理: 是全能代理, 就像有很多跳线的转接板, 它只是简单地将一端的系统连接到另外一端. 支持多种协议, 包括http, ftp请求及其它类型的请求. 它分socks 4和socks 5两种类型, socks 4只支持TCP协议而socks 5支持TCP/UDP协议, 还支持各种身份验证机制等协议. 其标准端口为1080.TUNNEL代理: 经HTTPTunnet程序转换的数据包封装成http请求(Request)来穿透防火墙, 允许利用HTTP服务器做任何TCP可以做的事情, 功能相当于Socks5.文献代理: 可以用来查询数据库的代理, 通过这些代理, 可以获得互联网的相关科研学术的数据库资源, 例如查询Sciencedirect网站(简称SD), Academic Press, IEEE, SPRINGER等数据库.教育网代理: 指学术教育机构局域网通过特定的代理服务器可使无出国权限或无访问某IP段权限的计算机访问相关资源.跳板代理: 应用于跳板程序, 可以看作一种具有动态加密的特殊socks5代理, 也可直接用于PSD软件. 其端口一般为1813.Ssso代理: 代理客户机上的ssso程序访问远程网站, 具有SSL加密强度的超级代理, 支持socks.Flat代理: 代理客户机上的flatsurfer程序访问远程网站, 具有高强度加密数据流的特殊代理, 支持socks, 最大可设置三次级联, 可以设置穿越代理. 其端口一般为6700.SoftE代理: 代理客户机上的SoftEther程序访问远程网站, 应用虚拟集线器HUB和虚拟网卡技术, 具备VPN功能及多种认证方式的代理, 符合https协议. 2.5 网络代理种类包括透明代理, 匿名代理, 混淆代理, 高匿代理.这4种代理, 主要是在代理服务器端的配置不同, 导致其向目标地址发送请求时, REMOTE_ADDR, HTTP_VIA, HTTP_X_FORWARDED_FOR三个变量不同. 2.5.1 透明代理(Transparent Proxy)123REMOTE_ADDR = Proxy IPHTTP_VIA = Proxy IPHTTP_X_FORWARDED_FOR = Your IP 透明代理虽然可以直接“隐藏”你的IP地址, 但是还是可以从HTTP_X_FORWARDED_FOR来查到你是谁. 2.5.2 匿名代理(Anonymous Proxy)123REMOTE_ADDR = proxy IPHTTP_VIA = proxy IPHTTP_X_FORWARDED_FOR = proxy IP 匿名代理比透明代理进步了一点: 别人只能知道你用了代理, 无法知道你是谁. 2.5.3 混淆代理(Distorting Proxies)123REMOTE_ADDR = Proxy IPHTTP_VIA = Proxy IPHTTP_X_FORWARDED_FOR = Random IP address 如果使用了混淆代理, 别人还是能知道你在用代理, 但是会得到一个假的IP地址, 伪装的更逼真. 2.5.4 高匿代理(Elite proxy或High Anonymity Proxy)123REMOTE_ADDR = Proxy IPHTTP_VIA = not determinedHTTP_X_FORWARDED_FOR = not determined 可以看出来, 高匿代理让别人根本无法发现你是在用代理, 所以是最好的选择. 3. NATNAT: network address translation(网络地址转换)通过在专用网连接到互联网的路由器上安装NAT软件, 这种NAT路由器至少保证一个有效的全球IP地址, 这样子一来, 只需要将本地地址转化为全球IP地址即可和因特网通信. 4. 参考链接什么是代理服务器及作用？如何使用其上网？代理服务器的工作原理代理服务器的分类透明代理、匿名代理、混淆代理、高匿代理有什么区别？了解VPN, NAT, 代理服务器的原理]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM垃圾回收]]></title>
    <url>%2F2018%2F09%2F24%2FJVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[1. 前言垃圾回收是JVM里面非常重要的一块, 这部分主要记录垃圾回收相关的知识. 2. 垃圾回收概述JVM的内存结构包括五大区域: 程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆区和方法区则不一样! 这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。 垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法！ 3. 堆区如何判断是否需要回收3.1 引用计数算法在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。 3.1.1 优缺点优点：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。缺点：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0。 3.1.2 举例123456789101112public class ReferenceFindTest &#123; public static void main(String[] args) &#123; MyObject object1 = new MyObject(); MyObject object2 = new MyObject(); object1.object = object2; object2.object = object1; object1 = null; object2 = null; &#125;&#125; 这段代码是用来验证引用计数算法不能检测出循环引用。最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为0，那么垃圾收集器就永远不会回收它们。 3.2 可达性分析算法可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。 在Java语言中，可作为GC Roots的对象包括下面几种: a) 虚拟机栈中引用的对象（栈帧中的本地变量表）；b) 方法区中类静态属性引用的对象；c) 方法区中常量引用的对象；d) 本地方法栈中JNI（Native方法）引用的对象。 3.3 Java中的引用无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在Java语言中，将引用又分为强引用、软引用、弱引用、虚引用4种，这四种引用强度依次逐渐减弱。 3.3.1 强引用在程序代码中普遍存在的，类似 Object obj = new Object() 这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 1Object obj = new Object() 3.3.2 软引用用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。 1234Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null;sf.get();//有时候会返回null 3.3.3 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 12345Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null;wf.get();//有时候会返回nullwf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾 3.3.4 虚引用也叫幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的作用是能在这个对象被收集器回收时收到一个系统通知。 12345Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj);obj=null;pf.get();//永远返回nullpf.isEnQueued();//返回是否从内存中已经删除 3.4 对象死亡(被回收)前的最后一次挣扎即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。 第一次标记：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记；第二次标记：第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。在finalize()方法中没有重新与引用链建立关联关系的，将被进行第二次标记。 第二次标记成功的对象将真的会被回收，如果对象在finalize()方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。 4. 方法区如何判断是否需要回收方法区存储内容是否需要回收的判断可就不一样咯。方法区主要回收的内容有：废弃常量(其实就是运行时常量池, 现在已经迁移到堆区了)和无用的类。 对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件： 1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；2. 加载该类的ClassLoader已经被回收；3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 5. 常用的垃圾收集算法5.1 标记-清除算法标记-清除算法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如下图所示。标记-清除算法不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。 5.2 复制算法复制算法的提出是为了克服句柄的开销和解决内存碎片的问题。它开始时把堆分成 一个对象 面和 多个空闲 面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾收集器就从根集合（GC Roots）中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。 5.3 标记-整理算法标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。具体流程见下图： 5.4 分代收集算法分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。新生代一般使用复制算法, 而老年代一般使用 标记-整理 或 标记-清除 算法. 5.4.1 年轻代的回收算法 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。 新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。 5.4.2 年老代的回收算法 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 内存比新生代也大很多(大概比例是2:1)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。 5.4.3 持久代的回收算法用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代也称方法区，具体的回收可参见上面 4. 方法区如何判断是否需要回收. 6. HotSpot算法实现6.1 枚举根节点6.1.1 GC停顿在进行对象的可达性分析时，必须在一个能确保一致性的快照中进行(一致性即在整个分析期间，整个执行系统不可以出现分析过程中，对象引用关系还在不断变化的过程)，该点不满足的话分析结果准确性就无法得到保证。所以GC进行时必须停顿所有Java线程。所以枚举根节点时必须要停顿。这件事件就是Stop The World(STW). 6.1.2 HotSpot枚举的实现在HotSpot的实现中，是使用一组称为OopMap（Ordinary Object Pointer：普通对象指针）的数据结构来实现的。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。所以GC扫描时就可以直接得知这些信息。 6.2 安全点6.2.1 安全点的位置的作用及选取安全点即何时生成OopMap的位置。程序执行时并非在所有地方都停顿下来开始GC，只有在到达安全点时才能停顿。安全点的选定基本是以程序“是否具有让程序长时间执行的特征”为标准进行选定的–因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以这些功能的指令才会产生Safepoint。 6.2.2 如何让所有的线程在最近的安全点停顿下来抢先式中断（Preemptive Suspension）：不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让他跑到安全点上。现在已不采用此中方式。 主动式中断（Voluntary Suspension）：当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。 6.3 安全区域6.3.1 问题提出安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的安全点。但是程序不执行的时候，没有分配CPU时间，典型的例子就是线程处于sleep状态或者blocked状态，这时候线程无法响应JVM的中断请求，走到安全的地方去中断挂起。所以这就需要安全区域来解决。 6.3.2 概念安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。可以把安全区域看做是扩展了的安全点。在线程执行到安全区域中的代码时，首先表示自己已经进入安全区域，在这段时间里JVM要发起GC时，就不用管标识自己为安全区域状态的线程了。在线程要离开安全区域时，要检查系统是否已经完成了根节点枚举或者是整个GC过程，如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开安全区域的信号为止。 7. 垃圾回收器GC实现目标: 准确、高效、低停顿、空闲内存规整. 7.1 新生代垃圾收集器7.1.1 Serial收集器Serial收集器是Hotspot运行在Client模式下的默认新生代收集器, 它的特点是 只用一个CPU/一条收集线程去完成GC工作, 且在进行垃圾收集时必须暂停其他所有的工作线程(“Stop The World” -后面简称STW).虽然是单线程收集, 但它却简单而高效, 在VM管理内存不大的情况下(收集几十M~一两百M的新生代), 停顿时间完全可以控制在几十毫秒~一百多毫秒内. 7.1.2 ParNew收集器ParNew收集器其实是前面Serial的多线程版本, 除使用多条线程进行GC外, 包括Serial可用的所有控制参数、收集算法、STW、对象分配规则、回收策略等都与Serial完全一样(也是VM启用CMS收集器-XX: +UseConcMarkSweepGC的默认新生代收集器).由于存在线程切换的开销, ParNew在单CPU的环境中比不上Serial, 且在通过超线程技术实现的两个CPU的环境中也不能100%保证能超越Serial. 但随着可用的CPU数量的增加, 收集效率肯定也会大大增加(ParNew收集线程数与CPU的数量相同, 因此在CPU数量过大的环境中, 可用-XX:ParallelGCThreads参数控制GC线程数). 7.1.3 Parallel Scavenge收集器与ParNew类似, Parallel Scavenge也是使用复制算法, 也是并行多线程收集器. 但与其他收集器关注尽可能缩短垃圾收集时间不同, Parallel Scavenge更关注系统吞吐量: 系统吞吐量=运行用户代码时间 / (运行用户代码时间+垃圾收集时间) 停顿时间越短就越适用于用户交互的程序-良好的响应速度能提升用户的体验;而高吞吐量则适用于后台运算而不需要太多交互的任务-可以最高效率地利用CPU时间,尽快地完成程序的运算任务. Parallel Scavenge提供了如下参数设置系统吞吐量: Parallel Scavenge参数 描述 MaxGCPauseMillis (毫秒数) 收集器将尽力保证内存回收花费的时间不超过设定值, 但如果太小将会导致GC的频率增加. GCTimeRatio (整数:0 &lt; GCTimeRatio &lt; 100) 是垃圾收集时间占总时间的比率 -XX:+UseAdaptiveSizePolicy 启用GC自适应的调节策略: 不再需要手工指定-Xmn、-XX:SurvivorRatio、-XX:PretenureSizeThreshold等细节参数, VM会根据当前系统的运行情况收集性能监控信息, 动态调整这些参数以提供最合适的停顿时间或最大的吞吐量 7.2 老年代7.2.1 Serial Old收集器Serial Old是Serial收集器的老年代版本, 同样是单线程收集器,使用“标记-整理”算法:Serial Old应用场景如下:JDK 1.5之前与Parallel Scavenge收集器搭配使用;作为CMS收集器的后备预案, 在并发收集发生Concurrent Mode Failure时启用(见下:CMS收集器). 7.2.2 Parallel Old收集器Parallel Old是Parallel Scavenge收老年代版本, 使用多线程和“标记－整理”算法, 吞吐量优先, 主要与Parallel Scavenge配合在 注重吞吐量 及 CPU资源敏感 系统内使用: 7.2.3 CMS收集器CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器，它非常符合那些集中在互联网站或者B/S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。从名字上（“Mark Sweep”）就可以看出它是基于“标记-清除”算法实现的。 CMS收集器工作的整个流程分为以下4个步骤： 初始标记（CMS initial mark）：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。并发标记（CMS concurrent mark）：进行GC Roots Tracing的过程，在整个过程中耗时最长。重新标记（CMS remark）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。并发清除（CMS concurrent sweep）由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。通过下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间： 7.2.3.1 优点CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿，因此CMS收集器也被称为并发低停顿收集器（Concurrent Low Pause Collector）。 7.2.3.2 缺点 对CPU资源非常敏感. 其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。 无法处理浮动垃圾（Floating Garbage）. 可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就被称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。 标记-清除算法导致的空间碎片. CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象。 7.3 G1收集器G1（Garbage-First）收集器是当今收集器技术发展最前沿的成果之一，它是一款面向服务端应用的垃圾收集器，HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。 7.3.1 G1的特点与其他GC收集器相比，G1具备如下特点： 并行与并发 G1 能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。 分代收集 与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。 空间整合 G1从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。这意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。 可预测的停顿 这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。 7.3.2 横跨整个堆内存在G1之前的其他收集器进行收集的范围都是整个新生代或者老生代，而G1不再是这样。G1在使用时，Java堆的内存布局与其他收集器有很大区别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合。 7.3.3 建立可预测的时间模型G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。 7.3.4 避免全堆扫描——Remembered SetG1把Java堆分为多个Region，就是“化整为零”。但是Region不可能是孤立的，一个对象分配在某个Region中，可以与整个Java堆任意的对象发生引用关系。在做可达性分析确定对象是否存活的时候，需要扫描整个Java堆才能保证准确性，这显然是对GC效率的极大伤害。 为了避免全堆扫描的发生，虚拟机为G1中每个Region维护了一个与之对应的Remembered Set。虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。 7.3.5 G1收集器的运作步骤如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤： 初始标记（Initial Marking） 仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程，但耗时很短。 并发标记（Concurrent Marking） 从GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。 最终标记（Final Marking） 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。 筛选回收（Live Data Counting and Evacuation） 首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 通过下图可以比较清楚地看到G1收集器的运作步骤中并发和需要停顿的阶段（Safepoint处）： 8. 内存分配策略Java的自动内存管理最终可以归结为自动化地解决了两个问题： 给对象分配内存 回收分配给对象的内存 对象的内存分配通常是在堆上分配（除此以外还有可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是固定的，实际取决于垃圾收集器的具体组合以及虚拟机中与内存相关的参数的设置。至于内存回收策略，在上文已经描述得很详尽了。 8.1 对象优先在Eden区分配大多数情况下，对象在新生代的Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。 8.2 大对象直接进入老年代所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是很长的字符串以及数组。大对象对虚拟机的内存分配来说是一个坏消息（尤其是遇到朝生夕灭的“短命大对象”，写程序时应避免），经常出现大对象容易导致内存还有不少空间时就提前触发GC以获取足够的连续空间来安置它们。 虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用复制算法回收内存）。 8.3 长期存活的对象将进入老年代既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。 8.4 动态对象年龄判定为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。 8.5 空间分配担保在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。 前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。 取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。 8.6 Full GC的触发条件对于Minor GC，其触发条件非常简单，当Eden区空间满时，就将触发一次Minor GC。而Full GC则相对复杂，因此本节我们主要介绍Full GC的触发条件。 8.6.1 调用System.gc()此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存，可通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc()。 8.6.2 老年代空间不足老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行Full GC后空间仍然不足，则抛出如下错误： Java.lang.OutOfMemoryError: Java heap space 为避免以上两种状况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。 8.6.3 空间分配担保失败前文介绍过，使用复制算法的Minor GC需要老年代的内存空间作担保，如果出现了HandlePromotionFailure担保失败，则会触发Full GC。 8.6.4 JDK 1.7及以前的永久代空间不足在JDK 1.7及以前，HotSpot虚拟机中的方法区是用永久代实现的，永久代中存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息： java.lang.OutOfMemoryError: PermGen space 为避免PermGen占满造成Full GC现象，可采用的方法为增大PermGen空间或转为使用CMS GC。 在JDK 1.8中用元空间替换了永久代作为方法区的实现，元空间是本地内存，因此减少了一种Full GC触发的可能性。 8.6.5 Concurrent Mode Failure执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是CMS GC时当前的浮动垃圾过多导致暂时性的空间不足触发Full GC），便会报Concurrent Mode Failure错误，并触发Full GC。 9. 参考链接&lt;&lt;深入理解Java虚拟机—-JVM高级特性与最佳实践&gt;&gt;(第二版, 周志明)扒一扒JVM的垃圾回收机制，下次面试你准备好了吗Java四种引用包括强引用，软引用，弱引用，虚引用。HotSpot算法实现JVM初探：内存分配、GC原理与垃圾收集器深入理解JVM(3)——7种垃圾收集器深入理解JVM(2)——GC算法与内存分配策略]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程安全和锁优化]]></title>
    <url>%2F2018%2F09%2F24%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1. 前言在公司开发, 高并发是不可避免需要考虑的. 这部分记录JVM中的线程安全和锁优化技术. 2. 线程安全2.1 线程安全定义当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的； 2.2 线程安全种类分为以下5类: 不可变, 绝对线程安全, 相对线程安全, 线程兼容, 线程对立; 2.2.1 不可变对象该对象一定是线程安全的, 无论是对象的方法实现还是方法的调用者, 都不需要采取任何的线程安全保障措施; 如果共享数据是一个基本数据类型, 那么只要在定义时使用 final 关键字修饰它就可以保证它是不可变的; 不妨想想java.lang.String类的对象: 它是一个典型的不可变对象, 调用它的substring(), replace(), concat() 这些方法都不会影响它原来的值, 只会返回一个新构造的字符串对象; 2.2.2 绝对线程安全绝对安全的线程的类, 完全符合线程安全定义的定义, 但在Java API中标注自己是线程安全的类, 大多数都不是绝对的线程安全. 2.2.3 相对线程安全是通常意义上的线程安全, 它需要保证对这个对象单独的操作是线程安全的, 在调用的时候不需要做额外的保证措施. 但是对于一些特定顺序的连续调用, 就可能需要在调用端使用额外的同步手段来保证调用的正确性.在Java语言中, 大部分线程安全类都属于这种类型.如Vector, Hashtable, Collections的synchronizedCollection()方法包装的集合等. 2.2.4 线程兼容线程兼容是指对象本身不是线程安全的, 但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中是可以安全使用的. Java API中的大部分的类都是属于线程兼容的.如ArrayList和HashMap等. 2.2.5 线程对立线程对立是指无论调用端是否采取了同步措施, 都无法在多线程环境中使用的代码. 线程对立这种排斥多线程的代码是很少出现的, 通常都是有害的, 应当避免.如Thread类的suspend()和resume()方法. 如果两个线程同时持有一个线程对象, 两个线程并发对该线程对象执行suspend()和resume()方法, 无论是否采用了同步, 都存在死锁风险. 2.3 线程安全的实现方法2.3.1 互斥同步 互斥同步: 是常见的并发正确性保障手段; 同步: 是指在多个线程并发访问共享数据时, 保证共享数据在同一个时刻被一个线程使用. 互斥: 互斥是实现同步的一种手段; 临界区, 互斥量和信号量都是主要的互斥实现方式. 因此, 在这4个字里面, 互斥是因, 同步是果; 互斥是方法, 同步是目的; 最基本的互斥同步手段就是 synchronized关键字: synchronized关键字经过 编译之后, 会在同步块的前后分别形成 monitorenter 和 monitorexit 这个两个字节码指令, 这两个字节码都需要一个 reference类型的参数来指明要锁定和解锁的对象; 如果java程序中的synchronized明确指定了对象参数, 那就是这个对象的reference; 如果没有明确指定, 那就根据 synchronized修饰的实例方法还是类方法, 去取对应的对象实例或Class 对象来作为锁对象; 根据虚拟机规范的要求: 在执行monitorenter指令时, 如果这个对象没有锁定或当前线程已经拥有了那个对象的锁, 锁的计数器加1, 相应的, 在执行 monitorexit 指令时会将锁计数器减1; 当计数器为0时, 锁就被释放了; 对于monitorenter 和 monitorexit 的行为描述中, 有两点需要注意:a. synchronized同步块对同一条线程来说是可重入的, 不会出现自己把自己锁死的问题;b. 同步块在已进入的线程执行完之前, 会阻塞后面其他线程 的进入; 除了synchronized之外, 还可以使用 java.util.concurrent 包中的重入锁(ReentrantLock)来实现同步; 2.3.1.1 Synchronized与ReentrantLock比较2.3.1.1.1 相似点这两种同步方式有很多相似之处, 它们都是加锁方式同步, 而且都是阻塞式的同步, 也就是说当如果一个线程获得了对象锁, 进入了同步块, 其他访问该同步块的线程都必须阻塞在同步块外面等待, 而进行线程阻塞和唤醒的代价是比较高的 2.3.1.1.2 区别这两种方式最大区别就是对于Synchronized来说, 它是java语言的关键字, 是原生语法层面的互斥, 需要jvm实现.而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁, 需要lock()和unlock()方法配合try/finally语句块来完成. 2.3.1.1.3 Synchronized的基本使用Synchronized进过编译, 会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令. 在执行monitorenter指令时, 首先要尝试获取对象锁. 如果这个对象没被锁定, 或者当前线程已经拥有了那个对象锁, 把锁的计算器加1, 相应的, 在执行monitorexit指令时会将锁计算器就减1, 当计算器为0时, 锁就被释放了. 如果获取对象锁失败, 那当前线程就要阻塞, 直到对象锁被另一个线程释放为止. 123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; Runnable runnable = new MyThread(); new Thread(runnable, "t1").start(); new Thread(runnable, "t2").start(); &#125;&#125;class MyThread implements Runnable &#123; @Override public void run() &#123; synchronized (this) &#123; for(int i=0;i&lt;10;i++) System.out.println(Thread.currentThread().getName()+":"+i); &#125; &#125;&#125; 运行结果: 1234567891011121314151617181920t1:0t1:1t1:2t1:3t1:4t1:5t1:6t1:7t1:8t1:9t2:0t2:1t2:2t2:3t2:4t2:5t2:6t2:7t2:8t2:9 2.3.1.1.4 ReentrantLock的基本使用由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁, 相比Synchronized, ReentrantLock类提供了一些高级功能, 主要有以下3项: 等待可中断, 持有锁的线程长期不释放的时候, 正在等待的线程可以选择放弃等待, 这相对于Synchronized来说可以避免出现死锁的情况。 公平锁, 多个线程等待同一个锁时, 必须按照申请锁的时间顺序获得锁, Synchronized锁非公平锁, ReentrantLock默认的构造函数是创建的非公平锁, 可以通过参数true设为公平锁, 但公平锁表现的性能不是很好. 锁绑定多个条件, 一个ReentrantLock对象可以同时绑定对个对象. 1234567891011121314151617181920212223import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Main &#123; public static void main(String[] args) &#123; Runnable runnable = new MyThread(); new Thread(runnable, "t1").start(); new Thread(runnable, "t2").start(); &#125;&#125;class MyThread implements Runnable &#123; private Lock lock=new ReentrantLock(); @Override public void run() &#123; lock.lock(); try&#123; for(int i=0;i&lt;5;i++) System.out.println(Thread.currentThread().getName()+":"+i); &#125;finally&#123; lock.unlock(); &#125; &#125;&#125; 运行结果: 12345678910t1:0t1:1t1:2t1:3t1:4t2:0t2:1t2:2t2:3t2:4 关于synchronized 和 ReentrantLock 性能的分析: 多线程环境下 synchronized的吞吐量下降得非常严重, 而 ReentrantLock 则能基本保持在同一个比较稳定的水平上; 与其说ReentrantLock性能好, 还不如说 synchronized还有非常大的优化余地; 虚拟机在未来的性能改进中肯定也会更加偏向于原生的 synchronized, 所以还是提倡在 synchronized能实现需求的情况下, 优先考虑使用 synchronized 来进行同步; 2.3.2 互斥同步非阻塞同步 阻塞同步(互斥同步)的问题: 就是进行线程阻塞和唤醒所带来的性能问题, 互斥同步属于一种悲观的并发策略, 无论共享数据是否真的会出现竞争, 它都要进行加锁, 用户态核心态转换, 维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作; 非阻塞同步定义: 基于冲突检测的乐观并发策略, 通俗的说, 就是先进行操作, 如果没有其他线程争用共享数据, 那操作就成功了; 如果共享数据有争用, 产生了冲突, 那就再采用其他的补偿措施, 这种乐观的并发策略的许多实现都不需要把线程挂起, 因此这种同步操作称为 非阻塞同步; 为什么作者要说使用乐观并发策略需要“硬件指令集的发展”才能进行呢? 因为 我们需要 操作 和 冲突检测 这两个步骤具备原子性, 靠什么来保证呢?a. 硬件: 保证一个从语义上看起来需要多次操作的行为只通过一次处理器指令就能完成 2.3.2.1 CAS(Compare-and-Swap)操作的使用1234567891011121314151617181920212223242526272829303132333435363738394041// Atomic 变量自增运算测试(incrementAndGet 方法的原子性)public class AtomicTest &#123; public static AtomicInteger race = new AtomicInteger(0); public static void increase() &#123; // 输出正确结果，一切都要归功于 incrementAndGet 方法的原子性 race.incrementAndGet(); &#125; public static final int THREADS_COUNT = 20; public static void main(String[] args) throws Exception &#123; Thread[] threads = new Thread[THREADS_COUNT]; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 10000; j++) &#123; increase(); &#125; &#125; &#125;); threads[i].start(); &#125; while(Thread.activeCount() &gt; 1) &#123; Thread.yield(); &#125; System.out.println(race); &#125; /** * incrementAndGet() 方法的JDK 源码 * Atomically increment by one the current value. * @return the updated value */ public final int incrementAndGet() &#123; for(;;) &#123; int current = get(); int next = current + 1; if(compareAndSet(current,next)) &#123; return next; &#125; &#125; &#125;&#125; 2.3.2.2 CAS操作的ABA问题和解决方法 问题描述:如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就说它的值没有被其他线程改变过了吗? 如果在这段期间它的值曾经被改为了B, 之后又改回了A, 那CAS操作就会误认为它从来没有被改变过, 这个漏洞称为 CAS操作的 ABA问题; 解决方法:J.U.C 包为了解决这个问题, 提供了一个带有标记的原子引用类“AtomicStampedReference”, 它可以通过控制变量值的version 来保证CAS的正确性. 不过目前来说这个类比较鸡肋, 大部分cases 下 ABA问题 不会影响程序并发的正确性, 如果需要解决ABA问题, 改用传统的互斥同步可能会比原子类更高效; 2.3.3 无同步方案如果一个方法本来就不涉及共享数据, 那它自然就无须任何同步措施去保证正确性, 因此会有一些代码天生就是线程安全的; 下面介绍两类线程安全代码: 第一类线程安全代码——可重入代码：也叫作纯代码，可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误;a. 所有的可重入代码都是线程安全的；b. 如何判断代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同 第二类线程安全代码——线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能够保证在同一线程中执行？ 如果能保证，我们就可以把共享数据的可见范围限制在同一个线程内，这样，无需同步也可以保证线程间不出现数据争用问题； 3. 锁优化锁优化技术(HotSpot虚拟机而言)包括适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等。这些技术都是为了在线程之间更高效地共享数据以及解决竞争问题，从而提高程序效率。 3.1 自旋锁与自适应自旋3.1.1 问题前文中我们提到，互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程很不值得； 3.1.2 自旋锁定义针对上面的问题, 提出的解决方法:为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁； jdk1.6中 自旋锁是默认开启的，可以使用 -XX:+UseSpinning 参数来开启； 自旋等待的时间必须要有一定的限度： 如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10，用户可以用参数 -XX:PreBlockSpin 来更改； 3.1.3 自适应自旋定义 自适应自旋锁：jdk1.6 中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定: 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个cycle； 如果对于某个锁，自旋很少成功获得过， 那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源； 3.2 锁消除3.2.1 定义锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检查到不可能存在共享数据竞争的锁进行消除； 3.2.2 判定依据来源于逃逸分析的数据支持；如果判定在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行了； 3.3 锁粗化3.3.1 问题描述如果一系列的连续操作都对同一个对象反复加锁和解锁, 甚至加锁操作是出现在循环体中的, 那即使没有线程竞争, 频繁地进行互斥同步操作也会导致不必要的性能损耗; 3.3.2 锁粗化的定义如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁, 将会把加锁同步的范围扩展(粗化)到整个操作序列的外部; 3.4 轻量级锁3.4.1 重量级锁定义使用操作系统互斥量来实现的传统锁； 3.4.2 轻量级锁的作用是在没有多线程竞争的前提下, 减少传统的重量级锁使用操作系统互斥量产生的性能消耗; 3.4.3 对象头Mark WordHotSpot虚拟机的对象头分为两部分信息:第一部分:用于存储对象自身的运行时数据, 如哈希码, GC分代年龄等; 这部分数据的长度在32位和64位的虚拟机中分别为 32bit 和 64bit, 官方称它为 Mark Word, 它是实现轻量级锁和偏向锁的关键;第二部分:用于存储指向方法区对象类型数据的指针, 如果是数组对象的话, 还会有一个额外的部分用于存储数组长度; 对象头信息是与对象自身定义的数据无关的额外存储成本, 考虑到虚拟机的空间效率, Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息, 它会工具对象的状态复用自己的存储空间; HotSpot 虚拟机对象头Mark Word 如下图所示: 3.4.4 实现逻辑在代码进入同步块的时候: 轻量级锁的加锁过程:step1. 如果此同步对象没有被锁定(锁标志位为01状态): 虚拟机首先将在当前线程的栈帧中建立一个名为 锁记录(Lock Record) 的空间, 用于存储对象目前的Mark Word 的拷贝;step2. 然后, 虚拟机将使用CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record的指针; 并将线程栈帧中的Lock Record里的owner指针指向Object的 Mark Word.step3. 如果这个更新工作成功了, 那么这个线程就拥有了该对象的锁, 并且对象Mark Word的锁标志位将转变为 00, 即表示 此对象处于轻量级锁定状态;step4. 如果这个更新失败了, 虚拟机首先会检查对象的Mark Word 是否指向当前线程的栈帧, 如果指向, 则说明当前线程已经拥有了这个对象的锁, 那就可以直接进入同步块继续执行, 否则说明这个锁对象以及被其他线程抢占了. 如果有两条以上的线程争用同一个锁, 那轻量级锁就不再有效, 要膨胀为重量级锁, 锁标志的状态值变为 10, Mark Word中存储的就是指向重量级(互斥量)的指针, 后面等待锁的线程也要进入阻塞状态; 轻量级锁的解锁过程:step1. 如果对象的Mark Word仍然指向着线程的锁记录, 那就用CAS 操作把对象当前的Mark Word 和 线程中复制的 Dispatched Mard Word替换回来;step2. 如果替换成功, 整个同步过程就over了;step3. 如果替换失败, 说明有其他线程尝试过获取该锁, 那就要在释放锁的同时, 唤醒被挂起的线程; 3.4.5 结论 轻量级锁能提升程序同步性能的依据是: 对于绝大部分的锁，在整个同步周期内都是不存在竞争的； 如果没有竞争，轻量级锁使用CAS 操作避免了使用互斥量的开销；但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS 操作，因此在有竞争的case下， 轻量级锁会比传统的重量级锁更慢； 3.5 偏向锁3.5.1 偏向锁的目的消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能； 如果说轻量级锁是在无竞争的情况使用CAS 操作去消除同步使用的互斥量：那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS 操作都不做了； 它的意思是这个锁会偏向于 第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步； 3.5.2 偏向锁的原理若当前虚拟机启用了偏向锁，那么，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为01， 即偏向模式；同时使用CAS 操作把获取到这个锁的线程的ID 记录在对象的 Mark Word之中，如果 CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作； 当有另一个线程去尝试获取这个锁时，偏向模式就结束了：根据锁对象目前是否处于被锁定的状态， 撤销偏向后恢复到未锁定（标志位为01）或轻量级锁定（标志位为00）的状态，后续的同步操作就如上面介绍的轻量级锁那样执行； 3.5.3 结论 偏向锁可以提高带有同步但无竞争的程序性能； 如果程序中大多数的锁总是被多个不同的线程访问：那偏向模式是多余的； 3.5.4 偏向锁流程偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会尝试消除它身上的偏向锁，将锁恢复到标准的轻量级锁。因此 流程是这样的 偏向锁-&gt;轻量级锁-&gt;重量级锁 简单的讲，就是在锁对象的对象头中有个ThreadId字段，这个字段如果是空的，第一次获取锁的时候，就将自身的ThreadId写入到锁的ThreadId字段内，将锁头内的是否偏向锁的状态位置1.这样下次获取锁的时候，直接检查ThreadId是否和自身线程Id一致，如果一致，则认为当前线程已经获取了锁，因此不需再次获取锁，略过了轻量级锁和重量级锁的加锁阶段。提高了效率。 4. synchronized原理图附上一张synchronized原理图, 帮助理解整个过程. 5. 参考链接&lt;&lt;深入理解Java虚拟机—-JVM高级特性与最佳实践&gt;&gt;(第二版, 周志明)【JVM】线程安全与锁优化java的两种同步方式， Synchronized与ReentrantLock的区别jvm(13)-线程安全与锁优化浅谈偏向锁、轻量级锁、重量级锁]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM类加载机制]]></title>
    <url>%2F2018%2F09%2F24%2FJVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1. 前言作为一名Java后台开发的程序员, 深入理解JVM, 重要性不言而喻, 这篇文章主要是记录JVM类加载机制相关知识. 2. 类加载的时机2.1 初始化情况JVM类加载分为5个过程: 加载, 验证, 准备, 解析, 初始化, 使用, 卸载, 如下图所示:那么, 什么情况下虚拟机需要开始初始化一个类呢? 这在虚拟机规范中是有严格规定的, 虚拟机规范指明, 有且只有 五种情况必须立即对类进行初始化(而这一过程自然发生在加载, 验证, 准备之后): 遇到new, getstatic, putstatic或invokestatic这四条字节码指令, 如果类没有进行过初始化, 则需要先触发其初始化. 使用java.lang.reflect包的方法对类进行反射调用的时候, 如果类没有进行过初始化, 则需要先触发其初始化. 当初始化一个类的时候, 如果发现其父类还没有进行过初始化, 则需要先触发其父类的初始化. 当虚拟机启动时, 户需要指定一个要执行的主类(包含main()方法的那个类), 虚拟机会先初始化这个主类. 当使用jdk1.7动态语言支持时, 如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄, 并且这个方法句柄所对应的类没有进行初始化, 则需要先出触发其初始化. 2.2 主动引用与被动引用注意, 对于这五种会触发类进行初始化的场景, 虚拟机规范中使用了一个很强烈的限定语: “有且只有”, 这五种场景中的行为称为对一个类进行 主动引用. 除此之外, 所有引用类的方式, 都不会触发初始化, 称为 被动引用.特别需要指出的是, 类的实例化与类的初始化是两个完全不同的概念: 类的实例化是指创建一个类的实例(对象)的过程; 类的初始化是指为类中各个类成员(被static修饰的成员变量)赋初始值的过程, 是类生命周期中的一个阶段. 2.3 被动引用经典示例1.通过子类引用父类的静态字段, 不会导致子类初始化 12345678public class Father &#123; static &#123; System.out.println("父类初试化"); &#125; public static void work()&#123; System.out.println("父类开始工作"); &#125;&#125; 12345public class Son extends Father &#123; static &#123; System.out.println("子类初试化"); &#125;&#125; 12345public class Main &#123; public static void main(String[] args) &#123; Son.work(); &#125;&#125; 运行结果: 12父类初试化父类开始工作 2.通过数组定义来引用类, 不会触发此类的初始化 12345public class Main &#123; public static void main(String[] args) &#123; Son[] sons = new Son[10]; &#125;&#125; 运行结果: 12 3.常量在编译阶段会存入调用类的常量池中, 本质上并没有直接引用到定义常量的类, 因此不会触发定义常量的类的初始化 123456public class Son&#123; static &#123; System.out.println("子类初试化"); &#125; public static final String message = "Hello World!";&#125; 12345public class Main &#123; public static void main(String[] args) &#123; System.out.println(Son.message); &#125;&#125; 运行结果: 1Hello World! 3. 类加载的过程3.1 加载 通过一个类的全限定名来获取定义此类的二进制字节流. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构. 在内存中生成一个代表这个类的java.lang.Class对象, 作为方法区这个类的各种数据的访问入口. 注意: JVM中的ClassLoader类加载器加载Class发生在此阶段. 3.2 验证 文件格式的验证 元数据验证 字节码验证 符号引用验证 3.3 准备准备阶段是正式为类变量(static 成员变量)分配内存并设置类变量初始值(零值)的阶段, 这些变量所使用的内存都将在方法区中进行分配. 这时候进行内存分配的仅包括类变量 , 而不包括实例变量, 实例变量将会在对象实例化时随着对象一起分配在堆中. 其次, 这里所说的初始值“通常情况”下是数据类型的零值, 假设一个类变量的定义为: 1public static int value = 123; 那么, 变量value在准备阶段过后的值为0而不是123.因为这时候尚未开始执行任何java方法, 而把value赋值为123的putstatic指令是程序被编译后, 存放于类构造器方法&lt; clinit &gt;()之中, 所以把value赋值为123的动作将在初始化阶段才会执行.至于“特殊情况”是指: 当类字段的字段属性是ConstantValue时, 会在准备阶段初始化为指定的值, 所以标注为final之后, value的值在准备阶段初始化为123而非0. 1public static final int value = 123; 注意:只设置类中的静态变量(方法区中), 不包括实例变量(堆内存中), 实例变量是在对象实例化的时候初始化分配值的. 3.4 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程. 符号引用: 简单的理解就是字符串, 比如引用一个类, java.util.ArrayList 这就是一个符号引用, 字符串引用的对象不一定被加载.直接引用: 指针或者地址偏移量. 引用对象一定在内存(已经加载). 3.5 初始化 执行类构造器&lt; clinit &gt; 初始化静态变量, 静态块中的数据等(一个类加载器只会初始化一次) 子类的&lt; clinit &gt;调用前保证父类的&lt; clinit &gt;被调用 注意:&lt; clinit &gt;是线程安全的, 执行&lt; clinit &gt;的线程需要先获取锁才能进行初始化操作, 保证只有一个线程能执行&lt; clinit &gt; 4. 类加载器java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称, 找到或者生成其对应的字节代码, 然后从这些字节代码中定义出一个Java 类, 即 java.lang.Class类的一个实例.ClassLoader提供了一系列的方法, 比较重要的方法如: 4.1 类加载器的树状层次结构Java 中的类加载器大致可以分成两类, 一类是系统提供的, 另外一类则是由 Java 应用开发人员编写的. 4.1.1 引导类加载器(Bootstrap ClassLoader)它用来加载 Java 的核心库(jre/lib/rt.jar), 是用原生C++代码来实现的, 并不继承自java.lang.ClassLoader. 4.1.2 扩展类加载器(Extensions ClassLoader)它用来加载 Java 的扩展库(jre/ext/*.jar). Java 虚拟机的实现会提供一个扩展库目录. 该类加载器在此目录里面查找并加载 Java 类. 4.1.3 系统类加载器(System ClassLoader)它根据 Java 应用的类路径(CLASSPATH)来加载 Java 类. 一般来说, Java 应用的类都是由它来完成加载的. 可以通过 ClassLoader.getSystemClassLoader()来获取它. 4.1.4 自定义类加载器(Custom ClassLoader)除了系统提供的类加载器以外, 开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器, 以满足一些特殊的需求. 4.1.5 测试12345678910public class Main &#123; public static void main(String[] args) &#123; //application class loader System.out.println(ClassLoader.getSystemClassLoader()); //extensions class loader System.out.println(ClassLoader.getSystemClassLoader().getParent()); //bootstrap class loader System.out.println(ClassLoader.getSystemClassLoader().getParent().getParent()); &#125;&#125; 结果: 123sun.misc.Launcher$AppClassLoader@18b4aac2sun.misc.Launcher$ExtClassLoader@4554617cnull 可以看出ClassLoader类是由AppClassLoader加载的. 他的父类是ExtClassLoader, ExtClassLoader的父亲无法获取是因为它是用C++实现的. 4.2 双亲委派机制某个特定的类加载器在接到加载类的请求时, 首先将加载任务委托交给父类加载器, 父类加载器又将加载任务向上委托, 直到最父类加载器, 如果最父类加载器可以完成类加载任务, 就成功返回, 如果不行就向下传递委托任务, 由其子类加载器进行加载. 4.2.1 双亲委派机制的好处保证java核心库的安全性(例如: 如果用户自己写了一个java.lang.String类就会因为双亲委派机制不能被加载, 不会破坏原生的String类的加载) 4.2.2 代理模式与双亲委派机制相反, 代理模式是先自己尝试加载, 如果无法加载则向上传递. Tomcat就是代理模式. 4.3 双亲委派模型的破坏者-线程上下文类加载器在Java应用中存在着很多服务提供者接口(Service Provider Interface, SPI), 这些接口允许第三方为它们提供实现, 如常见的 SPI 有 JDBC, JNDI等, 这些 SPI 的接口属于 Java 核心库, 一般存在rt.jar包中, 由Bootstrap类加载器加载, 而 SPI 的第三方实现代码则是作为Java应用所依赖的 jar 包被存放在classpath路径下, 由于SPI接口中的代码经常需要加载具体的第三方实现类并调用其相关方法, 但SPI的核心接口类是由引导类加载器来加载的, 而Bootstrap类加载器无法直接加载SPI的实现类, 同时由于双亲委派模式的存在, Bootstrap类加载器也无法反向委托AppClassLoader加载器SPI的实现类. 在这种情况下, 我们就需要一种特殊的类加载器来加载第三方的类库, 而线程上下文类加载器就是很好的选择.线程上下文类加载器(contextClassLoader)是从 JDK 1.2 开始引入的, 我们可以通过java.lang.Thread类中的getContextClassLoader()和 setContextClassLoader(ClassLoader cl)方法来获取和设置线程的上下文类加载器. 如果没有手动设置上下文类加载器, 线程将继承其父线程的上下文类加载器, 初始线程的上下文类加载器是AppClassLoader, 在线程中运行的代码可以通过此类加载器来加载类和资源, 如下图所示, 以jdbc.jar加载为例.从图可知rt.jar核心包是由Bootstrap类加载器加载的, 其内包含SPI核心接口类, 由于SPI中的类经常需要调用外部实现类的方法, 而jdbc.jar包含外部实现类(jdbc.jar存在于classpath路径)无法通过Bootstrap类加载器加载, 因此只能委派线程上下文类加载器把jdbc.jar中的实现类加载到内存以便SPI相关类使用. 显然这种线程上下文类加载器的加载方式破坏了“双亲委派模型”, 它在执行过程中抛弃双亲委派加载链模式, 使程序可以逆向使用类加载器, 当然这也使得Java类加载器变得更加灵活. 为了进一步证实这种场景, 不妨看看DriverManager类的源码, DriverManager是Java核心rt.jar包中的类, 该类用来管理不同数据库的实现驱动即Driver, 它们都实现了Java核心包中的java.sql.Driver接口, 如mysql驱动包中的com.mysql.jdbc.Driver, 这里主要看看如何加载外部实现类,在 DriverManager初始化时会执行如下代码 12345678910111213141516171819//DriverManager是Java核心包rt.jar的类public class DriverManager &#123; //省略不必要的代码 static &#123; loadInitialDrivers();//执行该方法 println("JDBC DriverManager initialized"); &#125;//loadInitialDrivers方法 private static void loadInitialDrivers() &#123; sun.misc.Providers() AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; //加载外部的Driver的实现类 ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); //省略不必要的代码...... &#125; &#125;); &#125; 12345public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123; //通过线程上下文类加载器加载 ClassLoader cl = Thread.currentThread().getContextClassLoader(); return ServiceLoader.load(service, cl); &#125; 很明显了确实通过线程上下文类加载器加载的, 实际上核心包的SPI类对外部实现类的加载都是基于线程上下文类加载器执行的, 通过这种方式实现了Java核心代码内部去调用外部实现类. 我们知道线程上下文类加载器默认情况下就是AppClassLoader, 那为什么不直接通过getSystemClassLoader()获取类加载器来加载classpath路径下的类的呢?其实是可行的, 但这种直接使用getSystemClassLoader()方法获取AppClassLoader加载类有一个缺点, 那就是代码部署到不同服务时会出现问题, 如把代码部署到Java Web应用服务或者EJB之类的服务将会出问题, 因为这些服务使用的线程上下文类加载器并非AppClassLoader, 而是Java Web应用服自家的类加载器, 类加载器不同. 所以我们应用该少用getSystemClassLoader(). 总之不同的服务使用的可能默认ClassLoader是不同的, 但使用线程上下文类加载器总能获取到与当前程序执行相同的ClassLoader, 从而避免不必要的问题. 4.4 自定义类加载器4.4.1 普通类加载器通常情况下, 我们都是直接使用系统类加载器. 但是, 有的时候, 我们也需要自定义类加载器. 比如应用是通过网络来传输 Java 类的字节码, 为保证安全性, 这些字节码经过了加密处理, 这时系统类加载器就无法对其进行加载, 这样则需要自定义类加载器来实现. 自定义类加载器一般都是继承自 ClassLoader类, 我们只需要重写findClass方法即可. 下面我们通过一个示例来演示自定义类加载器的流程: 123456789101112131415161718192021222324252627282930313233import java.io.*;public class MyClassLoader extends ClassLoader &#123; private String root; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] classData = loadClassData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, classData, 0, classData.length); &#125; &#125; private byte[] loadClassData(String className) &#123; String fileName = root + File.separatorChar + className.replace('.', File.separatorChar) + ".class"; try &#123; InputStream ins = new FileInputStream(fileName); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 1024; byte[] buffer = new byte[bufferSize]; int length = 0; while ((length = ins.read(buffer)) != -1) &#123; baos.write(buffer, 0, length); &#125; return baos.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; public void setRoot(String root) &#123; this.root = root; &#125;&#125; 12345public class Te &#123; static &#123; System.out.println("hello world"); &#125;&#125; 123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; MyClassLoader classLoader = new MyClassLoader(); classLoader.setRoot("C:\\Users\\ganlu\\IdeaProjects\\untitled3\\out\\production\\untitled3"); Class&lt;?&gt; testClass = null; try &#123; testClass = classLoader.loadClass("Te"); Object object = testClass.newInstance(); System.out.println(object.getClass().getClassLoader()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果: 12hello worldsun.misc.Launcher$AppClassLoader@18b4aac2 4.4.2 热部署类加载器所谓的热部署就是利用同一个class文件不同的类加载器在内存创建出两个不同的class对象(即利用不同的类加载实例), 由于JVM在加载类之前会检测请求的类是否已加载过(即在loadClass()方法中调用findLoadedClass()方法), 如果被加载过, 则直接从缓存获取, 不会重新加载. 注意同一个类加载器的实例和同一个class文件只能被加载器一次, 多次加载将报错, 因此我们实现的热部署必须让同一个class文件可以根据不同的类加载器重复加载, 以实现所谓的热部署. 通过直接调用findClass()方法, 而不是调用loadClass()方法即可实现, 因为ClassLoader中loadClass()方法体中调用findLoadedClass()方法进行了检测是否已被加载，因此我们直接调用findClass()方法就可以绕过这个问题, 当然也可以重写loadClass方法, 但强烈不建议这么干. 1MyClassLoader.java 和 Te.java 都用上面的定义. 12345678910111213141516171819202122232425262728public class Main &#123; public static void main(String[] args) &#123; MyClassLoader classLoader1 = new MyClassLoader(); MyClassLoader classLoader2 = new MyClassLoader(); classLoader1.setRoot("C:\\Users\\ganlu\\IdeaProjects\\untitled3\\out\\production\\untitled3"); classLoader2.setRoot("C:\\Users\\ganlu\\IdeaProjects\\untitled3\\out\\production\\untitled3"); try &#123; Class&lt;?&gt; testClass1 = classLoader1.loadClass("Te"); Class&lt;?&gt; testClass2 = classLoader2.loadClass("Te"); System.out.println(testClass1.hashCode()); System.out.println(testClass1.getClassLoader()); System.out.println(testClass2.hashCode()); System.out.println(testClass2.getClassLoader()); Class&lt;?&gt; testClass3 = classLoader1.findClass("Te"); Class&lt;?&gt; testClass4 = classLoader2.findClass("Te"); System.out.println(testClass3.hashCode()); System.out.println(testClass3.getClassLoader()); System.out.println(testClass4.hashCode()); System.out.println(testClass4.getClassLoader()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果: 123456781956725890sun.misc.Launcher$AppClassLoader@18b4aac21956725890sun.misc.Launcher$AppClassLoader@18b4aac21836019240MyClassLoader@1540e19d325040804MyClassLoader@14ae5a5 5. 参考链接&lt;&lt;深入理解Java虚拟机—-JVM高级特性与最佳实践&gt;&gt;(第二版, 周志明)JVM类生命周期概述：加载时机与加载过程JVM 类加载机制深入浅出JVM(四)—一道面试题搞懂JVM类加载机制深入探讨 Java 类加载器Java 类加载机制详解全面解析Java类加载器深入理解Java类加载器(ClassLoader)JVM 类加载机制详解]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存区域和对象]]></title>
    <url>%2F2018%2F09%2F24%2FJVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[1. 前言作为一名Java后台开发的程序员, 深入理解JVM, 重要性不言而喻, 这篇文章主要是记录JVM内存区域相关知识. 2. 运行时数据区Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域, 如下图所示: 2.1 程序计数器当前线程所执行的字节码的行号指示器. 如果线程正在执行的是一个Java方法, 这个计数器记录的是正在执行的虚拟机字节码指令的地址; 如果正在执行的是Native方法, 这个计数器值则为空(Undefined). 2.1.1 程序计数器的作用 生活中的案例比如老王正在看电影, 他看到三十五分钟的时候, 突然他的QQ好友给他开视频聊天, 这时候肯定打断他看电影了, 假设他qq好友和他视频完了, 他肯定要接着他那35分钟的进度去继续看, 这时候他怎么知道我看到35分钟了? 这时候程序计数器就起了作用, 他负责管理进度. 代码层面的案例A线程正在执行HelloWorld.class的第三十五行. 这时候CPU时间片被B线程抢走了, 当A线程重新被分配到时间片时, 他怎么知道我的class运行到哪了? 这时候他可以看程序计数器在哪个位置. 2.2 Java虚拟机栈描述Java方法执行的内存模型: 每个方法被执行的时候都会同时创建一个栈帧, 用于存储局部变量表, 操作数栈, 动态链接, 方法出口等信息. 每一个方法从调用直至执行完成的过程, 就对应着一个栈帧在虚拟机中入栈到出栈的过程. 2.2.1 局部变量表存放了编译期可知的各种基本数据类型(boolean, byte, char, short, int, float, long, double), 对象引用(不等同于对象本身), returnAddress类型(指向了一条字节码指令的地址).long 和 double 类型的数据会占用2个局部变量空间, 其余的数据类型只占用1个.局部变量表所需的内存空间在编译期间完成分配. 2.2.2 两种异常状况 如果线程请求的栈深度大于虚拟机所允许的深度, 将抛出StackOverflowError异常; 如果虚拟机栈可以动态扩展, 并且扩展时无法申请到足够的内存, 就会抛出OutOfMemoryError异常. 2.3 本地方法栈与虚拟机栈所发挥的作用是非常相似的, Java虚拟机栈为虚拟机执行Java方法服务, 而本地方法栈为虚拟机使用的Native方法服务. 2.4 Java堆Java堆是被所有线程共享的一块内存区域, 在虚拟机启动时创建. 所有的对象实例以及数组都要在堆上分配. 这里是垃圾收集器管理的主要区域.Java堆可以处于物理上不连续的内存空间中. 2.4.1 异常如果在堆中没有内存完成实例分配, 并且堆也无法再扩展时, 将会抛出OutOfMemoryError异常. 2.5 方法区线程共享的内存区域, 存储已被虚拟机加载的类信息, 常量, 静态变量, 即时编译器编译后的代码数据等(这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载). 2.5.1 异常当方法区无法满足内存分配需求时, 将会抛出OutOfMemoryError异常. 2.5.2 运行时常量池在方法区中有一个非常重要的部分就是运行时常量池(JDK7之后, 已经挪到堆区里面了), 它是每一个类或接口的常量池的运行时表示形式, 在类和接口被加载到JVM后, 对应的运行时常量池就被创建出来. 当然并非Class文件常量池中的内容才能进入运行时常量池, 在运行期间也可将新的常量放入运行时常量池中, 比如String的intern方法.当运行时常量池无法申请到内存时, 将会抛出OutOfMemoryError异常. 2.6 直接内存直接内存不是虚拟机运行时数据区的一部分, 也不是java虚拟机规范中定义的内存区域. 但是这部分内存也被频繁使用, 可能抛出OutOfMemoryError异常. NIO类引入了一种基于通道与缓冲区(Buffer)的I/O方式, 它可以使用Native函数库直接分配堆外内存, 然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作, 这样能在一些场景中显著提高性能, 因此避免了在java堆和Native堆中来回复制数据. 服务器管理员容易忽略直接内存, 使得内存区域总和大于物理内存限制, 从而导致动态抛出OutOfMemoryError异常. 3. 对象3.1 创建过程下面我们详细了解Java程序中new一个普通对象时, 虚拟机是怎么样创建这个对象的, 包括5个步骤: 相应类加载检查过程、在Java堆中为对象分配内存、分配后内存初始化为零、对对象进行必要的设置、以及执行对象实例方法&lt; init &gt;. 3.1.1 相应类加载检查JVM遇到new指令时, 先检查指令参数是否能在常量池中定位到一个类的符号引用: 如果能定位到，检查这个符号引用代表的类是否已被加载、解析和初始化过； 如果不能定位到，或没有检查到，就先执行相应的类加载过程； 3.1.2 为对象分配内存对象所需内存的大小在类加载完成后便完全确定(JVM可以通过普通Java对象的类元数据信息确定对象大小)；为对象分配内存相当于把一块确定大小的内存从Java堆里划分出来； (A). 分配方式 (1). 指针碰撞如果Java堆是绝对规整的: 一边是用过的内存. 一边是空闲的内存. 中间一个指针作为边界指示器;分配内存只需向空闲那边移动指针, 这种分配方式称为“指针碰撞”(Bump the Pointer); (2). 空闲列表如果Java堆不是规整的: 用过的和空闲的内存相互交错;需要维护一个列表, 记录哪些内存可用;分配内存时查表找到一个足够大的内存, 并更新列表, 这种分配方式称为“空闲列表”(Free List); Java堆是否规整由JVM采用的垃圾收集器是否带有压缩功能决定的；所以，使用Serial、ParNew等带Compact过程的收集器时，JVM采用指针碰撞方式分配内存；而使用CMS这种基于标记-清除（Mark-Sweep）算法的收集器时，采用空闲列表方式； (B). 线程安全问题并发时, 上面两种方式分配内存的操作都不是线程安全的, 有两种解决方案: (1). 同步处理对分配内存的动作进行同步处理:JVM采用CAS(Compare and Swap)机制加上失败重试的方式, 保证更新操作的原子性;CAS: 有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做； (2). 本地线程分配缓冲区把分配内存的动作按照线程划分在不同的空间中进行:在每个线程在Java堆预先分配一小块内存, 称为本地线程分配缓冲区(Thread Local Allocation Buffer,TLAB);哪个线程需要分配内存就从哪个线程的TLAB上分配；只有TLAB用完需要分配新的TLAB时, 才需要同步处理；JVM通过”-XX：+/-UseTLAB”指定是否使用TLAB； 3.1.3 分配后内存初始化为零内存分配完成后, 虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头), 如果使用TLAB, 提前至分配TLAB时;这保证了程序中对象(及实例变量)不显式初始赋零值, 程序也能访问到零值. 3.1.4 对对象进行必要的设置主要设置对象头信息，包括类元数据引用、对象的哈希码、对象的GC分代年龄等; 3.1.5 执行对象实例方法&lt; init &gt;该方法把对象(实例变量)按照程序中定义的初始赋值进行初始化; 3.2 内存布局下面我们详细了解Java普通对象创建后, 在虚拟机Java堆中的内存布局是怎样的, 可以分为3个区域: 对象头(Header), 实例数据(Instance)和对齐填充(Padding). 3.2.1 对象头可以主要分为两部分: (A). 存储对象自身运行时数据称为”Mark Word”, 包括哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；这部分长度为32bit（32位JVM）或64bit（64位JVM）；被设计成一个非固定的数据结构，会根据对象的状态复用自己的存储空间，以便在极小的空间内存储尽量多信息；例如，32bit的Mark Word在未被锁定状态下，前25bit存储对象哈希码，4bit存储对象分代年龄，2bit存储锁标志位，1bit固定为0，如图所示 (B). 存储指向对象类型数据的指针通过这个指针确定这个对象是哪个类的实例;不是必须的, 看对象的访问定位方式:对HotSpot虚拟机来说, 由于JVM栈本地变量表中对象的reference类型引用使用直接指针, 该指针指向堆内存中的对象, 所以对象头中是需要存储它的类元数据指针, 该指针指向方法区中对象类型数据. (C). 如果是Java数组, 对象头还需要存储数组长度因为数组对象类型数据中没有数组长度信息;而JVM可以通过普通Java对象的类元数据信息确定对象大小; 3.2.2 实例数据它是对象真正存储的有效信息, 程序代码所定义的各种类型字段内容, 以及包括父类继承或子类定义的;存储顺序:受到JVM分配策略参数(FiedAllocationStyle)和字段在Java源码中定义顺序影响;JVM默认分配策略为: longs/doubles. ints. shorts/chars. booleans. oops(Ordiary Object Pointers);JVM默认分配策略使得, 相同宽度的字段总被分配到一起;这个前提下, 父类定义的变量出现在子类之前;如果虚拟机的”CompactFields”参数为true, 子类中较窄的变量可能插入到父类变量空隙中, 以压缩节省空间; 3.2.3 对齐填充不是必然存在的;只起占位符作用, 没有其他含义;HotSpot虚拟机要求对象大小必须是8字节的整数倍;对象头是8字节整数倍, 所以填充是对实例数据没有对齐的情况来说的. 3.3 访问定位下面我们详细了解在Java堆中的Java对象是如何访问定位的: 先来了解reference类型数据是什么, 再来了解两种访问方式: 使用句柄或者使用直接指针(HotSpot虚拟机使用了直接指针的方式访问对象). 3.3.1 referenceJava程序通过reference类型数据操作堆上的具体对象;reference类型是引用类型(Reference Types)的一种;JVM规范规定reference类型来表示对某个对象的引用, 可以想象成类似于一个指向对象的指针;对象的操作、传递和检查都通过引用它的reference类型的数据进行操作; 3.3.2 对象访问方式 虽然定义的reference类型数据来作为对象内存数据的引用, 但JVM规范没有定义这个引用应该通过何种方式定位, 访问堆上的对象, 也没有不强制规定对象的内部结构应当如何表示;这些都取决于JVM的实现, 目前主流的对象访问方式有两种:句柄访问 和 直接指针访问 3.3.2.1 句柄访问Java堆划分一块内存作为句柄池, reference中存储就是对象的句柄地址;对象句柄包含两个地址: 在堆中分配的对象实例数据的地址; 这个对象类型数据地址; 如图所示优点: 对象移动时(垃圾回收时常见的动作), reference不需要修改, 只改变句柄中实例数据指针; 3.3.2.2 直接指针访问reference中存储就是在堆中分配的对象实例数据的地址;而对象实例数据中需要有这个对象类型数据的相关信息(前面章节讨论了HotSpot使用对象头来存储对象类型数据地址);如图所示 优点: 对象访问时节省了一次指针定位的时间开销, 速度更快;由于对象访问非常频繁进行, 所以能较好提升性能;HotSpot虚拟机使用了直接指针的方式访问对象; 4. 参考链接&lt;&lt;深入理解Java虚拟机—-JVM高级特性与最佳实践&gt;&gt;(第二版, 周志明)JVM程序计数器Java中的常量池(字符串常量池、class常量池和运行时常量池)Java对象与JVM（一） Java对象在Java虚拟机中的创建过程Java对象与JVM（二） Java对象在Java虚拟机中的内存布局Java对象与JVM（三） Java对象在Java虚拟机中的引用访问方式]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中String.intern()]]></title>
    <url>%2F2018%2F09%2F24%2FJava%E4%B8%ADString.intern()%2F</url>
    <content type="text"><![CDATA[1. 前言学习JVM的时候, 看到了String.intern()这个方法, 以前没用过, 所以记录一下这个方法, 也帮助自己更好的理解运行时常量池. 2. 概述2.1 Java代码123456789101112131415161718192021222324/** * Returns a canonical representation for the string object. * &lt;p&gt; * A pool of strings, initially empty, is maintained privately by the * class &#123;@code String&#125;. * &lt;p&gt; * When the intern method is invoked, if the pool already contains a * string equal to this &#123;@code String&#125; object as determined by * the &#123;@link #equals(Object)&#125; method, then the string from the pool is * returned. Otherwise, this &#123;@code String&#125; object is added to the * pool and a reference to this &#123;@code String&#125; object is returned. * &lt;p&gt; * It follows that for any two strings &#123;@code s&#125; and &#123;@code t&#125;, * &#123;@code s.intern() == t.intern()&#125; is &#123;@code true&#125; * if and only if &#123;@code s.equals(t)&#125; is &#123;@code true&#125;. * &lt;p&gt; * All literal strings and string-valued constant expressions are * interned. String literals are defined in section 3.10.5 of the * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;. * * @return a string that has the same contents as this string, but is * guaranteed to be from a pool of unique strings. */public native String intern(); String.intern方法中看到, 这个方法是一个 native 的方法, 但注释写的非常明了. “如果运行时常量池中存在当前字符串, 就会直接返回当前字符串(不做额外操作);如果运行时常量池中没有此字符串, 会将此字符串放入运行时常量池中后, 再返回(JDK7中, 会将String的值也变为该字符串的直接引用)”. 2.2 实现思路它的大体实现思路就是:JAVA 使用 jni 调用c++实现的StringTable的intern方法, StringTable的intern方法跟Java中的HashMap的实现是差不多的, 只是不能自动扩容. 默认大小是1009, 要注意的是, String的String Pool是一个固定大小的Hashtable, 默认值大小长度是1009, 如果放进String Pool的String非常多, 就会造成Hash冲突严重, 从而导致链表会很长, 而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降. 在 jdk6中StringTable是固定的, 就是1009的长度, 所以如果常量池中的字符串过多就会导致效率下降很快. 在jdk7中, StringTable的长度可以通过一个参数指定: 1-XX:StringTableSize=99991 2.3 JDK6 和 JDK7 下 intern 的区别2.3.1 示例相信很多 Java 程序员都做做类似 String s = new String(“abc”)这个语句创建了几个对象的题目. 这种题目主要就是为了考察程序员对字符串对象的常量池掌握与否. 上述的语句中是创建了2个对象, 第一个对象是”abc”字符串存储在常量池中, 第二个对象在Java 堆中的 String 对象.示例1: 1234567891011public static void main(String[] args) &#123; String s = new String("1"); s.intern(); String s2 = "1"; System.out.println(s == s2); String s3 = new String("1") + new String("1"); s3.intern(); String s4 = "11"; System.out.println(s3 == s4);&#125; 运行结果: 12jdk6 下false falsejdk7 下false true 示例2: 1234567891011public static void main(String[] args) &#123; String s = new String("1"); String s2 = "1"; s.intern(); System.out.println(s == s2); String s3 = new String("1") + new String("1"); String s4 = "11"; s3.intern(); System.out.println(s3 == s4);&#125; 运行结果: 12jdk6 下false falsejdk7 下false false 2.3.2 JDK6中的解释注: 图中绿色线条代表 string 对象的内容指向. 黑色线条代表地址指向.如上图所示. 首先说一下 jdk6中的情况. 在 jdk6中上述的所有打印都是 false 的, 因为 jdk6中的常量池是放在 Perm 区中的, Perm区和正常的 JAVA Heap 区域是完全分开的. 上面说过如果是使用引号声明的字符串都是会直接在字符串常量池中生成, 而 new 出来的 String 对象是放在 JAVA Heap 区域. 所以拿一个 JAVA Heap 区域的对象地址和字符串常量池的对象地址进行比较肯定是不相同的, 即使调用String.intern方法也是没有任何关系的. 2.3.3 JDK7中的解释在 Jdk6 以及以前的版本中, 字符串的常量池是放在堆的Perm区的, Perm区是一个类静态的区域, 主要存储一些加载类的信息, 常量池, 方法片段等内容, 默认大小只有4m, 一旦常量池中大量使用 intern 是会直接产生java.lang.OutOfMemoryError:PermGen space错误的.在 jdk7 的版本中, 字符串常量池已经从Perm区移到正常的Java Heap区域了. 为什么要移动, Perm 区域太小是一个主要原因.正是因为字符串常量池移动到JAVA Heap区域后, 再来解释为什么会有上述的打印结果.在第一段代码中, 先看 s3和s4字符串. String s3 = new String(“1”) + new String(“1”);, 这句代码中现在生成了2最终个对象, 是字符串常量池中的“1” 和 JAVA Heap中的 s3引用指向的对象. 中间还有2个匿名的new String(“1”)我们不去讨论它们. 此时s3引用对象内容是”11″, 但此时常量池中是没有 “11”对象的. 接下来s3.intern();这一句代码, 是将 s3中的”11”字符串放入String 常量池中, 因为此时常量池中不存在”11”字符串, 因此常规做法是跟 jdk6 图中表示的那样, 在常量池中生成一个”11”的对象, 关键点是 jdk7 中常量池不在Perm区域了, 这块做了调整. 常量池中不需要再存储一份对象了, 可以直接存储堆中的引用. 这份引用指向s3引用的对象. 也就是说引用地址是相同的. 最后String s4 = “11”; 这句代码中”11″是显示声明的, 因此会直接去常量池中创建, 创建的时候发现已经有这个对象了, 此时也就是指向s3引用对象的一个引用. 所以s4引用就指向和s3一样了. 因此最后的比较 s3 == s4 是 true. 再看s和 s2 对象. String s = new String(“1”); 第一句代码, 生成了2个对象. 常量池中的“1” 和 JAVA Heap 中的字符串对象. s.intern(); 这一句是 s 对象去常量池中寻找后发现 “1” 已经在常量池里了. 接下来String s2 = “1”; 这句代码是生成一个 s2的引用指向常量池中的“1”对象. 结果就是 s 和 s2 的引用地址明显不同. 图中画的很清晰.来看第二段代码, 从上边第二幅图中观察. 第一段代码和第二段代码的改变就是 s3.intern(); 的顺序是放在String s4 = “11”;后了. 这样, 首先执行String s4 = “11”;声明 s4 的时候常量池中是不存在“11”对象的, 执行完毕后, “11“对象是 s4 声明产生的新对象. 然后再执行s3.intern();时, 常量池中“11”对象已经存在了, 因此 s3 和 s4 的引用是不同的.第二段代码中的 s 和 s2 代码中, s.intern();，这一句往后放也不会有什么影响了, 因为对象池中在执行第一句代码String s = new String(“1”);的时候已经生成“1”对象了. 下边的s2声明都是直接从常量池中取地址引用的. s 和 s2 的引用地址是不会相等的. 3. 小结写这篇博客想表达以下几个重点: JDK7之后,运行时常量池已经从方法区挪到了堆区. String.intern 方法时, 如果存在堆中的对象, 会直接保存以前对对象的引用, 而不会重新创建对象. 4. 参考链接String的Intern方法详解]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM类文件结构]]></title>
    <url>%2F2018%2F09%2F24%2FJVM%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1. 前言作为一名Java后台开发的程序员, 深入理解JVM, 重要性不言而喻, 这篇文章主要是记录JVM类文件结构相关知识. 2. 实例这部分比较抽象, 所以以实例的形式来学习. 这部分作为资料, 以便后面的章节用来翻阅. 2.1 实例代码12345public class Main &#123; public static void main(String[] args) &#123; System.out.println("Hello World!"); &#125;&#125; 2.2 实例二进制123456789101112131415161718192021222324252627282930313233cafe babe 0000 0034 0022 0a00 0600 14090015 0016 0800 170a 0018 0019 0700 1a07001b 0100 063c 696e 6974 3e01 0003 28295601 0004 436f 6465 0100 0f4c 696e 654e756d 6265 7254 6162 6c65 0100 124c 6f63616c 5661 7269 6162 6c65 5461 626c 65010004 7468 6973 0100 064c 4d61 696e 3b010004 6d61 696e 0100 1628 5b4c 6a61 76612f6c 616e 672f 5374 7269 6e67 3b29 56010004 6172 6773 0100 135b 4c6a 6176 612f6c61 6e67 2f53 7472 696e 673b 0100 0a536f75 7263 6546 696c 6501 0009 4d61 696e2e6a 6176 610c 0007 0008 0700 1c0c 001d001e 0100 0c48 656c 6c6f 2057 6f72 6c642107 001f 0c00 2000 2101 0004 4d61 696e0100 106a 6176 612f 6c61 6e67 2f4f 626a6563 7401 0010 6a61 7661 2f6c 616e 672f5379 7374 656d 0100 036f 7574 0100 154c6a61 7661 2f69 6f2f 5072 696e 7453 74726561 6d3b 0100 136a 6176 612f 696f 2f507269 6e74 5374 7265 616d 0100 0770 72696e74 6c6e 0100 1528 4c6a 6176 612f 6c616e67 2f53 7472 696e 673b 2956 0021 00050006 0000 0000 0002 0001 0007 0008 00010009 0000 002f 0001 0001 0000 0005 2ab70001 b100 0000 0200 0a00 0000 0600 01000000 0100 0b00 0000 0c00 0100 0000 05000c00 0d00 0000 0900 0e00 0f00 0100 09000000 3700 0200 0100 0000 09b2 0002 1203b600 04b1 0000 0002 000a 0000 000a 00020000 0003 0008 0004 000b 0000 000c 00010000 0009 0010 0011 0000 0001 0012 00000002 0013 2.3 javap分析javap -verbose Main.class 2.4 手工分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960cafe babe // 魔数0000 0034 // Class文件版本0022 // 常量池-容量计数器(34-1=33)0a 0006 0014 // 第1个常量09 0015 0016 // 第2个常量08 0017 // 第3个常量0a 0018 0019 // 第4个常量07 001a // 第5个常量07 001b // 第6个常量01 0006 3c 69 6e 69 74 3e // 第7个常量 &lt;init&gt;01 0003 28 29 56 // 第8个常量 ()V01 0004 43 6f 64 65 // 第9个常量 Code01 000f 4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 // 第10个常量 LineNumberTable01 0012 4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 // 第11个常量 LocalVariableTable01 0004 74 68 69 73 // 第12个常量 this01 0006 4c 4d 61 69 6e 3b // 第13个常量 LMain;01 0004 6d 61 69 6e // 第14个常量 main01 0016 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 29 56 // 第15个常量 ([Ljava/lang/String;)V01 0004 61 72 67 73 // 第16个常量 args01 0013 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b // 第17个常量 [Ljava/lang/String;01 000a 53 6f 75 72 63 65 46 69 6c 65 // 第18个常量 SourceFile01 0009 4d 61 69 6e 2e 6a 61 76 61 // 第19个常量 Main.java0c 0007 0008 // 第20个常量07 001c // 第21个常量0c 001d 001e // 第22个常量01 000c 48 65 6c 6c 6f 20 57 6f 72 6c 64 21 // 第23个常量 Hello World!07 001f // 第24个常量0c 0020 0021 // 第25个常量01 0004 4d 61 69 6e // 第26个常量 Main01 0010 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74 // 第27个常量 java/lang/Object01 0010 6a 61 76 61 2f 6c 61 6e 67 2f 53 79 73 74 65 6d // 第28个常量 java/lang/System01 0003 6f 75 74 // 第29个常量 out01 0015 4c 6a 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 3b // 第30个常量 Ljava/io/PrintStream;01 0013 6a 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d // 第31个常量 java/io/PrintStream01 0007 70 72 69 6e 74 6c 6e // 第32个常量 println01 0015 28 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 29 56 // 第33个常量 (Ljava/lang/String;)V0021 // 访问标志0005 // 类索引0006 // 父类索引0000 // 接口索引集合0000 // 字段表集合0002 // 方法表集合.计数器(2)0001 // 第1个方法:方法访问标识符0007 // 第1个方法:方法名称索引项0008 // 第1个方法:方法描述符索引项0001 // 第1个方法:属性表计数器(1)0009 // 第1个方法:属性名字0000 002f // 第1个方法:属性长度(47)00 01 00 01 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 00 00 06 00 01 00 00 00 01 00 0b 00 00 00 0c 00 01 00 00 00 05 00 0c 00 0d 00 00 // 第1个方法:属性info0009 // 第2个方法:方法访问标识符000e // 第2个方法:方法名称索引项000f // 第2个方法:方法描述符索引项0001 // 第2个方法:属性表计数器(1)0009 // 第2个方法:属性名字0000 0037 // 第2个方法:属性长度(55)00 02 00 01 00 00 00 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a 00 00 00 0a 00 02 00 00 00 03 00 08 00 04 00 0b 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 // 第2个方法:属性info0001 // Class文件属性表计数器(1)0012 // 属性名字0000 0002 // 属性长度(2)00 13 // 属性info 3. Class类文件结构Java 虚拟机规范中定义了许多规范, 其中有一部分定义了字节码的结构和规范. Java 虚拟机规范定义了两种数据类型来表示 Class 文件格式, 分别是: 无符号数和表.无符号数属于最基本的数据类型, 以 u1, u2, u4, u8分别代表 1 个字节, 2 个字节, 4 个字节, 8 个字节的无符号数, 无符号数可以用来描述数字, 索引引用, 数量值或者按照 UTF-8 编码构成的字符串值.表是由多个无符号数或者其他表作为数据项构成的复合数据类型, 所有表都习惯性地以”_info”结尾. 表用于描述由层次关系的复合结构的数据, 整个Class文件本质上就是一张表.整个 Class 文件本质上就是一张表, 它由表下表所示的数据项构成. 3.1 魔数Class 文件的第 1 - 4 个字节代表了该文件的魔数()Magic Number). 它唯一的作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件, 其值固定是: 0xCAFEBABE(咖啡宝贝). 如果一个 Class 文件的魔数不是 0xCAFEBABE, 那么虚拟机将拒绝运行这个文件. 3.1.1 实例对照我们看看实例部分, 其前 4 个字节分别是：cafe babe 3.2 Class文件版本Class 文件的第 5 - 6 个字节代表了 Class 文件的次版本号(Minor Version), 即编译该 Class 文件的 JDK 次版本号。Class 文件的第 7 - 8 个字节代表了 Class 文件的主版本号(Major Version), 即编译该 Class 文件的 JDK 主版本号。高版本的 JDK 能向下兼容以前的 Class 文件, 但不能运行新版本的 Class 文件.例如一个 Class 文件是使用 JDK 1.5 编译的, 那么我们可以用 JDK 1.7 虚拟机运行它, 但不能用 JDK 1.4 虚拟机运行它.下表列出了各个版本 JDK 的十六进制版本号信息: 3.2.1 实例对照我们看看实例部分, 其 5 - 8 个字节分别是：0000 0034, 那么我们可以知道, 这个 Class 文件是由 JDK1.8 编译的. 3.3 常量池紧接着主次版本号之后是常量池入口, 由于常量池中常量的数量是不固定的, 所以在常量池的入口需要放置一个常量池容量计数值(constant_pool_count), 这个容量计数是从1而不是0开始的, 设计者这样设计的目的是为了满足后面某些指向常量池的索引值的数据在特殊情况下需要表达”不引用任何一个常量池项目”的含义.Class文件结构中只有常量池的容量计数是从1开始的, 索引集合. 字段集合. 方法集合. 属性集合的容量计数都是从0开始的.注意, Long和Double型占用两个计数.常量池中主要存放两大类常量: 字面量(Literal)和符号引用.字面量接近Java语言层面的常量概念, 如文本字符串. 声明为final的常量值等.符号引用属于编译原理的概念, 包括三类常量: 类和接口的全限定名; 字段的名称和描述符; 方法的名称和描述符. 常量池中每一项常量都是一个表, 在JDK1.7之后共有14种表结构, 它们有一个共同的特点, 就是表开始的第一位是一个u1类型的标志位(tag, 取值见下表), 代表当前这个常量属于哪种常量类型.每个常量池的常量都用一个类型为 cp_info 的表表示, 该表有 14 个值, 分别是:常量池中的14种常量项的结构总表: 3.3.1 实例对照我们Class 文件第 9 - 10 个字节为 0022, 表示有 33 个常量. 第 1 个常量. 紧接着 0022 的后一个字节为 0a, 表示该常量为CONSTANT_MethodHandle_info. 从上面的总表查阅知道, 该常量项第 2 - 3 个字节表示方法的类描述符, 这里是 0006 表示指向常量池第 6 个常量所表示的信息. 该常量项的第 4 - 5 个字节表示名称及类描述符, 这里值为 0014 表示指向常量池第 20 个常量所表示的信息. 第 2 个常量. 紧接着 0014 的后一个字节为 09, 表示该常量为CONSTANT_Fieldref_info. 从上面的总表查阅知道, 该常量项第 2 - 3 个字节表示字段的类或者接口描述符, 这里是 0015 表示指向常量池第 21 个常量所表示的信息. 该常量项的第 4 - 5 个字节表示字段描述符, 这里值为 0016 表示指向常量池第 22 个常量所表示的信息. 第 3 个常量. 紧接着 0016 的后一个字节为 08, 表示该常量为CONSTANT_String_info. 从上面的总表查阅知道, 该常量项第 2 - 3 个字节表示指向字符串字面量的索引, 这里是 0017 表示指向常量池的第 23 个常量. 第 4 个常量. 紧接着 0017 的后一个字节为 0a, 表示该常量为CONSTANT_MethodHandle_info的常量. 从上面的总表查阅知道, 该常量项第 2 - 3 个字节表示方法的类描述符, 这里是 0018 表示指向常量池第 24 个常量所表示的信息. 该常量项的第 4 - 5 个字节表示名称及类描述符, 这里值为 0019 表示指向常量池第 25 个常量所表示的信息. 第 5 个常量. 紧接着 0019 的后一个字节为 07, 表示该常量为CONSTANT_Class_info的常量. 从上面的总表查阅知道, 该常量项第 2 - 3 个字节表示全限定名常量项, 这里是 001a 表示指向常量池第 26 个常量所表示的信息.……更多可以参考 2.实例 部分中的分析. 3.4 访问标志在常量池结束之后, 紧接着的两个字节代表访问标记(access_flags), 这个标志用于识别一些类或者接口层次的访问信息, 包括: 这个Class是类还是接口, 是否定义为public类型, 是否定义为abstract类型等. 具体的标志位以及标志的含义见下表. 3.4.1 实例对照在实例里面, 这两个字节是 00 21, 通过查看我们并没有发现有标志值是 00 21 的标志名称. 这是因为这里的访问标志可能是由多个标志名称组成的, 所以字节码文件中的标志值其实是多个值进行或运算的结果.通过查阅上述表格, 我们可以知道, 00 21 由 00 01 和 00 20 进行或运算得来, 也就是说该类的访问标志是 public 并且允许使用 invokespecial 字节码指令的新语义. 3.5 类索引, 父类索引和接口索引集合类索引和父类索引都是一个u2类型的数据, 而接口索引集合是一组u2类型的数据的集合, Class文件中由这三项数据来确定这个类的继承关系. 3.5.1 实例对照类索引. 类索引用于确定这个类的全限定名, 它用一个 u2 类型的数据表示. 这里的类索引是 00 05 表示其指向了常量池中第 5 个常量, 通过我们之前的分析, 我们知道第 5 个常量其最终的信息是 Main 类.父类索引. 父类索引用于确定这个类的父类的全限定名, 父类索引用一个u2类型的数据表示. 这里的父类索引是 00 06 表示其指向了常量池中第 6 个常量, 通过我们之前的分析, 我们知道第 6 个常量其最终的信息是 Object 类. 因为其并没有继承任何类, 所以 Demo 类的父类就是默认的 Object 类.接口索引. 接口索引集合就用来描述哪个类实现了哪些接口, 这些被实现的接口将按 implements 语句(如果这个类本身就是一个接口, 则应当是extends语句)后的接口顺序从左到右排列在接口索引集合中. 对于接口索引集合, 入口第一项是 u2 类型的数据为接口计数器(interfaces_count), 表示索引表的容量, 而在接口计数器后则紧跟着所有的接口信息. 如果该类没有实现任何接口, 则该计数器值为0, 后面接口的索引表不再占用任何字节.这里 Main 类的字节码文件中, 因为并没有实现任何接口, 所以紧跟着父类索引后的两个字节是0x0000, 这表示该类没有实现任何接口. 因此后面的接口索引表为空. 3.6 字段表集合字段表集合用于描述接口或者类中声明的变量. 这里说的字段包括类级变量和实例级变量, 但不包括在方法内部声明的局部变量.在类接口集合后的2个字节是一个字段计数器, 表示总有有几个属性字段. 在字段计数器后, 才是具体的属性数据. 字段表的每个字段用一个名为 field_info 的表来表示, field_info 表的数据结构如下所示:字段访问标志:跟随 字段访问标志 的是两项索引值: name_index和 descriptor_index. 它们都是对常量池的引用, 分别代表字段的简单名称 以及 字段和方法的描述符.描述符的作用是描述字段的数据类型, 方法的参数列表(包括数量, 类型及顺序)和返回值.根据描述符的规则, 基本数据类型以及代表无返回值的void类型都用一个大写字符来表示, 而对象类型则用字符L加对象的全限定名表示, 见下表对于数组类型, 每一维度将使用一个前置的”[“字符来描述. 如”String[][]”, 会被记录为”[[Ljava/lang/String”,”int[]”被记录为”[I”.描述符描述方法时, 按照先参数列表, 后返回值的顺序描述. 参数列表按照参数的严格顺序放置一组小括号“()”内, 如void inc()的描述符为“()V”,“viod main(String[] args)”的描述符为“([Ljava/lang/String;)V”,“int indexOf(char[] source,int sourceOffset,int sourceCount,char[] target,int targetOffset,int targetCount,int fromIndex)”的描述符为“([CII[CIII)I”.字段表都包含的固定数据项到descriptor_index为止就结束了, 不过在descriptor_index之后跟随着一个属性表集合用于存储一些额外的信息, 字段都可以在属性表中描述零至多项的额外信息.字段表集合中不会列出从超类或者父类接口中继承而来的字段, 但有可能列出原本Java代码之中不存在的字段. 3.6.1 实例对照因为我们并没有声明任何的类成员变量或类变量, 所以在 Main 的字节码文件中, 字段计数器为 00 00, 表示没有属性字段. 3.7 方法表集合在字段表后的 2 个字节是一个方法计数器, 表示类中总有有几个方法. 在字段计数器后, 才是具体的方法数据, 方法表中的每个方法都用一个 method_info 表示, 其数据结构如下:方法表所包含的数据项目的含义也和字段表集合的非常的类似, 仅在访问标志和属性表集合的可选项中有所区别. 由于volatile, transient关键字不能修饰方法, 同时synchronized, native, strictfp和abstract关键字可以修饰方法. 对于方法表, 所有标志位及其取值如下通过访问标志, 名称索引, 描述符索引可清楚的表达方法的定义. 那方法里面的代码去哪里了呢? 方法里的Java代码经过编译器编译成字节码指令后, 存放在方法属性表集合中属性表中; 这个属性表的名称为”Code”. 属性表是Class文件格式中最具扩展性的一种数据项目.与字段表集合相对应的, 如果父类方法在子类中没有被重写(Override), 方法表集合中就不会出现来自父类的方法信息, 但可能出现编译器自动添加的方法, 最典型的便是类构造器”&lt;clinit&gt;”方法和实例构造器”&lt;init&gt;”方法.在Java语言中, 重载(Overload)一个方法, 1.要与原方法具有相同的简单名称. 2.要与原方法有不同的特征签名.Java代码的方法特征签名只包括方法名称, 参数顺序及参数类型; 而字节码的特征签名还包括方法返回值以及受查异常表. 3.7.1 实例对照Main 类的字节码文件中, 方法计数器的值为 00 02, 表示一共有 2 个方法.第 1 个方法. 方法计数器后 2 个字节表示方法访问标识, 这里是 00 01, 表示其实 ACC_PUBLIC 标识, 即该方法访问表示为 public.紧 接着 2 个字节表示方法名称的索引, 这里是 00 07 表示指向了常量池第 7 个常量, 查阅可知其指向了&lt;init&gt;. 紧接着的 2 个字节表示方法描述符索引项, 这里是 00 08 表示指向了常量池第 8 个常量, 查阅可知其指向了()V. 紧接着 2 个字节表示属性表计数器, 这里是 00 01 表示该方法一共有 1 个属性. 紧接着的一连串就是属性表的内容. 3.8 属性表集合在Class文件, 字段表, 方法表, 属性表都可以携带自己的属性表集合, 用于描述某些场景专有的信息.与Class文件中其他的数据项目要求严格的顺序, 长度和内容不同, 属性表集合的限制稍微宽松了一些, 不再要求各个属性表具有严格顺序, 并且只要不与已有属性名重复, 任何人实现的编译器都可以想属性表中写入自己定义的属性信息, Java虚拟机运行时会忽略掉它不认识的属性. 下边将介绍一些关键常用的属性.虚拟机规范预定义的属性: 属性名称 使用位置 含义 Code 方法表 Java代码编译成的字节码指令 ConstantValue 字段表 final关键字定义的常量值 Deprecated 类、方法表、字段表 被声明为deprecated的方法和字段 Exceptions 方法表 方法抛出的异常 EnclosingMethod 类文件 仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法 InnerClasses 类文件 内部类列表 LineNumberTable Code属性 Java源码的行号与字节码指令的对应关系 LocalVariableTable Code属性 方法的局部变量描述 StackMapTable Code属性 JDK1.6中新增的属性，供新的类型检查验证器（Type Checker）检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配 Signature 类、方法表、字段表 JDK1.5中新增的属性，这个属性用于支持泛型情况下的方法签名，在Java语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则Signature属性会为它记录泛型签名信息。由于Java的泛型采用擦除法实现，在为了避免类型信息被擦除后导致签名混乱，需要这个属性记录泛型中的相关信息 SourceFile 类文件 记录源文件名称 SourceDebugExtension 类文件 JDK1.6中新增的属性，SourceDebugExtension属性用于存储额外的调试信息。譬如在进行JSP文件调试时，无法通过Java堆栈来定位JSP文件的行号，JSR-45规范为这些非Java语言编写，却需要编译成字节码并运行在Java虚拟机中的程序提供了一个进行调试的标准机制，使用SourceDebugExtension属性就可以用于存储这个标准所新加入的调试信息 Synthetic 类、方法表、字段表 标识方法或字段为编译器自动生成的 LocalVariableTypeTable 类 JDK1.5中新增的属性，它使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加 RuntimeVisibleAnnotations 类、方法表、字段表 JDK1.5新增的属性，为动态注解提供支持。RuntimeVisibleAnnotations属性用于注明哪些注解是运行时（实际上运行时就是进行反射调用）可见的 RuntimeInvisibleAnnotations 类、方法表、字段表 JDK1.5新增的属性，与RuntimeVisibleAnnotations属性作用刚好相反，用于指明哪些注解是运行时不可见的 RuntimeVisibleParameterAnnotations 方法表 JDK1.5新增的属性，作用与RuntimeVisibleAnnotations属性类似，只不过作用对象为方法参数 RuntimeInvisibleParameterAnnotations 方法表 JDK1.5新增的属性，作用与RuntimeInvisibleAnnotations属性类似，只不过作用对象为方法参数 AnnotationDefault 方法表 JDK1.5新增的属性，用于记录注解类元素的默认值 BootstrapMethods 类文件 JDK1.7中新增的属性，用于保存invokedynamic指令引用的引导方法限定符 对于每个属性, 它的名称需要从常量池引用一个CONSTANT_Utf8_info类型的常量来表示, 而属性值的结构则完全自定义的, 只需要通过一个u4的长度属性去说明属性值所占用的位数即可. 一个符合规则的属性表应该满足以下定义结构.属性表结构: 类型 名称 数量 u2 attribute_name_index 1 u4 attribute_length 1 u1 info attribute_length attribute_name_index是指向CONSTANT_Utf8_info类型常量的索引, CONSTANT_Utf8_info类型常量记录着属性的名称; attribute_length标识属性值所占用的位数. 3.8.1 实例对照这里不做过多扩展了, 每种属性具体的定义参考书就可以了. 4. 参考链接&lt;&lt;深入理解Java虚拟机—-JVM高级特性与最佳实践&gt;&gt;(第二版, 周志明)从 HelloWorld 看 Java 字节码文件结构Java类文件结构详解]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java自动装箱拆箱]]></title>
    <url>%2F2018%2F09%2F24%2FJava%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[1. 前言在后台开发的过程中, 使用框架开发, 经常会不得已遇到自动拆装箱的问题, 这篇文章主要是记录自动拆箱装箱的相关知识, 便于自己写出高质量的代码. 2. 概述2.1 什么是自动装箱拆箱很简单, 下面两句代码就可以看到装箱和拆箱过程. 1234//自动装箱Integer total = 99;//自定拆箱int totalprim = total; 简单一点说, 装箱就是自动将基本数据类型转换为包装器类型; 拆箱就是自动将包装器类型转换为基本数据类型.下面我们来看看需要装箱拆箱的类型有哪些: 2.2 执行过程这个过程是自动执行的, 那么我们需要看看它的执行过程: 12345678public class Main &#123; public static void main(String[] args) &#123; //自动装箱 Integer total = 99; //自定拆箱 int totalprim = total; &#125;&#125; 反编译class文件之后得到如下内容: 1javap -c Main.class Integer total = 99;执行上面那句代码的时候, 系统为我们执行了:Integer total = Integer.valueOf(99); int totalprim = total;执行上面那句代码的时候，系统为我们执行了:int totalprim = total.intValue(); 我们现在就以Integer为例, 来分析一下它的源码 2.2.1 Integer.valueOf函数123public static Integer valueOf(int i) &#123; return i &gt;= 128 || i &lt; -128 ? new Integer(i) : SMALL_VALUES[i + 128];&#125; 它会首先判断i的大小: 如果i小于-128或者大于等于128. 就创建一个Integer对象. 否则执行SMALL_VALUES[i + 128].首先我们来看看Integer的构造函数: 1234567private final int value;public Integer(int value) &#123; this.value = value;&#125;public Integer(String string) throws NumberFormatException &#123; this(parseInt(string));&#125; 它里面定义了一个value变量, 创建一个Integer对象, 就会给这个变量初始化. 第二个传入的是一个String变量, 它会先把它转换成一个int值, 然后进行初始化.下面看看SMALL_VALUES[i + 128]是什么东西: 1private static final Integer[] SMALL_VALUES = new Integer[256]; 它是一个静态的Integer数组对象, 也就是说最终valueOf返回的都是一个Integer对象.所以我们这里可以总结一点: 装箱的过程会创建对应的对象, 这个会消耗内存, 所以装箱的过程会增加内存的消耗, 影响性能. 2.2.2 intValue函数1234@Overridepublic int intValue() &#123; return value;&#125; 这个很简单, 直接返回value值即可. 2.2.3 相关问题上面我们看到在Integer的构造函数中, 它分两种情况: i &gt;= 128 || i &lt; -128 =====&gt; new Integer(i) i &lt; 128 &amp;&amp; i &gt;= -128 =====&gt; SMALL_VALUES[i + 128] 1private static final Integer[] SMALL_VALUES = new Integer[256]; SMALL_VALUES本来已经被创建好, 也就是说在i &gt;= 128 || i &lt; -128是会创建不同的对象, 在i &lt; 128 &amp;&amp; i &gt;= -128会根据i的值返回已经创建好的指定的对象. 12345678910public class Main &#123; public static void main(String[] args) &#123; Integer i1 = 100; Integer i2 = 100; Integer i3 = 200; Integer i4 = 200; System.out.println(i1==i2); //true System.out.println(i3==i4); //false &#125;&#125; 代码的后面, 我们可以看到它们的执行结果是不一样的, 为什么, 在看看我们上面的说明. i1和i2会进行自动装箱, 执行了valueOf函数, 它们的值在[-128,128)这个范围内, 它们会拿到SMALL_VALUES数组里面的同一个对象SMALL_VALUES[256], 它们引用到了同一个Integer对象, 所以它们肯定是相等的. i3和i4也会进行自动装箱, 执行了valueOf函数, 它们的值大于128, 所以会执行new Integer(200), 也就是说它们会分别创建两个不同的对象, 所以它们肯定不等. 下面我们来看看另外一个例子: 12345678910public class Main &#123; public static void main(String[] args) &#123; Double i1 = 100.0; Double i2 = 100.0; Double i3 = 200.0; Double i4 = 200.0; System.out.println(i1==i2); //false System.out.println(i3==i4); //false &#125;&#125; 看看上面的执行结果, 跟Integer不一样, 这样也不必奇怪, 因为它们的valueOf实现不一样, 结果肯定不一样, 那为什么它们不统一一下呢?这个很好理解, 因为对于Integer, 在[-128,128)之间只有固定的256个值, 所以为了避免多次创建对象, 我们事先就创建好一个大小为256的Integer数组SMALL_VALUES, 所以如果值在这个范围内, 就可以直接返回我们事先创建好的对象就可以了.但是对于Double类型来说, 我们就不能这样做, 因为它在这个范围内个数是无限的.总结一句就是: 在某个范围内的整型数值的个数是有限的, 而浮点数却不是.所以在Double里面的做法很直接, 就是直接创建一个对象, 所以每次创建的对象都不一样. 123public static Double valueOf(double d) &#123; return new Double(d);&#125; 下面我们进行一个归类:Integer派别: Integer, Short, Byte, Character, Long这几个类的valueOf方法的实现是类似的.Double派别: Double, Float的valueOf方法的实现是类似的. 每次都返回不同的对象.下面对Integer派别进行一个总结, 如下图:下面我们来看看另外一种情况: 12345678910public class Main &#123; public static void main(String[] args) &#123; Boolean i1 = false; Boolean i2 = false; Boolean i3 = true; Boolean i4 = true; System.out.println(i1==i2);//true System.out.println(i3==i4);//true &#125;&#125; 可以看到返回的都是true, 也就是它们执行valueOf返回的都是相同的对象. 123public static Boolean valueOf(boolean b) &#123; return b ? Boolean.TRUE : Boolean.FALSE;&#125; 可以看到它并没有创建对象, 因为在内部已经提前创建好两个对象, 因为它只有两种情况, 这样也是为了避免重复创建太多的对象. 12public static final Boolean TRUE = new Boolean(true);public static final Boolean FALSE = new Boolean(false); 上面把几种情况都介绍到了 , 下面来进一步讨论其他情况. 123Integer num1 = 400; int num2 = 400; System.out.println(num1 == num2); //true 说明num1 == num2进行了拆箱操作 123Integer num1 = 100; int num2 = 100; System.out.println(num1.equals(num2)); //true 我们先来看看equals源码: 1234@Overridepublic boolean equals(Object o) &#123; return (o instanceof Integer) &amp;&amp; (((Integer) o).value == value);&#125; 我们指定equal比较的是内容本身, 并且我们也可以看到equal的参数是一个Object对象, 我们传入的是一个int类型, 所以首先会进行装箱, 然后比较, 之所以返回true , 是由于它比较的是对象里面的value值. 123456Integer num1 = 100; int num2 = 100; Long num3 = 200l; System.out.println(num1 + num2); //200System.out.println(num3 == (num1 + num2)); //trueSystem.out.println(num3.equals(num1 + num2)); //false 当一个基础数据类型与封装类进行==, +, -, *, /运算时, 会将封装类进行拆箱, 对基础数据类型进行运算. 对于num3.equals(num1 + num2)为false的原因很简单, 我们还是根据代码实现来说明: 1234@Overridepublic boolean equals(Object o) &#123; return (o instanceof Long) &amp;&amp; (((Long) o).value == value);&#125; 它必须满足两个条件才为true: 类型相同 内容相同 上面返回false的原因就是类型不同. 1234Integer num1 = 100;Integer num2 = 200;Long num3 = 300l;System.out.println(num3 == (num1 + num2)); //true 我们来反编译一些这个class文件:可以看到运算的时候首先对num3进行拆箱(执行num3的longValue得到基础类型为long的值300), 然后对num1和mum2进行拆箱(分别执行了num1和num2的intValue得到基础类型为int的值100和200), 然后进行相关的基础运算.我们来对基础类型进行一个测试: 1234int num1 = 100;int num2 = 200;long num3 = 300;System.out.println(num3 == (num1 + num2)); //true 就说明了为什么最上面会返回true.所以, 当 “==”运算符的两个操作数都是 包装器类型的引用, 则是比较指向的是否是同一个对象, 而如果其中有一个操作数是表达式(即包含算术运算)则比较的是数值(即会触发自动拆箱的过程).陷阱: 12Integer integer100=null; int int100=integer100; 这两行代码是完全合法的, 完全能够通过编译的,但 是在运行时, 就会抛出空指针异常.其 中, integer100为Integer类型的对象, 它当然可以指向null. 但在第二行时, 就会对integer100进行拆箱. 也就是对一个null对象执行intValue()方法, 当然会抛出空指针异常.所 以, 有拆箱操作时一定要特别注意封装类对象是否为null. 3. 特别强调当两种不同类型用==比较时, 包装器类的会拆箱;当同种类型用==比较时, 会直接比较.(int 与 Integer 属于不同类型) 4. 参考链接详解Java的自动装箱与拆箱(Autoboxing and unboxing)]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java注解]]></title>
    <url>%2F2018%2F09%2F24%2FJava%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. 前言使用框架的时候, 经常会遇到注解, 为了更好的阅读框架源码, 同时为了让自己的代码质量更高, 所以写这篇文章来记录注解相关的知识. 2. JDK中的常见注解@Override 用于修饰此方法覆盖了父类的方法;@Deprecated 用于修饰已经过时的方法;@SuppressWarings(“deprecation”) 用于通知Java编译器忽略特定的编译警告. 3. 注解的分类源码注解: 注解只在源码中存在, 编译成.class文件就不存在了编译时注解: 注解在源码和.class文件中都存在(如: JDK内置系统注解)运行时注解: 在运行阶段还起作用, 甚至会影响运行逻辑的注解(如: Spring中@Autowried) 元注解: 注解的注解 4. 自定义注解4.1 注解定义123456789@Target(&#123;ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Description &#123; String desc(); String author(); int age() default 18;&#125; 4.2注解应用1234@Description(desc = "I am eyeColor", author = "My body")public String eyeColor()&#123; return "red";&#125; 4.3 元注解元注解是什么意思呢?元注解是可以注解到注解上的注解, 或者说元注解是一种基本注解, 但是它能够应用到其它的注解上面.元标签有 @Retention, @Documented, @Target, @Inherited, @Repeatable 5 种. 4.3.1 @RetentionRetention 的英文意为保留期的意思. 当 @Retention 应用到一个注解上的时候, 它解释说明了这个注解的的存活时间.它的取值如下: RetentionPolicy.SOURCE 注解只在源码阶段保留, 在编译器进行编译时它将被丢弃忽视. RetentionPolicy.CLASS 注解只被保留到编译进行的时候, 它并不会被加载到 JVM 中. RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候, 它会被加载进入到 JVM 中, 所以在程序运行时可以获取到它们. 123@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123;&#125; 4.3.2 @Documented顾名思义, 这个元注解肯定是和文档有关. 它的作用是能够将注解中的元素包含到 Javadoc 中去. 1234@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface TestAnnotation &#123;&#125; 4.3.3 @TargetTarget 是目标的意思, @Target 指定了注解运用的地方. ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 12345@Retention(RetentionPolicy.RUNTIME)@Documented@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)public @interface TestAnnotation &#123;&#125; 4.3.4 @InheritedInherited 是继承的意思, 但是它并不是说注解本身可以继承, 而是说如果一个超类被 @Inherited 注解过的注解进行注解的话, 那么如果它的子类没有被任何注解应用的话, 那么这个子类就继承了超类的注解. 12345678@Inherited@Retention(RetentionPolicy.RUNTIME)@interface Test &#123;&#125;@Testpublic class A &#123;&#125;public class B extends A &#123;&#125; 注解 Test 被 @Inherited 修饰, 之后类 A 被 Test 注解, 类 B 继承 A,类 B 也拥有 Test 这个注解. 4.3.5 @RepeatableRepeatable 自然是可重复的意思. @Repeatable 是 Java 1.8 才加进来的, 所以算是一个新的特性.什么样的注解会多次应用呢?通常是注解的值可以同时取多个.举个例子, 一个人他既是程序员又是产品经理,同时他还是个画家. 1234567891011121314@interface Persons &#123; Person[] value();&#125;@Repeatable(Persons.class)@interface Person&#123; String role() default "";&#125;@Person(role="artist")@Person(role="coder")@Person(role="PM")public class SuperMan&#123;&#125; 注意上面的代码, @Repeatable 注解了 Person. 而 @Repeatable 后面括号中的类相当于一个容器注解.什么是容器注解呢? 就是用来存放其它注解的地方. 它本身也是一个注解.我们再看看代码中的相关容器注解. 123@interface Persons &#123; Person[] value();&#125; 按照规定, 它里面必须要有一个 value 的属性, 属性类型是一个被 @Repeatable 注解过的注解数组, 注意它是数组. 4.4 注解属性注解的属性也叫做成员变量. 注解只有成员变量, 没有方法. 注解的成员变量在注解的定义中以”无形参的方法”形式来声明, 其方法名定义了该成员变量的名字, 其返回值定义了该成员变量的类型. 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; int id(); String msg();&#125; 上面代码定义了 TestAnnotation 这个注解中拥有 id 和 msg 两个属性. 在使用的时候, 我们应该给它们进行赋值.赋值的方式是在注解的括号内以 value=”” 形式, 多个属性之前用, 隔开. 123@TestAnnotation(id=3,msg="hello annotation")public class Test &#123;&#125; 需要注意的是, 在注解中定义属性时它的类型必须是 8 种基本数据类型外加 类、接口、注解及它们的数组.注解中属性可以有默认值, 默认值需要用 default 关键值指定 .比如: 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; public int id() default -1; public String msg() default "Hi";&#125; TestAnnotation 中 id 属性默认值为 -1, msg 属性默认值为 Hi.它可以这样应用. 12@TestAnnotation()public class Test &#123;&#125; 因为有默认值, 所以无需要再在 @TestAnnotation 后面的括号里面进行赋值了, 这一步可以省略.另外, 还有一种情况. 如果一个注解内仅仅只有一个名字为 value 的属性时, 应用这个注解时可以直接接属性值填写到括号内. 123public @interface Check &#123; String value();&#125; 上面代码中, Check 这个注解只有 value 这个属性. 所以可以这样应用. 12@Check("hi")int a; 这和下面的效果是一样的 12@Check(value="hi")int a; 最后, 还需要注意的一种情况是一个注解没有任何属性. 比如 1public @interface Perform &#123;&#125; 那么在应用这个注解的时候, 括号都可以省略. 12@Performpublic void testMethod()&#123;&#125; 4.5 语法总结 使用@interface关键字定义注解 无参无异常声明成员 可用default为成员指定一个默认值 合法成员类型, 包括: 基本数据类型, String, Class, Annotation和Enumeration 如只有一个成员, 则成员名必须为value(), 且使用时可忽略”value=” 注解类可以没有成员, 没有成员的注解称为标识注解. 5. 注解的提取与应用博文前面的部分讲了注解的基本语法, 要想提取注解, 离不开一个手段, 那就是反射. 5.1 注解与反射 1.注解通过反射获取. 首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解 1public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) &#123;&#125; 2.1.然后通过 getAnnotation() 方法来获取 Annotation 对象. 1public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) &#123;&#125; 2.2.或者是 getAnnotations() 方法. 1public Annotation[] getAnnotations() &#123;&#125; 前一种方法返回指定类型的注解, 后一种方法返回注解到这个元素上的所有注解. 3.如果获取到的 Annotation 如果不为 null, 则就可以调用它们的属性方法了. 比如 1234567891011@TestAnnotation()public class Test &#123; public static void main(String[] args) &#123; boolean hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class); if ( hasAnnotation ) &#123; TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class); System.out.println("id:"+testAnnotation.id()); System.out.println("msg:"+testAnnotation.msg()); &#125; &#125;&#125; 程序的运行结果是: 12id:-1msg:Hi 这个正是 TestAnnotation 中 id 和 msg 的默认值.上面的例子中, 只是检阅出了注解在类上的注解, 其实属性, 方法上的注解照样是可以的. 同样还是要假手于反射.这里我就不继续举例子了.需要注意的是, 如果一个注解要在运行时被成功提取, 那么 @Retention(RetentionPolicy.RUNTIME) 是必须的. 5.2 注解的使用场景注解主要给编译器及工具类型的软件用的. 5.3 注解的缺点注解的提取需要借助于 Java 的反射技术, 反射比较慢, 所以注解使用时也需要谨慎计较时间成本. 6. 参考链接全面解析Java注解秒懂，Java 注解 （Annotation）你可以这样学]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射]]></title>
    <url>%2F2018%2F09%2F23%2FJava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[1. 前言Java反射也是日常开发和阅读源码中经常遇到的, 掌握反射是非常有必要的. 2. 概述2.1 什么是反射简单来说, 反射可以帮助我们在动态运行的时候, 对于任意一个类, 可以获得其所有的方法(包括 public protected private 默认状态的), 所有的变量(包括 public protected private 默认状态的). 反射就是把Java类中的各种成分映射成一个个的Java对象.例如: 一个类有: 成员变量, 方法, 构造方法, 包等等信息, 利用反射技术可以对一个类进行解剖, 把个个组成部分映射成一个个对象.如图是类的正常加载过程: 反射的原理在于Class对象. 2.2 反射有什么用a. 获取某些类的一些变量, 调用某些类的私有方法b. 增加代码的灵活性. 很多主流框架都使用了反射技术. 3. 反射的使用假如有这样一个类 Person, 它拥有多个成员变量, country,city,name,province,height,age 等, 同时它拥有多个 构造方法, 多个方法, 这些变量, 方法的访问权限既有 public 也有 private 的. 下面我们以这个为例子, 一起看怎样使用反射获得相应的 Filed, Constructor, Method. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.HashMap;public class Person &#123; public String country; public String city; private String name; private String province; private Integer height; private Integer age; public Person() &#123; System.out.println("调用Person的无参构造方法"); &#125; private Person(String country, String city, String name) &#123; this.country = country; this.city = city; this.name = name; &#125; public Person(String country, Integer age) &#123; this.country = country; this.age = age; &#125; private String getMobile(String number) &#123; String mobile = "010-110" + "-" + number; return mobile; &#125; private void setCountry(String country) &#123; this.country=country; &#125; public void getGenericHelper(HashMap&lt;String, Integer&gt; hashMap) &#123; &#125; public Class getGenericType() &#123; try &#123; HashMap&lt;String, Integer&gt; hashMap = new HashMap&lt;String, Integer&gt;(); Method method = getClass().getDeclaredMethod("getGenericHelper",HashMap.class); Type[] genericParameterTypes = method.getGenericParameterTypes(); if (null == genericParameterTypes || genericParameterTypes.length &lt; 1) &#123; return null; &#125; ParameterizedType parameterizedType=(ParameterizedType)genericParameterTypes[0]; Type rawType = parameterizedType.getRawType(); System.out.println("----&gt; rawType=" + rawType); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); if (actualTypeArguments==genericParameterTypes || actualTypeArguments.length&lt;1) &#123; return null; &#125; for (int i = 0; i &lt; actualTypeArguments.length; i++) &#123; Type type = actualTypeArguments[i]; System.out.println("----&gt; type=" + type); &#125; &#125; catch (Exception e) &#123; &#125; return null; &#125; @Override public String toString() &#123; return "Person&#123;" + "country='" + country + '\'' + ", city='" + city + '\'' + ", name='" + name + '\'' + ", province='" + province + '\'' + ", height=" + height + '&#125;'; &#125;&#125; 3.1 获得构造方法几个重要的方法 方法 描述 public Constructor getConstructor(Class… parameterTypes) 获得指定的构造方法，注意只能获得 public 权限的构造方法，其他访问权限的获取不到 public Constructor getDeclaredConstructor(Class… parameterTypes) 获得指定的构造方法，注意可以获取到任何访问权限的构造方法。 public Constructor[] getConstructors() throws SecurityException 获得所有 public 访问权限的构造方法 public Constructor[] getDeclaredConstructors() throws SecurityException 获得所有的构造方法，包括（public, private,protected,默认权限的） 3.1.1 获得所有的构造方法123456789101112131415161718192021222324import java.lang.reflect.Constructor;public class Main&#123; public static void main(String[] args)&#123; String className = Person.class.getName(); printConstructor(className); &#125; public static void printConstructor(String className) &#123; try &#123; Class aClass = Class.forName(className); Constructor[] constructors = aClass.getConstructors(); print(constructors); System.out.println("====================="); Constructor[] declaredConstructors = aClass.getDeclaredConstructors(); print(declaredConstructors); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static void print(Constructor[] constructors)&#123; for(Constructor constructor : constructors)&#123; System.out.println(constructor.toString()); &#125; &#125;&#125; 运行结果: 123456public Person(java.lang.String,java.lang.Integer)public Person()=====================public Person(java.lang.String,java.lang.Integer)private Person(java.lang.String,java.lang.String,java.lang.String)public Person() 3.1.2 获得指定的构造方法123456789101112131415161718192021222324252627282930313233import java.lang.reflect.Constructor;public class Main&#123; public static void main(String[] args)&#123; String className = Person.class.getName(); Constructor constructor = getConstructor(className, String.class, Integer.class); try &#123; Object meinv = constructor.newInstance("CHINA", 24); Person person = (Person) meinv; System.out.println("testConstructor: = " + person.toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Constructor getConstructor(String className, Class&lt;?&gt;... clzs) &#123; try &#123; Class&lt;?&gt; aClass = Class.forName(className); Constructor&lt;?&gt; declaredConstructor = aClass.getDeclaredConstructor(clzs); print(declaredConstructor); // if Constructor is not public,you should call this declaredConstructor.setAccessible(true); return declaredConstructor; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static void print(Constructor constructor)&#123; System.out.println(constructor.toString()); &#125;&#125; 运行结果: 12public Person(java.lang.String,java.lang.Integer)testConstructor: =Person&#123;country='CHINA', city='null', name='null', province='null', height=null&#125; 这说明我们成功通过反射调用 Person 带两个参数的沟改造方法. 3.1.3 注意事项如果该方法, 或者该变量不是 public 访问权限的, 我们应该调用相应的 setAccessible(true) 方法, 才能访问得到 12//if Constructor is not public,you should call thisdeclaredConstructor.setAccessible(true); 3.2 获得Filed变量3.2.1 获得所有的Filed变量123456789101112131415161718192021222324import java.lang.reflect.Field;public class Main&#123; public static void main(String[] args)&#123; String className = Person.class.getName(); printFiled(className); &#125; public static void printFiled(String className) &#123; try &#123; Class aClass = Class.forName(className); Field[] fields = aClass.getFields(); print(fields); System.out.println("============================"); Field[] declaredFields = aClass.getDeclaredFields(); print(declaredFields); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static void print(Field[] fields)&#123; for(Field field : fields)&#123; System.out.println(field.toString()); &#125; &#125;&#125; 运行结果: 123456789public java.lang.String Person.countrypublic java.lang.String Person.city============================public java.lang.String Person.countrypublic java.lang.String Person.cityprivate java.lang.String Person.nameprivate java.lang.String Person.provinceprivate java.lang.Integer Person.heightprivate java.lang.Integer Person.age 3.2.2 获得指定的Filed变量现在假如我们要获得 Person 中的私有变量 age , 我们可以通过以下的代码获得. 1234567891011121314151617import java.lang.reflect.Field;public class Main&#123; public static void main(String[] args) throws Exception&#123; String className = Person.class.getName(); Person person = new Person("CHINA", 12); Field field = getFiled(className, "age"); Integer integer = (Integer) field.get(person); System.out.println("integer = " + integer); &#125; public static Field getFiled(String className, String filedName) throws Exception&#123; Class aClass = Class.forName(className); Field declaredField = aClass.getDeclaredField(filedName); //if not public,you should call this declaredField.setAccessible(true); return declaredField; &#125;&#125; 运行结果: 1integer = 12 3.3 执行Method主要有以下几个方法: 1234public Method[] getDeclaredMethods()public Method[] getMethods() throws SecurityExceptionpublic Method getDeclaredMethod()public Method getMethod(String name, Class&lt;?&gt; ... parameterTypes) 3.3.1 获取所有的Method123456789101112131415161718192021import java.lang.reflect.Method;public class Main&#123; public static void main(String[] args)&#123; String className = Person.class.getName(); printMethods(className); &#125; public static void printMethods(String className) &#123; try &#123; Class&lt;?&gt; aClass = Class.forName(className); Method[] declaredMethods = aClass.getDeclaredMethods(); print(declaredMethods); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static void print(Method[] declaredMethods)&#123; for(Method method : declaredMethods)&#123; System.out.println(method.toString()); &#125; &#125;&#125; 运行结果: 12345public java.lang.String Person.toString()public java.lang.Class Person.getGenericType()private void Person.setCountry(java.lang.String)public void Person.getGenericHelper(java.util.HashMap)private java.lang.String Person.getMobile(java.lang.String) 3.3.2 获取指定的Method12345678910111213141516171819import java.lang.reflect.Method;public class Main&#123; public static void main(String[] args) throws Exception&#123; String className = Person.class.getName(); Person person=new Person(); Method method = getMethod(className, "setCountry", String.class); // 执行方法，结果保存在 person 中 Object o = method.invoke(person, "CHINA"); // 拿到我们传递进取的参数 country 的值 China String country=person.country; System.out.println("country : " + country); &#125; public static Method getMethod(String className, String methodName, Class&lt;?&gt;... clzs) throws Exception &#123; Class&lt;?&gt; aClass = Class.forName(className); Method declaredMethod = aClass.getDeclaredMethod(methodName, clzs); declaredMethod.setAccessible(true); return declaredMethod; &#125;&#125; 运行结果: 1country : CHINA 3.4 操作数组123456789101112131415161718192021222324import java.lang.reflect.Array;public class Main&#123; public static void main(String[] args) &#123; testArrayClass(); &#125; /** * 利用反射操作数组 * 1 利用反射修改数组中的元素 * 2 利用反射获取数组中的每个元素 */ public static void testArrayClass() &#123; String[] strArray = new String[]&#123;"5","7","暑期","美女","女生","女神"&#125;; Array.set(strArray,0,"帅哥"); Class clazz = strArray.getClass(); if (clazz.isArray()) &#123; int length = Array.getLength(strArray); for (int i = 0; i &lt; length; i++) &#123; Object object = Array.get(strArray, i); String className=object.getClass().getName(); System.out.println("----&gt; object=" + object+",className="+className); &#125; &#125; &#125;&#125; 运行结果: 123456----&gt; object=帅哥,className=java.lang.String----&gt; object=7,className=java.lang.String----&gt; object=暑期,className=java.lang.String----&gt; object=美女,className=java.lang.String----&gt; object=女生,className=java.lang.String----&gt; object=女神,className=java.lang.String 从结果可以说明, 我们成功通过 Array.set(strArray,0,”帅哥”) 改变数组的值. 3.5 获得泛型类型12public static void getGenericHelper(HashMap&lt;String, Person&gt; map) &#123;&#125; 现在假设我们有这样一个方法, 那我们要怎样获得 HashMap 里面的 String, Person 的类型呢? 123456789101112131415161718192021222324252627282930import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.HashMap;public class Main&#123; public static void main(String[] args) throws Exception&#123; getGenericType(); &#125; public static void getGenericType() throws Exception&#123; Method method =TestHelper.class.getDeclaredMethod("getGenericHelper", HashMap.class); Type[] genericParameterTypes = method.getGenericParameterTypes(); // 检验是否为空 if (null == genericParameterTypes || genericParameterTypes.length &lt; 1) &#123; return ; &#125; // 取 getGenericHelper 方法的第一个参数 ParameterizedType parameterizedType=(ParameterizedType)genericParameterTypes[0]; Type rawType = parameterizedType.getRawType(); System.out.println("----&gt; rawType=" + rawType); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); if (actualTypeArguments==genericParameterTypes || actualTypeArguments.length&lt;1) &#123; return ; &#125; // 打印出每一个类型 for (int i = 0; i &lt; actualTypeArguments.length; i++) &#123; Type type = actualTypeArguments[i]; System.out.println("----&gt; type=" + type); &#125; &#125;&#125; 运行结果: 123----&gt; rawType=class java.util.HashMap----&gt; type=class java.lang.String----&gt; type=class Person 3.6 怎样获得Metho, Field, Constructor的访问权限(public, private, ptotected等)其实很简单, 我们阅读文档可以发现他们都有 getModifiers() 方法, 该方法放回 int 数字, 我们在利用 Modifier.toString() 就可以得到他们的访问权限. 12int modifiers = method.getModifiers();Modifier.toString(modifiers); 4. 参考链接Java基础之—反射（非常重要）Java 反射机制详解]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java泛型]]></title>
    <url>%2F2018%2F09%2F23%2FJava%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1. 前言Java源码中有大量泛型的使用, 但是, 日常开发中, 对泛型特性的了解却仅限于表面的浅浅一层, 所以这里记录泛型相关的一些知识. 2. 泛型概述2.1 什么是泛型泛型, 即”参数化类型”. 一提到参数, 最熟悉的就是定义方法时有形参, 然后调用此方法时传递实参. 那么参数化类型怎么理解呢? 顾名思义, 就是将类型由原来的具体的类型参数化, 类似于方法中的变量参数, 此时类型也定义成参数形式(可以称之为类型形参), 然后在使用/调用时传入具体的类型(类型实参). 泛型的本质是为了参数化类型(在不创建新的类型的情况下, 通过泛型指定的不同类型来控制形参具体限制的类型). 也就是说在泛型使用过程中, 操作的数据类型被指定为一个参数, 这种参数类型可以用在类, 接口和方法中, 分别被称为泛型类, 泛型接口, 泛型方法. 2.2 为什么要有泛型代码示例: 1234567891011public class Main &#123; public static void main(String[] args)&#123; List arrayList = new ArrayList(); arrayList.add("aaaa"); arrayList.add(100); for(int i = 0; i&lt; arrayList.size();i++)&#123; String item = (String)arrayList.get(i); System.out.println("泛型测试, item = " + item); &#125; &#125;&#125; 运行结果: 123泛型测试, item = aaaaException in thread "main" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String at Main.main(Main.java:11) ArrayList可以存放任意类型, 例子中添加了一个String类型, 添加了一个Integer类型, 在使用时都以String的方式使用, 因此程序崩溃了. 为了解决类似这样的问题(在编译阶段就可以解决), 泛型应运而生.我们将第一行声明初始化list的代码更改一下, 编译器会在编译阶段就能够帮我们发现类似这样的问题. 123List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();...//arrayList.add(100); 在编译阶段，编译器就会报错 2.3 特性泛型只在编译阶段有效. 看下面的代码 12345678910public class Main &#123; public static void main(String[] args)&#123; List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;(); Class classStringArrayList = stringArrayList.getClass(); Class classIntegerArrayList = integerArrayList.getClass(); System.out.println(classStringArrayList); System.out.println(classIntegerArrayList); &#125;&#125; 结果: 12class java.util.ArrayListclass java.util.ArrayList 通过上面的例子可以证明, 在编译之后程序会采取去泛型化的措施. 也就是说Java中的泛型, 只在编译阶段有效. 在编译过程中, 正确检验泛型结果后, 会将泛型的相关信息擦除, 并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法. 也就是说, 泛型信息不会进入到运行时阶段. 3. 泛型的使用泛型有三种使用方式, 分别为: 泛型类, 泛型接口, 泛型方法 3.1 泛型类泛型类型用于类的定义中, 被称为泛型类. 通过泛型可以完成对一组类的操作对外开放相同的接口. 最典型的就是各种容器类, 如: List, Set, Map.泛型类的最基本写法(这么看可能会有点晕, 会在下面的例子中详解): 12345class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123; private 泛型标识 /*（成员变量类型）*/ var; ..... &#125;&#125; 一个最普通的泛型类: 123456789101112//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123; //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; &#125; public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; &#125;&#125; 1234567891011public class Main &#123; public static void main(String[] args)&#123; //泛型的类型参数只能是类类型（包括自定义类），不能是简单类型 //传入的实参类型需与泛型的类型参数类型相同，即为Integer. Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456); //传入的实参类型需与泛型的类型参数类型相同，即为String. Generic&lt;String&gt; genericString = new Generic&lt;String&gt;("key_vlaue"); System.out.println("泛型测试, key is " + genericInteger.getKey()); System.out.println("泛型测试, key is " + genericString.getKey()); &#125;&#125; 运行结果: 12泛型测试, key is 123456泛型测试, key is key_vlaue 定义的泛型类, 就一定要传入泛型类型实参么? 并不是这样, 在使用泛型的时候如果传入泛型实参, 则会根据传入的泛型实参做相应的限制, 此时泛型才会起到本应起到的限制作用. 如果不传入泛型类型实参的话, 在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型. 123456789101112public class Main &#123; public static void main(String[] args)&#123; Generic generic = new Generic("111111"); Generic generic1 = new Generic(4444); Generic generic2 = new Generic(55.55); Generic generic3 = new Generic(false); System.out.println("泛型测试, key is " + generic.getKey()); System.out.println("泛型测试, key is " + generic1.getKey()); System.out.println("泛型测试, key is " + generic2.getKey()); System.out.println("泛型测试, key is " + generic3.getKey()); &#125;&#125; 运行结果: 1234泛型测试, key is 111111泛型测试, key is 4444泛型测试, key is 55.55泛型测试, key is false 3.2 泛型接口泛型接口与泛型类的定义及使用基本相同. 泛型接口常被用在各种类的生产器中, 可以看一个例子: 1234//定义一个泛型接口public interface Generator&lt;T&gt; &#123; public T next();&#125; 当实现泛型接口的类, 未传入泛型实参时: 1234567891011/** * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错："Unknown class" */class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; @Override public T next() &#123; return null; &#125;&#125; 当实现泛型接口的类, 传入泛型实参时: 1234567891011121314151617/** * 传入泛型实参时： * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt; * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。 * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。 */public class FruitGenerator implements Generator&lt;String&gt; &#123; private String[] fruits = new String[]&#123;"Apple", "Banana", "Pear"&#125;; @Override public String next() &#123; Random rand = new Random(); return fruits[rand.nextInt(3)]; &#125;&#125; 3.3 泛型通配符我们知道Integer是Number的一个子类, 同时在特性章节中我们也验证过Generic与Generic实际上是相同的一种类型. 那么问题来了, 在使用Generic作为形参的方法中, 能否使用Generic的实例传入呢? 在逻辑上类似于Generic和Generic是否可以看成具有父子关系的泛型类型呢?为了弄清楚这个问题, 我们使用Generic这个泛型类继续看下面的例子: 12345678910111213public class Main &#123; public static void main(String[] args)&#123; Generic&lt;Integer&gt; gInteger = new Generic&lt;Integer&gt;(123); Generic&lt;Number&gt; gNumber = new Generic&lt;Number&gt;(456); showKeyValue(gNumber); // 下面showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt; // cannot be applied to Generic&lt;java.lang.Number&gt; // showKeyValue(gInteger); &#125; public static void showKeyValue(Generic&lt;Number&gt; obj)&#123; System.out.println("泛型测试, key value is " + obj.getKey()); &#125;&#125; 123456789101112//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123; //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; &#125; public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; &#125;&#125; 通过提示信息我们可以看到Generic不能被看作为`Generic的子类. 由此可以看出:同一种泛型可以对应多个版本(因为参数类型是不确定的), 不同版本的泛型类实例是不兼容的.回到上面的例子, 如何解决上面的问题? 总不能为了定义一个新的方法来处理Generic类型的类, 这显然与java中的多台理念相违背. 因此我们需要一个在逻辑上可以表示同时是Generic和Generic父类的引用类型. 由此类型通配符应运而生.我们可以将上面的方法改一下: 123public void showKeyValue(Generic&lt;?&gt; obj)&#123; System.out.println("泛型测试, key value is " + obj.getKey());&#125; 类型通配符一般是使用? 代替具体的类型实参, 注意了, 此处 ? 是类型实参, 而不是类型形参. 再直白点的意思就是, 此处的?和Number, String, Integer一样都是一种实际的类型, 可以把?看成所有类型的父类. 是一种真实的类型.可以解决当具体类型不确定的时候, 这个通配符就是?; 当操作类型时, 不需要使用类型的具体功能时, 只使用Object类中的功能. 那么可以用? 通配符来表未知类型. 3.4 泛型方法泛型类, 是在实例化类的时候指明泛型的具体类型, 泛型方法, 是在调用方法的时候指明泛型的具体类型. 123456789101112131415/** * 泛型方法的基本介绍 * @param tClass 传入的泛型实参 * @return T 返回值为T类型 * 说明： * 1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。 * 2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 * 3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。 * 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 */public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException , IllegalAccessException&#123; T instance = tClass.newInstance(); return instance;&#125; 1Object obj = genericMethod(Class.forName("Test")); 3.4.1 泛型方法的基本用法光看上面的例子有的同学可能依然会非常迷糊, 我们再通过一个例子, 把我泛型方法再总结一下. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class GenericTest &#123; //这个类是个泛型类，在上面已经介绍过 public class Generic&lt;T&gt;&#123; private T key; public Generic(T key) &#123; this.key = key; &#125; //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。 //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。 //所以在这个方法中才可以继续使用 T 这个泛型。 public T getKey()&#123; return key; &#125; /** * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E" * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。 public E setKey(E key)&#123; this.key = key &#125; */ &#125; /** * 这才是一个真正的泛型方法。 * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T * 这个T可以出现在这个泛型方法的任意位置. * 泛型的数量也可以为任意多个 * 如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123; * ... * &#125; */ public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123; System.out.println("container key :" + container.getKey()); //当然这个例子举的不太合适，只是为了说明泛型方法的特性。 T test = container.getKey(); return test; &#125; //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。 public void showKeyValue1(Generic&lt;Number&gt; obj)&#123; System.out.println("泛型测试, key value is " + obj.getKey()); &#125; //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符? //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类 public void showKeyValue2(Generic&lt;?&gt; obj)&#123; System.out.println("泛型测试, key value is " + obj.getKey()); &#125; /** * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' " * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。 * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。 public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123; ... &#125; */ /** * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' " * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。 * 所以这也不是一个正确的泛型方法声明。 public void showkey(T genericObj)&#123; &#125; */ public static void main(String[] args) &#123; &#125;&#125; 3.4.2 类中的泛型方法当然这并不是泛型方法的全部, 泛型方法可以出现杂任何地方和任何场景中使用. 但是有一种情况是非常特殊的, 当泛型方法出现在泛型类中时, 我们再通过一个例子看一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class GenericFruit &#123; class Fruit&#123; @Override public String toString() &#123; return "fruit"; &#125; &#125; class Apple extends Fruit&#123; @Override public String toString() &#123; return "apple"; &#125; &#125; class Person&#123; @Override public String toString() &#123; return "Person"; &#125; &#125; class GenerateTest&lt;T&gt;&#123; public void show_1(T t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。 //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。 public &lt;E&gt; void show_3(E t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。 public &lt;T&gt; void show_2(T t)&#123; System.out.println(t.toString()); &#125; &#125; public void main(String[] args) &#123; Apple apple = new Apple(); Person person = new Person(); GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;(); //apple是Fruit的子类，所以这里可以 generateTest.show_1(apple); //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person //generateTest.show_1(person); //使用这两个方法都可以成功 generateTest.show_2(apple); generateTest.show_2(person); //使用这两个方法也都可以成功 generateTest.show_3(apple); generateTest.show_3(person); &#125;&#125; 3.4.3 泛型方法与可变参数再看一个泛型方法和可变参数的例子: 12345678910public class Main&#123; public static void main(String[] args)&#123; printMsg("111",222,"aaaa","2323.4",55.55); &#125; public static &lt;T&gt; void printMsg( T... args)&#123; for(T t : args)&#123; System.out.println("泛型测试, t is " + t); &#125; &#125;&#125; 3.4.4 静态方法与泛型静态方法有一种情况需要注意一下, 那就是在类中的静态方法使用泛型: 静态方法无法访问类上定义的泛型; 如果静态方法操作的引用数据类型不确定的时候, 必须要将泛型定义在方法上.即: 如果静态方法要使用泛型的话, 必须将静态方法也定义成泛型方法. 12345678910111213public class StaticGenerator&lt;T&gt; &#123; .... .... /** * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法） * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。 * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息： "StaticGenerator cannot be refrenced from static context" */ public static &lt;T&gt; void show(T t)&#123; &#125;&#125; 3.4.5 泛型方法总结泛型方法能使方法独立于类而产生变化, 以下是一个基本的指导原则: 无论何时, 如果你能做到, 你就该尽量使用泛型方法. 也就是说, 如果使用泛型方法将整个类泛型化, 那么就应该使用泛型方法. 另外对于一个static的方法而言, 无法访问泛型类型的参数. 所以如果static方法要使用泛型能力, 就必须使其成为泛型方法. 3.5 泛型上下边界在使用泛型的时候, 我们还可以为传入的泛型类型实参进行上下边界的限制, 如: 类型实参只准传入某种类型的父类或某种类型的子类.为泛型添加上边界, 即传入的类型实参必须是指定类型的子类型. 123456789101112131415161718public class Main&#123; public static void main(String[] args)&#123; Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;("11111"); Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222); Generic&lt;Float&gt; generic3 = new Generic&lt;Float&gt;(2.4f); Generic&lt;Double&gt; generic4 = new Generic&lt;Double&gt;(2.56); //这一行代码编译器会提示错误，因为String类型并不是Number类型的子类 //showKeyValue1(generic1); showKeyValue1(generic2); showKeyValue1(generic3); showKeyValue1(generic4); &#125; public static void showKeyValue1(Generic&lt;? extends Number&gt; obj)&#123; System.out.println("泛型测试, key value is " + obj.getKey()); &#125;&#125; 如果我们把泛型类的定义也改一下: 123456789public class Generic&lt;T extends Number&gt;&#123; private T key; public Generic(T key) &#123; this.key = key; &#125; public T getKey()&#123; return key; &#125;&#125; 12//这一行代码也会报错，因为String不是Number的子类Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;("11111"); 再来一个泛型方法的例子: 1234567//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错："Unexpected bound"public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container)&#123; System.out.println("container key :" + container.getKey()); T test = container.getKey(); return test;&#125; 通过上面的两个例子可以看出: 泛型的上下边界添加, 必须与泛型的声明在一起. 3.6 泛型数组在Java中 “是不能创建一个确切的泛型类型的数组” 的.也就是说下面的这个例子是不可以的: 1List&lt;String&gt;[] ls = new ArrayList&lt;String&gt;[10]; 而使用通配符创建泛型数组是可以的, 如下面这个例子: 1List&lt;?&gt;[] ls = new ArrayList&lt;?&gt;[10]; 这样也是可以的: 1List&lt;String&gt;[] ls = new ArrayList[10]; 下面使用Sun的一篇文档的一个例子来说明这个问题: 1234567List&lt;String&gt;[] lsa = new List&lt;String&gt;[10]; // Not really allowed.Object o = lsa;Object[] oa = (Object[]) o;List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();li.add(new Integer(3));oa[1] = li; // Unsound, but passes run time store check String s = lsa[1].get(0); // Run-time error: ClassCastException. 这种情况下, 由于JVM泛型的擦除机制, 在运行时JVM是不知道泛型信息的, 所以可以给oa[1]赋上一个ArrayList而不会出现异常, 但是在取出数据的时候却要做一次类型转换, 所以就会出现ClassCastException, 如果可以进行泛型数组的声明, 上面说的这种情况在编译期将不会出现任何的警告和错误, 只有在运行时才会出错. 这个部分写不下去了, 记住一点就好. 不要使用泛型数组!!! 4. 参考链接java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java序列化]]></title>
    <url>%2F2018%2F09%2F23%2FJava%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1. 前言阅读源码和日常开发, 序列化也是基础中的基础, 这篇文章主要是记录序列化相关的知识点. 2. 基本概念2.1 什么是序列化和反序列化 Java序列化是指把Java对象转换为字节序列的过程, 而Java反序列化是指把字节序列恢复为Java对象的过程; 序列化: 对象序列化的最主要的用处就是在传递和保存对象的时候, 保证对象的完整性和可传递性. 序列化是把对象转换成有序字节流, 以便在网络上传输或者保存在本地文件中. 序列化后的字节流保存了Java对象的状态以及相关的描述信息. 序列化机制的核心作用就是对象状态的保存与重建. 反序列化: 客户端从文件中或网络上获得序列化后的对象字节流后, 根据字节流中所保存的对象状态及描述信息, 通过反序列化重建对象. 本质上讲, 序列化就是把实体对象状态按照一定的格式写入到有序字节流, 反序列化就是从有序字节流重建对象, 恢复对象状态. 2.2 为什么需要序列化与反序列化我们知道, 当两个进程进行远程通信时, 可以相互发送各种类型的数据, 包括文本, 图片, 音频, 视频等, 而这些数据都会以二进制序列的形式在网络上传送.那么当两个Java进程进行通信时, 能否实现进程间的对象传送呢? 答案是可以的! 如何做到? 这就需要Java序列化与反序列化了!换句话说, 一方面, 发送方需要把这个Java对象转换为字节序列, 然后在网络上传送; 另一方面, 接收方需要从字节序列中恢复出Java对象.当我们明晰了为什么需要Java序列化和反序列化后, 我们很自然地会想Java序列化的好处. 其好处一是实现了数据的持久化, 通过序列化可以把数据永久地保存到硬盘上(通常存放在文件里), 二是, 利用序列化实现远程通信, 即在网络上传送对象的字节序列.总的来说可以归结为以下几点: 永久性保存对象, 保存对象的字节序列到本地文件或者数据库中; 通过序列化以字节流的形式使对象在网络中进行传递和接收; 通过序列化在进程间传递对象; 2.3 序列化算法一般会按步骤做如下事情 将对象实例相关的类元数据输出. 递归地输出类的超类描述直到不再有超类. 类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值. 从上至下递归输出实例的数据. 2.4 Java如何实现序列化和反序列化2.4.1 JDK类库中序列化和反序列化APIjava.io.ObjectOutputStream: 表示对象输出流;它的writeObject(Object obj)方法可以对参数指定的obj对象进行序列化, 把得到的字节序列写到一个目标输出流中;java.io.ObjectInputStream: 表示对象输入流;它的readObject()方法源输入流中读取字节序列, 再把它们反序列化成为一个对象, 并将其返回; 2.4.2 实现序列化的要求只有实现了Serializable或Externalizable接口的类的对象才能被序列化, 否则抛出异常! 2.4.3 实现Java对象序列化与反序列化的方法假定一个User类, 它的对象需要序列化, 可以有如下三种方法: 若User类仅仅实现了Serializable接口, 则可以按照以下方式进行序列化和反序列化:ObjectOutputStream采用默认的序列化方式, 对User对象的非transient的实例变量进行序列化.ObjcetInputStream采用默认的反序列化方式, 对User对象的非transient的实例变量进行反序列化. 若User类仅仅实现了Serializable接口, 并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out), 则采用以下方式进行序列化与反序列化:ObjectOutputStream调用User对象的writeObject(ObjectOutputStream out)的方法进行序列化.ObjectInputStream会调用User对象的readObject(ObjectInputStream in)的方法进行反序列化. 若User类实现了Externalnalizable接口, 且User类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法, 则按照以下方式进行序列化与反序列化:ObjectOutputStream调用User对象的writeExternal(ObjectOutput out))的方法进行序列化.ObjectInputStream会调用User对象的readExternal(ObjectInput in)的方法进行反序列化. 2.5 JDK类库中序列化和反序列化的步骤序列化步骤: 1234// 步骤一: 创建一个对象输出流, 它可以包装一个其它类型的目标输出流, 如文件输出流:ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("D:\\object.out"));// 步骤二: 通过对象输出流的writeObject()方法写对象:oos.writeObject(new User("xuliugen", "123456", "male")); 反序列化步骤: 1234// 步骤一: 创建一个对象输入流, 它可以包装一个其它类型输入流，如文件输入流：ObjectInputStream ois= new ObjectInputStream(new FileInputStream("object.out"));// 步骤二: 通过对象输出流的readObject()方法读取对象：User user = (User) ois.readObject(); 2.6 示例1234567891011121314151617181920212223242526272829303132333435363738import java.io.*;public class Main &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //序列化 FileOutputStream fos = new FileOutputStream("object.out"); ObjectOutputStream oos = new ObjectOutputStream(fos); User user1 = new User("xuliugen", "123456", "male"); oos.writeObject(user1); oos.flush(); oos.close(); //反序列化 FileInputStream fis = new FileInputStream("object.out"); ObjectInputStream ois = new ObjectInputStream(fis); User user2 = (User) ois.readObject(); System.out.println(user2.getUserName()+ " " + user2.getPassword() + " " + user2.getSex()); //反序列化的输出结果为：xuliugen 123456 male &#125;&#125;class User implements Serializable &#123; private String userName; private String password; private String sex; public User(String userName, String password, String sex) &#123; this.userName = userName; this.password = password; this.sex = sex; &#125; public String getUserName() &#123; return userName; &#125; public String getPassword() &#123; return password; &#125; public String getSex() &#123; return sex; &#125;&#125; 序列化图示反序列化图示 3. 注意事项 序列化时, 只对对象的状态进行保存, 而不管对象的方法; 当一个父类实现序列化, 子类自动实现序列化, 不需要显式实现Serializable接口; 当一个对象的实例变量引用其他对象, 序列化该对象时也把引用对象进行序列化; 并非所有的对象都可以序列化, 至于为什么不可以, 有很多原因了, 比如:a. 安全方面的原因, 比如一个对象拥有private, public等field, 对于一个要传输的对象, 比如写到文件, 或者进行RMI传输等等, 在序列化进行传输的过程中, 这个对象的private等域是不受保护的;b. 资源分配方面的原因, 比如socket, thread类, 如果可以序列化, 进行传输或者保存, 也无法对他们进行重新的资源分配, 而且, 也是没有必要这样实现; 声明为static和transient类型的成员数据不能被序列化. 因为static代表类的状态, transient代表对象的临时数据. 序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联, 该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类. 为它赋予明确的值. 显式地定义serialVersionUID有两种用途:a. 在某些场合, 希望类的不同版本对序列化兼容, 因此需要确保类的不同版本具有相同的serialVersionUID;b. 在某些场合, 不希望类的不同版本对序列化兼容, 因此需要确保类的不同版本具有不同的serialVersionUID. Java有很多基础类已经实现了serializable接口, 比如String,Vector等.但是也有一些没有实现serializable接口的; 如果一个对象的成员变量是一个对象, 那么这个对象的数据成员也会被保存, 这是能用序列化解决深拷贝的重要原因. 4. 参考链接序列化和反序列化的底层实现原理是什么？深入理解JAVA序列化]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java关键字final]]></title>
    <url>%2F2018%2F09%2F23%2FJava%E5%85%B3%E9%94%AE%E5%AD%97final%2F</url>
    <content type="text"><![CDATA[1. 前言阅读Java源码或者日常后台开发中, 会不可避免的与final打交道, 那么final关键字究竟有哪些特性?这篇文章主要介绍final关键字及其相关知识点. 2. 基本用法在Java中, final可以用来修饰类,方法和变量(包括成员变量和局部变量). 我们先来简单介绍一下final关键字的这几个用法. 2.1 final修饰类常见的一个例子就是String类. 当用final修饰一个类时, 表明这个类不能被继承, 并且final类中的所有成员方法都会被隐式地指定为final方法, 但成员变量不会变.一般来说, 我们还是尽量不要将类设计为final类, 除非我们出于某些因素的考虑必须这么做. 比如不希望类被继承, 也就是说不希望类被修改语义. 如果我们继承String类, 那么就可以定义一个可被修改的String类, 这对于String类的使用者来说近乎是一种灾难. 2.2 final修饰方法使用final修饰方法有两个原因:一是把方法锁定, 以防任何继承类修改它的含义;二是效率. 在早期的Java实现版本中, 会将final方法转为内嵌调用. 但是如果方法过于庞大, 可能看不到内嵌调用带来的任何性能提升. 在最近的Java版本中, 不需要使用final方法进行这些优化了.同final类相似, 只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final. 另外,类 的private方法会隐式地被指定为final方法, 其语义要求private方法不能被重新定义. 2.3 final修饰变量final用得最多的地方就是修饰变量. 对于一个final变量, 如果是基本数据类型的变量, 则其数值一旦在初始化之后便不能更改;如果是引用类型的变量, 则在对其初始化之后便不能再让其指向另一个对象, 但是它指向的对象的内容是可变的.由于final变量初始化之后无法修改, 针对这个特性, Java编译器对此进行了优化. 当final变量是基本数据类型以及String类型时, 如果在编译期间能知道它的确切值, 则编译器会把它当做编译期常量使用. 这个优化通常对于程序逻辑没有太多影响, 但如果用==比较的时候, 可能会出乎意料. 3. 总结综上所述, final在修饰类和方法时, 代表不能再修改其定义, 而在修饰变量时, 则类似C++中的const关键字, 用于表示常量. 一个好的编程习惯是我们应该尽量将变量声明为final的, 除非变量必须是可变的. 例如当你在方法中不需要改变作为参数的变量时, 可以使用final进行声明, 这样可以防止你无意的修改, 尤其是当你的方法很长很复杂的时候. 当然是否用final修饰参数, 都不会影响方法之外的变量. 4. 参考链接聊聊Java的final关键字]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java字符串处理]]></title>
    <url>%2F2018%2F09%2F23%2FJava%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 前言对字符串的操作是后台开发中非常常见的, 对字符串相关的类有深刻的认识有助于写出高质量的代码. 这篇文章主要是介绍String, StringBuffer, StringBuilder这三个字符串相关的类. 2. 基本认识2.1 String1234567891011121314/** Strings are constant; their values cannot be changed after they * are created. String buffers support mutable strings. * Because String objects are immutable they can be shared. * 字符串是不变的，他们的值在创造后不能改变。 * 字符串缓冲区支持可变字符串，因为字符串对象是不可变的，所以它们可以共享。 * * @see StringBuffer * @see StringBuilder * @see Charset * @since 1.0 */public final class String implements Serializable, Comparable&lt;String&gt;, CharSequence &#123; private static final long serialVersionUID = -6849794470754667710L; private static final char REPLACEMENT_CHAR = (char) 0xfffd; 这句话总结归纳了String的两个最重要的特点:String是值不可变的常量, 是线程安全的(can be shared).String类使用了final修饰符, String类是不可继承的. 2.2 StringBufferStringBuffer字符串变量(线程安全)是一个容器, 最终会通过toString方法变成字符串; 1234567891011121314151617181920public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, Appendable, CharSequence&#123; /** * Constructs a string buffer with no characters in it and an * initial capacity of 16 characters. */ public StringBuffer() &#123; super(16); &#125; public synchronized StringBuffer append(int i) &#123; super.append(i); return this; &#125; public synchronized StringBuffer delete(int start, int end) &#123; super.delete(start, end); return this; &#125;&#125; 2.3 StringBuilderStringBuilder 字符串变量(非线程安全). 12345678910111213public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, Appendable, CharSequence &#123; public StringBuilder() &#123; super(16); &#125; public StringBuilder append(String str) &#123; super.append(str); return this; &#125; public StringBuilder delete(int start, int end) &#123; super.delete(start, end); return this; &#125;&#125; 3. 源码理解3.1 String 与 StringBuffer/StringBuilder 的区别String和StringBuffer/StringBuilder底层都是一个char数组, 但是String的char数组是final的;StringBuffer/StringBuilder的char数组不是final的.(1)String在修改时不会改变对象自身, 在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象, 然后将指针指向新的 String 对象, 所以经常改变内容的字符串最好不要用 String. 1234567public class Main &#123; public static void main(String[] args) &#123; String str = "abc"; String str2 = str + ""; System.out.println(str == str2); &#125;&#125; 结果: 1false (2)StringBuffer/StringBuilder在修改时会改变对象自身, 每次结果都会对StringBuffer/StringBuilder对象本身进行操作, 而不是生成新的对象, 再改变对象引用. 所以在一般情况下我们推荐使用StringBuffer/StringBuilder, 特别是字符串对象经常改变的情况下.StringBuffer/StringBuilder上的主要操作是 append 和 insert 方法. 1234567public class Main &#123; public static void main(String[] args) &#123; StringBuffer stringBuffer = new StringBuffer("abc"); StringBuffer stringBuffer2 = stringBuffer.append("a"); System.out.println(stringBuffer == stringBuffer2); &#125;&#125; 结果: 1true 3.2 StringBuffer 与 StringBuilder 的区别StringBuffer: 线程安全的, 通过synchronized实现;StringBuilder: 线程非安全的. 4. 总结 如果要操作少量的数据用 String; 多线程操作字符串缓冲区下操作大量数据 StringBuffer; 单线程操作字符串缓冲区下操作大量数据 StringBuilder. 5. 参考链接Java基础之String、StringBuffer与StringBuilder的区别及应用场景]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合(三)----HashMap]]></title>
    <url>%2F2018%2F09%2F22%2FJava%E9%9B%86%E5%90%88(%E4%B8%89)----HashMap%2F</url>
    <content type="text"><![CDATA[1. 前言集合是Java基础中非常重要的一部分, 也是日常中用到非常多的类, 这篇博客主要记录集合HashMap相关的知识. 2. HashMap2.1 概述HashMap 是用于映射(键值对)处理的数据类型, 基于哈希表的 Map 接口的非同步实现, 允许插入最多一条key为null的记录, 允许插入多条value为null的记录. 此外, HashMap 不保证元素顺序, 根据需要该容器可能会对元素重新哈希, 元素的顺序也会被重新打散, 因此在不同时间段迭代同一个 HashMap 的顺序可能会不同. HashMap 非线程安全, 即任一时刻有多个线程同时写 HashMap 的话可能会导致数据的不一致. HashMap 实际上是数组+链表+红黑树的结合体, 其底层包含一个数组, 数组中的每一项元素的可能值有四种: null, 单独一个结点, 链表, 红黑树(JDK1.8 开始 HashMap 通过使用红黑树来提高元素查找效率). 当往 HashMap 中 put 元素的时候, 需要先根据 key 的哈希值得到该元素在数组中的位置(即下标), 如果该位置上已经存放有其他元素了, 那么在这个位置上的元素将以链表或者红黑树的形式来存放, 如果该位置上没有元素, 就直接向该位置存放元素.HashMap 要求映射中的 key 是不可变对象，即要求该对象在创建后它的哈希值不会被改变，否则 Map 对象很可能就定位不到映射的位置了. 2.2 类声明12public class HashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable, Serializable 2.3 常量HashMap 中声明的常量有以下几个, 其中需要特别关注的是装载因子 DEFAULT_LOAD_FACTOR 和 TREEIFY_THRESHOLD. 装载因子用于规定数组在自动扩容之前可以数据占有其容量的最高比例, 即当数据量占有数组的容量达到这个比例后, 数组将自动扩容. 装载因子衡量的是一个散列表的空间的使用程度, 装载因子越大表示散列表的装填程度越高, 反之愈小. 因此如果装载因子越大, 则对空间的利用程度更高, 相对应的是查找效率的降低. 如果装载因子太小, 那么数组的数据将过于稀疏, 对空间的利用率低, 官方默认的装载因子为0.75, 是平衡空间利用率和运行效率两者之后的结果. 如果在实际情况中, 内存空间较多而对时间效率要求很高, 可以选择降低装载因子的值; 如果内存空间紧张而对时间效率要求不高, 则可以选择提高装载因子的值. 此外, 即使装载因子和哈希算法设计得再合理, 也不免会出现由于哈希冲突导致链表长度过长的情况, 这将严重影响 HashMap 的性能. 为了优化性能, 从 JDK1.8 开始引入了红黑树, 当链表长度超出 TREEIFY_THRESHOLD 规定的值时, 链表就会被转换为红黑树, 利用红黑树快速增删改查的特点以提高 HashMap 的性能. 12345678910111213141516171819202122//序列化IDprivate static final long serialVersionUID = 362498820763181265L;//哈希桶数组的默认容量static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;//网上很多文章都说这个值是哈希桶数组能够达到的最大容量，其实这样说并不准确//从 resize() 方法的扩容机制可以看出来，HashMap 每次扩容都是将数组的现有容量增大一倍//如果现有容量已大于或等于 MAXIMUM_CAPACITY ，则不允许再次扩容//否则即使此次扩容会导致容量超出 MAXIMUM_CAPACITY ，那也是允许的static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//装载因子的默认值//装载因子用于规定数组在自动扩容之前可以数据占有其容量的最高比例，即当数据量占有数组的容量达到这个比例后，数组将自动扩容//装载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小//对于使用链表的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，则对空间的利用程度更高，相对应的是查找效率的降低//如果负载因子太小，那么数组的数据将过于稀疏，对空间的利用率低//官方默认的负载因子为0.75，是平衡空间利用率和运行效率两者之后的结果static final float DEFAULT_LOAD_FACTOR = 0.75f;//为了提高效率，当链表的长度超出这个值时，就将链表转换为红黑树static final int TREEIFY_THRESHOLD = 8; 2.4 成员变量123456789101112131415161718192021222324//哈希桶数组，在第一次使用时才初始化//容量值应是2的整数倍transient Node&lt;K, V&gt;[] table;/** * Holds cached entrySet(). Note that AbstractMap fields are used * for keySet() and values(). */transient Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;//Map的大小transient int size;//每当Map的结构发生变化时，此参数就会递增//当在对Map进行迭代操作时，迭代器会检查此参数值//如果检查到此参数的值发生变化，就说明在迭代的过程中Map的结构发生了变化，因此会直接抛出异常transient int modCount;//数组的扩容临界点，当数组的数据量达到这个值时就会进行扩容操作//计算方法：当前容量 x 装载因子int threshold;//使用的装载因子值final float loadFactor; 2.5 构造函数12345678910111213141516171819202122232425262728//设置Map的初始化大小和装载因子public HashMap(int initialCapacity, float loadFactor) &#123; //检查参数合法性 if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125;//设置Map的初始化大小public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;//都使用默认值public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR;&#125;//传入初始数据public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 2.6 结点类123456789101112131415161718//结点static class Node&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123; //当前结点的 key 的哈希值 final int hash; //键 final K key; //值 V value; //下一个结点 Node&lt;K, V&gt; next; Node(int hash, K key, V value, Node&lt;K, V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; ···&#125; 2.7 哈希算法在查询, 添加和移除键值对时, 定位到哈希桶数组的指定位置都是很关键的第一步, 只有 HashMap 中的元素尽量分布均匀, 才能在定位键值对时快速地查找到相应位置, 避免频繁地去遍历链表或者红黑树, 这就需要依靠于一个比较好的哈希算法了. 以下是 HashMap 中计算 key 值的哈希值以及根据哈希值获取其在哈希桶数组中位置的算法. 12345678910111213141516171819202122//计算哈希值static final int hash(Object key) &#123; int h; //高位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;//根据 key 值获取 Valuepublic V get(Object key) &#123; Node&lt;K, V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;//查找指定结点final Node&lt;K, V&gt; getNode(int hash, Object key) &#123; ··· //只有当 table 不为空且 hash 对应的位置不为 null 才有可获取的元素值 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; ··· &#125; return null;&#125; 确定键值对在哈希桶数组的位置的步骤分为三步: 计算 key 的 hashCode（h = key.hashCode()）, 高位运算（h &gt;&gt;&gt; 16）、取模运算（(n - 1) &amp; hash） 2.8 插入数据在上边说过, HashMap 是数组+链表+红黑树的结合, 数组包含的元素的可能值分为四种类型: null, 单个结点, 链表, 红黑树. 在插入结点时(每一个待存数据都会被包装为结点对象), 会根据待插入 Key 的哈希值来决定结点在数组中的位置, 如果计算得出的位置此时包含的元素为 null , 则直接将结点存入该位置, 如果不为 null , 则说明发生了哈希碰撞, 此时就需要将结点插入到链表或者是红黑树中. 当哈希算法的计算结果越分散均匀, 哈希碰撞的概率就越小, map 的存取效率就会越高. 如果待插入结点的 key 与链表或红黑树中某个已有结点的 key 相等(hash 值相等且两者 equals 成立), 则新添加的结点将覆盖原有数据.插入数据对应的是 put(K key, V value) 方法. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//插入数据public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;//计算哈希值static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent 为 true 表示不会覆盖有相同 key 的非 null value，否则会覆盖原有值 * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; p; int n, i; //如果 table 还未初始化，则调用 resize 方法进行初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //判断要存入的 key 是否存在哈希冲突，等于 null 说明不存在冲突 if ((p = tab[i = (n - 1) &amp; hash]) == null) //直接在索引 i 处构建包含待存入元素的结点 tab[i] = newNode(hash, key, value, null); else &#123; //走入本分支，说明待存入的 key 存在哈希冲突 Node&lt;K, V&gt; e; K k; //p 值已在上一个 if 语句中赋值了，此处就直接来判断 key 值之间的相等性 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //指向冲突的头结点 e = p; //如果头结点的 key 与待插入的 key 不相等，且头结点是 TreeNode 类型，说明该 hash 值是采用红黑树来处理冲突 else if (p instanceof TreeNode) //如果红黑数中包含有相同 key 的结点，则返回该结点，否则返回 null e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(this, tab, hash, key, value); else &#123; //采用链表来处理 hash 值冲突 for (int binCount = 0; ; ++binCount) &#123; //当遍历到链表尾部时 if ((e = p.next) == null) &#123; //构建一个新的结点添加到链表尾部 p.next = newNode(hash, key, value, null); //如果链表的长度已达到允许的最大长度 TREEIFY_THRESHOLD - 1 时，就将链表转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //当 e 指向的结点的 key 值与待插入的 key 相等时则跳出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; //如果 e != null，说明原先已存在相同 key 的键 if (e != null) &#123; V oldValue = e.value; //只有当 onlyIfAbsent 为 true 且 oldValue 不为 null 时才不会覆盖原有值 if (!onlyIfAbsent || oldValue == null) e.value = value; //用于 LinkedHashMap ，在 HashMap 中是空实现 afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //当元素数量达到扩容临界点时，需要进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 2.9 读取数据读取数据对应的是 get(Object key)方法 12345678910111213141516171819202122232425262728293031//根据 key 值获取 Valuepublic V get(Object key) &#123; Node&lt;K, V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;//查找指定结点final Node&lt;K, V&gt; getNode(int hash, Object key) &#123; Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; first, e; int n; K k; //只有当 table 不为空且 hash 对应的位置不为 null 才有可获取的元素值 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //如果头结点的 hash 值与 Key 与待插入数据相等的话，则说明找到了对应值 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // first.next != null 说明存在哈希冲突 if ((e = first.next) != null) &#123; //如果是由红黑树来处理哈希冲突，则由此查找相应结点 if (first instanceof TreeNode) return ((TreeNode&lt;K, V&gt;) first).getTreeNode(hash, key); //遍历链表 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 2.10 移除结点从 Map 中移除键值对的操作, 在底层数据结构的体现就是移除对某个结点对象的引用, 可能是从数组中, 也可能是链表或者红黑树. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public V remove(Object key) &#123; Node&lt;K, V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; &#125; /** * Implements Map.remove and related methods * * @param hash key 的哈希值 * @param key the key * @param value key对应的值，只有当 matchValue 为 true 时才需要使用到，否则忽略该值 * @param matchValue 如果为 true ，则只有当 Map 中存在某个键 equals key 且 value 相等时才会移除该元素，否则只要 key 的 hash 值相等就直接移除该元素 * @param movable if false do not move other nodes while removing * @return the node, or null if none */ final Node&lt;K, V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; p; int n, index; //只有当 table 不为空且 hash 对应的索引位置存在值时才有可移除的对象 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K, V&gt; node = null, e; K k; V v; //如果与头结点的 key 相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; //存在哈希冲突 //用红黑树来处理哈希冲突 if (p instanceof TreeNode) //查找对应结点 node = ((TreeNode&lt;K, V&gt;) p).getTreeNode(hash, key); else &#123; //用链表来处理哈希冲突 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; //node != null 说明存在相应结点 //如果 matchValue 为 false ，则通过之前的判断可知查找到的结点的 key 与 参数 key 的哈希值一定相等，此处就可以直接移除结点 node //如果 matchValue 为 true ，则当 value 相等时才需要移除该结点 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) //对应红黑树 ((TreeNode&lt;K, V&gt;) node).removeTreeNode(this, tab, movable); else if (node == p) //对应 key 与头结点相等的情况，此时直接将指针移向下一位即可 tab[index] = node.next; else //对应的是链表的情况 p.next = node.next; ++modCount; --size; //用于 LinkedHashMap ，在 HashMap 中是空实现 afterNodeRemoval(node); return node; &#125; &#125; return null; &#125; 2.11 扩容如果哈希桶数组很大, 即使用的是较差的哈希算法元素也会比较分散, 如果哈希桶数组很小, 即使用的是好的哈希算法也会出现较多哈希碰撞的情况, 所以就需要在空间成本和时间成本之间权衡, 除了设计较好的哈希算法以减少哈希冲突外, 也需要在合适的的时机对哈希桶数组进行必要的扩容. 当 HashMap 中的元素越来越多时, 因为数组的长度是固定的, 所以哈希冲突的几率也就越来越高, 为了提高效率, 此时就需要对 HashMap 中的数组进行扩容, 而扩容操作最消耗性能的地方就在于: 原数组中的数据必须重新计算其在新数组中的位置并存放到新数组中. 那么 HashMap 扩容操作的触发时机是什么时候呢? 当 HashMap 中的元素个数超出 threshold 时(数组容量 与 loadFactor 的乘积), 就会进行数组扩容. 默认情况下, 数组的默认值为 16, loadFactor 的默认值为 0.75, 这是平衡空间利用率和运行效率两者之后的结果. 也就是说, 假设数组当前大小为16, loadFactor 值为0.75, 那么当 HashMap 中的元素个数达到12个时, 就会自动触发扩容操作, 把数组的大小扩充到 2 * 16 = 32, 即扩大一倍, 然后重新计算每个元素在新数组中的位置, 而这是一个非常消耗性能的操作, 所以如果已经预知到待存入 HashMap 的数据量, 那么在初始化 HashMap 时直接指定初始化大小会是一种更为高效的做法. 更改: 那么 HashMap 扩容操作的触发时机是什么时候呢?同时满足下面的两个条件:1. 存放新值的时候当前已有元素的个数必须大于等于阈值2. 存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值换算出来的数组下标位置已经存在值） 扩容操作对应的是 resize()方法 2.11.1 JDK1.8引入的扩容巧妙设计经过rehash之后, 元素的位置要么是在原位置, 要么是在原位置再移动2次幂的位置.图(a)表示扩容前的key1和key2两种key确定索引位置的示例;图(b)表示扩容后key1和key2两种key确定索引位置的示例, 其中hash1是key1对应的哈希与高位运算结果.元素在重新计算hash之后, 因为n变为2倍, 那么n-1的mask范围在高位多1bit(红色), 因此新的index就会发生这样的变化因此, 我们在扩充HashMap的时候, 不需要像JDK1.7的实现那样重新计算hash, 只需要看看原来的hash值新增的那个bit是1还是0就好了, 是0的话索引没变, 是1的话索引变成”原索引+oldCap”, 可以看看下图为16扩充为32的resize示意图:这个设计确实非常的巧妙, 既省去了重新计算hash值的时间, 而且同时, 由于新增的1bit是0还是1可以认为是随机的, 因此resize的过程, 均匀的把之前的冲突的节点分散到新的bucket了. 这一块就是JDK1.8新增的优化点. 有一点注意区别, JDK1.7中rehash的时候, 旧链表迁移新链表的时候, 如果在新表的数组索引位置相同, 则链表元素会倒置, 但是从上图可以看出, JDK1.8不会倒置. 2.11.2 resize源码解读12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879final Node&lt;K, V&gt;[] resize() &#123; Node&lt;K, V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float) newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float) MAXIMUM_CAPACITY ? (int) ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes"，"unchecked"&#125;) Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K, V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K, V&gt;) e).split(this, newTab, j, oldCap); else &#123; // 链表优化重hash的代码块 Node&lt;K, V&gt; loHead = null, loTail = null; Node&lt;K, V&gt; hiHead = null, hiTail = null; Node&lt;K, V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125;// 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 2.12 效率测试这里来测试下不同的初始化大小以及 key 值的 HashCode 值的分布情况的不同对 HashMap 效率的影响首先来定义作为 Key 的类, hashCode() 方法直接返回其包含的属性 value 123456789101112131415161718import java.util.Objects;public class Key &#123; private int value; public Key(int value) &#123; this.value = value; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Key key = (Key) o; return value == key.value; &#125; @Override public int hashCode() &#123; return Objects.hash(value); &#125;&#125; 初始化大小从 100 到 100000 之间以 10 倍的倍数递增，向 HashMap 存入同等数据量的数据，观察不同 HashMap 存入数据消耗的总时间 12345678910111213141516171819202122232425import java.util.HashMap;import java.util.Map;public class KeyMain &#123; private static final int MAX_KEY = 20000; private static final Key[] KEYS = new Key[MAX_KEY]; static &#123; for (int i = 0; i &lt; MAX_KEY; i++) &#123; KEYS[i] = new Key(i); &#125; &#125; private static void test(int size) &#123; long startTime = System.currentTimeMillis(); Map&lt;Key, Integer&gt; map = new HashMap&lt;&gt;(size); for (int i = 0; i &lt; MAX_KEY; i++) &#123; map.put(KEYS[i], i); &#125; long endTime = System.currentTimeMillis(); System.out.println("初始化大小是：" + size + " , 所用时间：" + (endTime - startTime) + "毫秒"); &#125; public static void main(String[] args) &#123; for (int i = 20; i &lt;= MAX_KEY; i *= 10) &#123; test(i); &#125; &#125;&#125; 运行结果: 1234初始化大小是：20 , 所用时间：9毫秒初始化大小是：200 , 所用时间：13毫秒初始化大小是：2000 , 所用时间：5毫秒初始化大小是：20000 , 所用时间：3毫秒 在上述使用的例子中, 各个 Key 对象之间的哈希码值各不相同, 所以键值对在哈希桶数组中的分布可以说是很均匀的了, 此时主要影响性能的就是扩容机制了, 由上图可以看出各个初始化大小对 HashMap 的性能影响还是很大的接下来再看看各个 Key 对象之间频繁发生哈希冲突时 HashMap 的性能令 Key 类的 hashCode() 方法固定返回 100, 则每个键值对在存入 HashMap 时, 一定会发生哈希冲突 1234@Overridepublic int hashCode() &#123; return 100;&#125; 运行结果: 1234初始化大小是：20 , 所用时间：6192毫秒初始化大小是：200 , 所用时间：6004毫秒初始化大小是：2000 , 所用时间：5633毫秒初始化大小是：20000 , 所用时间：5914毫秒 此时主要影响性能的点就在于对哈希冲突的处理了 2.13 equals()和hashCode()在使用Map存对象的时候, 要记得, 一定要重写此类的 equals() 和 hashCode() 方法哦!!! 3. 参考链接HashMap源码，你知道多少？HashMap的扩容机制—resize()深入理解HashMap的扩容机制]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合(二)----Set]]></title>
    <url>%2F2018%2F09%2F22%2FJava%E9%9B%86%E5%90%88(%E4%BA%8C)----Set%2F</url>
    <content type="text"><![CDATA[1. 前言集合是Java基础中非常重要的一部分, 也是日常中用到非常多的类, 这篇博客主要记录集合Set相关的知识. 特别声明: 大部分内容并非原创, 引用自参考链接. 2. SetSet继承于Collection接口, 是一个不允许出现重复元素, 并且无序的集合, 主要有HashSet和TreeSet两大实现类.在判断重复元素的时候, Set集合会调用hashCode()和equal()方法来实现.HashSet是哈希表结构, 主要利用HashMap的key来存储元素, 计算插入元素的hashCode来获取元素在集合中的位置;TreeSet是红黑树结构, 每一个元素都是树中的一个节点, 插入的元素都会进行排序; 2.1 Set常用操作与List接口一样, Set接口也提供了集合操作的基本方法.但与List不同的是, Set还提供了equals(Object o)和hashCode(), 供其子类重写, 以实现对集合中插入重复元素的处理; 12345678910111213141516171819202122232425262728293031public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123; A:添加功能 boolean add(E e); boolean addAll(Collection&lt;? extends E&gt; c); B:删除功能 boolean remove(Object o); boolean removeAll(Collection&lt;?&gt; c); void clear(); C:长度功能 int size(); D:判断功能 boolean isEmpty(); boolean contains(Object o); boolean containsAll(Collection&lt;?&gt; c); boolean retainAll(Collection&lt;?&gt; c); E:获取Set集合的迭代器： Iterator&lt;E&gt; iterator(); F:把集合转换成数组 Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); //判断元素是否重复，为子类提高重写方法 boolean equals(Object o); int hashCode();&#125; 2.2 初识HashSetHashSet实现Set接口, 底层由HashMap(后面讲解)来实现, 为哈希表结构, 新增元素相当于HashMap的key, value默认为一个固定的Object. HashSet相当于一个阉割版的HashMap;当有元素插入的时候, 会计算元素的hashCode值, 将元素插入到哈希表对应的位置中来;它继承于AbstractSet, 实现了Set, Cloneable, Serializable接口.(1)HashSet继承AbstractSet类, 获得了Set接口大部分的实现, 减少了实现此接口所需的工作, 实际上是又继承了AbstractCollection类;(2)HashSet实现了Set接口, 获取Set接口的方法, 可以自定义具体实现, 也可以继承AbstractSet类中的实现;(3)HashSet实现Cloneable, 得到了clone()方法, 可以实现克隆功能;(4)HashSet实现Serializable, 表示可以被序列化, 通过序列化去传输, 典型的应用就是hessian协议.具有如下特点:(1)不允许出现重复因素;(2)允许插入Null值;(3)元素无序(添加顺序和遍历顺序不一致);(4)线程不安全, 若2个线程同时操作HashSet, 必须通过代码实现同步; 2.2.1 HashSet元素添加Set集合不允许添加重复元素, 那么到底是个怎么情况呢?来看一个简单的例子: 12345678910111213141516171819202122232425262728293031public class HashSetTest &#123; public static void main(String[] agrs)&#123; //hashCode() 和 equals()测试： hashCodeAndEquals(); &#125; public static void hashCodeAndEquals()&#123; //第一个 Set集合： Set&lt;String&gt; set1 = new HashSet&lt;String&gt;(); String str1 = new String("jiaboyan"); String str2 = new String("jiaboyan"); set1.add(str1); set1.add(str2); System.out.println("长度："+set1.size()+",内容为："+set1); //第二个 Set集合： Set&lt;App&gt; set2 = new HashSet&lt;App&gt;(); App app1 = new App(); app1.setName("jiaboyan"); App app2 = new App(); app2.setName("jiaboyan"); set2.add(app1); set2.add(app2); System.out.println("长度："+set2.size()+",内容为："+set2); //第三个 Set集合： Set&lt;App&gt; set3 = new HashSet&lt;App&gt;(); App app3 = new App(); app3.setName("jiaboyan"); set3.add(app3); set3.add(app3); System.out.println("长度："+set3.size()+",内容为："+set3); &#125;&#125; 测试结果: 123长度：1,内容为：[jiaboyan]长度：2,内容为：[App@74a14482, App@4554617c]长度：1,内容为：[App@1540e19d] 可以看到, 第一个Set集合中最终只有一个元素; 第二个Set集合保留了2个元素; 第三个集合也只有1个元素;究竟是什么原因呢?让我们来看看HashSet的add(E e)方法: 123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 在底层HashSet调用了HashMap的put(K key, V value)方法: 123456789101112131415161718192021public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125; 简单概括如下:在向HashMap中添加元素时, 先判断key的hashCode值是否相同, 如果相同, 则调用==, equals()进行判断, 若相同则覆盖原有元素; 如果不同, 则直接向Map中添加元素;反过来, 我们在看下上面的例子:在第一个Set集合中, 我们new了两个String对象, 赋了相同的值. 当传入到HashMap中时, key均为”jiaboyan”, 所以hash和i的值都相同. 进行if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))判断, 由于String对象重写了equals()方法,所以在((k = e.key) == key || key.equals(k))判断时, 返回了true, 所以第二次的插入并不会增加Set集合的长度;第二个Set集合中, 也是new了两个对象, 但没有重写equals()方法(底层调用的Object的equals()，也就是==判断), 所以会增加2个元素;第三个Set集合中, 只new了一个对象, 调用的两次add方法都添加的这个新new的对象,所以也只是保留了1个元素; 2.3 初识TreeSet从名字上可以看出, 此集合的实现和树结构有关.与HashSet集合类似, TreeSet也是基于Map来实现, 具体实现TreeMap, 其底层结构为红黑树;与HashSet不同的是, TreeSet具有排序功能, 分为自然排序(123456)和自定义排序两类, 默认是自然排序; 在程序中, 我们可以按照任意顺序将元素插入到集合中, 等到遍历时TreeSet会按照一定顺序输出–倒序或者升序;它继承AbstractSet, 实现NavigableSet, Cloneable, Serializable接口.(1)与HashSet同理, TreeSet继承AbstractSet类,获得了Set集合基础实现操作;(2)TreeSet实现NavigableSet接口, 而NavigableSet又扩展了SortedSet接口. 这两个接口主要定义了搜索元素的能力, 例如给定某个元素,查找该集合中比给定元素大于, 小于, 等于的元素集合, 或者比给定元素大于, 小于, 等于的元素个数; 简单地说, 实现NavigableSet接口使得TreeSet具备了元素搜索功能;(3)TreeSet实现Cloneable接口, 意味着它也可以被克隆;(4)TreeSet实现了Serializable接口, 可以被序列化, 可以使用hessian协议来传输;具有如下特点:(1)对插入的元素进行排序, 是一个有序的集合(主要与HashSet的区别);(2)底层使用红黑树结构, 而不是哈希表结构;(3)允许插入Null值;(4)不允许插入重复元素;(5)线程不安全; 2.3.1 TreeSet元素排序在前面的章节, 我们讲到了TreeSet是一个有序集合,可以对集合元素排序,其中分为自然排序和自定义排序,那么这两种方式如何实现呢?首先,我们通过JDK提供的对象来展示, 我们使用String, Integer: 1234567891011121314151617181920public class TreeSetTest &#123; public static void main(String[] agrs)&#123; naturalSort(); &#125; //自然排序顺序：升序 public static void naturalSort()&#123; TreeSet&lt;String&gt; treeSetString = new TreeSet&lt;String&gt;(); treeSetString.add("a"); treeSetString.add("z"); treeSetString.add("d"); treeSetString.add("b"); System.out.println("字母顺序：" + treeSetString.toString()); TreeSet&lt;Integer&gt; treeSetInteger = new TreeSet&lt;Integer&gt;(); treeSetInteger.add(1); treeSetInteger.add(24); treeSetInteger.add(23); treeSetInteger.add(6); System.out.println("数字顺序：" + treeSetInteger.toString()); &#125;&#125; 测试结果: 12字母顺序：[a, b, d, z]数字顺序：[1, 6, 23, 24] 接下来, 我们自定义对象, 看能否实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.TreeSet;public class Main &#123; public static void main(String[] agrs)&#123; customSort(); &#125; //自定义排序顺序：升序 public static void customSort()&#123; TreeSet&lt;App&gt; treeSet = new TreeSet&lt;App&gt;(); //排序对象： App app1 = new App("hello",10); App app2 = new App("world",20); App app3 = new App("my",15); App app4 = new App("name",25); //添加到集合： treeSet.add(app1); treeSet.add(app2); treeSet.add(app3); treeSet.add(app4); System.out.println("TreeSet集合顺序为："+treeSet); &#125;&#125;class App&#123; private String name; private Integer age; public App()&#123;&#125; public App(String name,Integer age)&#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public static void main(String[] args )&#123; System.out.println( "Hello World!" ); &#125;&#125; 测试结果: 123456Exception in thread "main" java.lang.ClassCastException: App cannot be cast to java.lang.Comparable at java.util.TreeMap.compare(TreeMap.java:1294) at java.util.TreeMap.put(TreeMap.java:538) at java.util.TreeSet.add(TreeSet.java:255) at Main.customSort(Main.java:15) at Main.main(Main.java:4) 为什么会报错呢? 12345compare(key, key); // type (and possibly null) checkfinal int compare(Object k1, Object k2) &#123; return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2);&#125; 通过查看源码发现, 在TreeSet调用add方法时, 会调用到底层TreeMap的put方法, 在put方法中会调用到compare(key, key)方法, 进行key大小的比较;在比较的时候, 会将传入的key进行类型强转, 所以当我们自定义的App类进行比较的时候, 自然就会抛出异常, 因为App类并没有实现Comparable接口;将App实现Comparable接口, 再做比较: 123456789101112131415161718192021222324252627282930313233343536373839class App implements Comparable&lt;App&gt;&#123; private String name; private Integer age; public App()&#123;&#125; public App(String name,Integer age)&#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public static void main(String[] args )&#123; System.out.println( "Hello World!" ); &#125; @Override //自定义比较：先比较name的长度，在比较age的大小； public int compareTo(App app) &#123; //比较name的长度： int num = this.name.length() - app.name.length(); //如果name长度一样，则比较年龄的大小： return num == 0 ? this.age - app.age : num; &#125; @Override public String toString() &#123; return "App&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 测试结果: 1TreeSet集合顺序为：[App&#123;name=&apos;my&apos;, age=15&#125;, App&#123;name=&apos;name&apos;, age=25&#125;, App&#123;name=&apos;hello&apos;, age=10&#125;, App&#123;name=&apos;world&apos;, age=20&#125;] 此外, 还有另一种方式, 那就是实现Comparetor接口, 并重写compare方法; 12345678//自定义App类的比较器：public class AppComparator implements Comparator&lt;App&gt; &#123; //比较方法：先比较年龄，年龄若相同在比较名字长度； public int compare(App app1, App app2) &#123; int num = app1.getAge() - app2.getAge(); return num == 0 ? app1.getName().length() - app2.getName().length() : num; &#125;&#125; 此时, App不用在实现Comparerable接口了, 单纯的定义一个类即可; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.Comparator;import java.util.TreeSet;public class Main &#123; public static void main(String[] agrs)&#123; customSort(); &#125; //自定义排序顺序：升序 public static void customSort()&#123; TreeSet&lt;App&gt; treeSet = new TreeSet&lt;App&gt;(new AppComparator()); //排序对象： App app1 = new App("hello",10); App app2 = new App("world",20); App app3 = new App("my",15); App app4 = new App("name",25); //添加到集合： treeSet.add(app1); treeSet.add(app2); treeSet.add(app3); treeSet.add(app4); System.out.println("TreeSet集合顺序为："+treeSet); &#125;&#125;class App&#123; private String name; private Integer age; public App()&#123;&#125; public App(String name,Integer age)&#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public static void main(String[] args )&#123; System.out.println( "Hello World!" ); &#125; @Override public String toString() &#123; return "App&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125;//自定义App类的比较器：class AppComparator implements Comparator&lt;App&gt; &#123; //比较方法：先比较年龄，年龄若相同在比较名字长度； public int compare(App app1, App app2) &#123; int num = app1.getAge() - app2.getAge(); return num == 0 ? app1.getName().length() - app2.getName().length() : num; &#125;&#125; 测试结果: 1TreeSet集合顺序为：[App&#123;name=&apos;hello&apos;, age=10&#125;, App&#123;name=&apos;my&apos;, age=15&#125;, App&#123;name=&apos;world&apos;, age=20&#125;, App&#123;name=&apos;name&apos;, age=25&#125;] 最后, 再说下关于compareTo(), compare()方法: 123结果返回大于0时，方法前面的值大于方法中的值；结果返回等于0时，方法前面的值等于方法中的值；结果返回小于0时，方法前面的值小于方法中的值； 2.4 HashSet源码分析(基于JDK1.7.0_75)HashSet基于HashMap, 底层方法是通过调用HashMap的API来实现, 因此HashSet源码结构比较简单, 代码较少. 2.4.1 成员变量在HashSet中, 有两个成员变量比较重要–map, PRESENT;其中,map就是存储元素的地方, 实际是一个HashMap. 当有元素插入到HashSet中时, 会被当做HashMap的key保存到map属性中去.对于HashMap来说,光有key还不够, 在HashSet的实现中, 每个key对应的value都默认为PRESENT属性, 也就是new了一个Object对象而已; 123456789public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123; static final long serialVersionUID = -5024744406713321676L; //HashSet通过HashMap保存集合元素的： private transient HashMap&lt;E,Object&gt; map; //HashSet底层由HashMap实现，新增的元素为map的key，而value则默认为PRESENT。 private static final Object PRESENT = new Object();&#125; 2.4.2 构造方法HashSet的构造方法很简单, 主要是在方法内部初始化map属性, new了一个HashMap对象; 123456789101112131415161718192021222324252627public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; //无参构造方法： public HashSet() &#123; //默认new一个HashMap map = new HashMap&lt;&gt;(); &#125; // 带集合的构造函数 public HashSet(Collection&lt;? extends E&gt; c) &#123; // 进行初始化HashMap容量判断， map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); &#125; // 指定HashSet初始容量和加载因子的构造函数：主要用于Map内部的扩容机制 public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor); &#125; // 指定HashSet初始容量的构造函数 public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity); &#125; //与前4个不同，此构造最终new了一个LinkedHashMap对象： HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125;&#125; 2.4.3 add()HashSet的add(E e)方法, 主要是调用底层HashMap的put(K key, V value)方法.其中key就是HashSet集合插入的元素, 而value则是默认的PRESENT属性(一个new Object()); 1234//调用HashMap中的put()方法:public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 2.4.4 remove()与add(E e)方法类似, HashSet的remove(Object o)也是调用了底层HashMap的(Object key)方法;主要是计算出要删除元素的hash值, 在HashMap找到对应的对象, 然后从Entry[]数组中删除; 1234//调用HashMap中的remove方法：public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125; 2.5 TreeSet源码分析(基于JDK1.7.0_75)与HashSet类似, TreeSet底层也是采用了一个Map来保存集合元素, 这个Map就是NavigableMap.不过, NavigableMap仅仅是一个接口, 具体的实现还是使用了TreeMap类; 2.5.1 成员变量成员变量m是一个NavigableMap类型的Map集合, 常用实现是TreeMap对象;在TreeMap中, key是我们TreeSet插入的元素, 而value则是TreeSet中另一个成员变量PRESENT, 一个普通的不能再普通的Object对象; 1234567public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable &#123; //TreeSet中保存元素的map对象： private transient NavigableMap&lt;E,Object&gt; m; //map对象中保存的value: private static final Object PRESENT = new Object();&#125; 2.5.2 构造方法12345678910111213141516171819202122232425public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable &#123; //最底层的构造方法，不对外。传入一个NavigableMap接口的实现类 TreeSet(NavigableMap&lt;E,Object&gt; m) &#123; this.m = m; &#125; //无参构造：向底层构造传入一个TreeMap对象： public TreeSet() &#123; this(new TreeMap&lt;E,Object&gt;()); &#125; //传入比较器的构造：通常传入一个自定义Comparator的实现类； public TreeSet(Comparator&lt;? super E&gt; comparator) &#123; this(new TreeMap&lt;&gt;(comparator)); &#125; //将集合Collection传入TreeSet中： public TreeSet(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; //将集合SortedSet传入TreeSet中： public TreeSet(SortedSet&lt;E&gt; s) &#123; this(s.comparator()); addAll(s); &#125;&#125; 2.5.3 add()向TreeSet中添加元素 123public boolean add(E e) &#123; return m.put(e, PRESENT)==null;&#125; 2.5.4 remove()删除TreeSet中元素o 123public boolean remove(Object o) &#123; return m.remove(o)==PRESENT;&#125; 2.6 SortedSet和NavigableSet到底是什么在一些关于TreeSet讲解的文章中, 在介绍TreeSet的时候都会提到NavigableSet, 接着会说下NavigableSet是个”导航Set集合”, 提供了一系列”导航”方法. 那么, 什么是”导航”方法?通过接口的定义, 我们可以看到NavigableSet继承了SortedSet接口(后面说), 实现了对其的扩展;而通过下面的方法, 我们得出NavigableSet实际提供了一系列的搜索匹配元素的功能, 能获取到某一区间内的集合元素; 123456789101112131415161718192021public interface NavigableSet&lt;E&gt; extends SortedSet&lt;E&gt; &#123; E lower(E e);//返回此set集合中小于e元素的最大元素 E floor(E e);//返回此set集合中小于等于e元素的最大元素 E ceiling(E e);//返回此set集合中大于等于e元素的最小元素 E higher(E e);//返回此set集合中大于e元素的最小元素 E pollFirst(); //获取并移除此set集合中的第一个元素 E pollLast();//获取并移除此set集合中的最后一个元素 Iterator&lt;E&gt; iterator();//返回此set集合的迭代器--升序 NavigableSet&lt;E&gt; descendingSet();//以倒序的顺序返回此set集合 Iterator&lt;E&gt; descendingIterator();//返回此set集合的迭代器--倒序 //返回此set集合的部分元素--从fromElement开始到toElement结束，其中fromInclusive、toInclusive意为返回的集合是否包含头尾元素 NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive); //返回此set集合的部分元素--小于toElement，inclusive意味返回的集合是否包含toElement NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive); //返回此set集合的部分元素--从fromElement开始到toElement结束，包含头不含为尾 SortedSet&lt;E&gt; subSet(E fromElement, E toElement); //返回此set集合的部分元素--小于toElement SortedSet&lt;E&gt; headSet(E toElement); //返回此set集合的部分元素--大于等于toElement SortedSet&lt;E&gt; tailSet(E fromElement);&#125; 说完了NavigableSet, 我们在一起儿看下其父类SortedSet接口:通过名字, 我们可以得出此接口跟排序有关, 会提供跟排序的方法; 1234567891011121314public interface SortedSet&lt;E&gt; extends Set&lt;E&gt; &#123; //返回与排序有关的比较器 Comparator&lt;? super E&gt; comparator(); //返回从fromElement到toElement的元素集合： SortedSet&lt;E&gt; subSet(E fromElement, E toElement); //返回从第一个元素到toElement元素的集合： SortedSet&lt;E&gt; headSet(E toElement); //返回从fromElement开始到最后元素的集合： SortedSet&lt;E&gt; tailSet(E fromElement); //返回集合中的第一个元素： E first(); //返回集合中的最后一个元素： E last();&#125; 3. 参考链接Java集合：Set源码详细分析(一)Java集合：Set源码详细分析(二)]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合(一)----List]]></title>
    <url>%2F2018%2F09%2F22%2FJava%E9%9B%86%E5%90%88(%E4%B8%80)----List%2F</url>
    <content type="text"><![CDATA[1. 前言集合是Java基础中非常重要的一部分, 也是日常中用到非常多的类, 这篇博客主要记录集合List相关的知识. 特别声明: 大部分内容并非原创, 引用自参考链接. 2. Java集合相比于数组(Array)来说, 集合类的长度可变, 更加适合于现代开发需求;在程序运行时, Java集合可以动态的进行扩展, 随着元素的增加而扩大.在Java中, 集合类通常存在于java.util包中.Java集合主要由2大体系构成, 分别是Collection体系和Map体系, 其中Collection和Map分别是2大体系中的顶层接口.Collection主要有三个子接口, 分别为List(列表), Set(集), Queue(队列). 其中, List, Queue中的元素有序可重复, 而Set中的元素无序不可重复;List中主要有ArrayList, LinkedList两个实现类; Set中则是有HashSet实现类; 而Queue是在JDK1.5后才出现的新集合, 主要以数组和链表两种形式存在.Map同属于java.util包中, 是集合的一部分,但与Collection是相互独立的, 没有任何关系. Map中都是以key-value的形式存在, 其中key必须唯一, 主要有HashMap, Hashtable, TreeMap三个实现类. 3. List在Collection中, List集合是有序的, Developer可对其中每个元素的插入位置进行精确地控制, 可以通过索引来访问元素, 遍历元素.在List集合中, 我们常用到ArrayList和LinkedList这两个类. 3.1 初识ArrayList其中, ArrayList底层通过数组实现, 随着元素的增加而动态扩容. 而LinkedList底层通过链表来实现, 随着元素的增加不断向链表的后端增加节点.ArrayList是Java集合框架中使用最多的一个类, 是一个数组队列, 线程不安全集合.它继承于AbstractList, 实现了List, RandomAccess, Cloneable, Serializable接口.(1)ArrayList实现List, 得到了List集合框架基础功能;(2)ArrayList实现RandomAccess, 获得了快速随机访问存储元素的功能, RandomAccess是一个标记接口, 没有任何方法;(3)ArrayList实现Cloneable, 得到了clone()方法, 可以实现克隆功能;(4)ArrayList实现Serializable, 表示可以被序列化, 通过序列化去传输, 典型的应用就是hessian协议. 它具有如下特点:(1)容量不固定, 随着容量的增加而动态扩容(阈值基本不会达到)(2)有序集合(插入的顺序=输出的顺序)(3)插入的元素可以为null(4)增删改查效率更高(相对于LinkedList来说)(5)线程不安全. 数据结构: 3.2 初识LinkedListLinkedList是一个双向链表, 每一个节点都拥有指向前后节点的引用. 相比于ArrayList来说, LinkedList的随机访问效率更低.它继承AbstractSequentialList, 实现了List, Deque, Cloneable, Serializable接口.(1)LinkedList实现List, 得到了List集合框架基础功能;(2)LinkedList实现Deque, Deque 是一个双向队列, 也就是既可以先入先出, 又可以先入后出,说 简单些就是既可以在头部添加元素, 也可以在尾部添加元素;(3)LinkedList实现Cloneable, 得到了clone()方法, 可以实现克隆功能;(4)LinkedList实现Serializable, 表示可以被序列化, 通过序列化去传输, 典型的应用就是hessian协议.数据结构: 3.3 List常用方法12345678910111213141516171819202122232425262728A:添加功能boolean add(E e):向集合中添加一个元素void add(int index, E element):在指定位置添加元素boolean addAll(Collection&lt;? extends E&gt; c)：向集合中添加一个集合的元素。B:删除功能void clear()：删除集合中的所有元素E remove(int index)：根据指定索引删除元素，并把删除的元素返回boolean remove(Object o)：从集合中删除指定的元素boolean removeAll(Collection&lt;?&gt; c):从集合中删除一个指定的集合元素。C:修改功能E set(int index, E element):把指定索引位置的元素修改为指定的值，返回修改前的值。D:获取功能E get(int index)：获取指定位置的元素Iterator iterator():就是用来获取集合中每一个元素。E:判断功能boolean isEmpty()：判断集合是否为空。boolean contains(Object o)：判断集合中是否存在指定的元素。boolean containsAll(Collection&lt;?&gt; c)：判断集合中是否存在指定的一个集合中的元素。F:长度功能int size():获取集合中的元素个数。G:把集合转换成数组Object[] toArray():把集合变成数组。 3.4 ArrayList和LinkedList性能比较3.4.1 元素新增从直观上看, 在新增操作时, ArrayList效率不如LinkedList, 因为ArrayList底层是数组实现, 在动态扩容时, 性能有所损耗, 而LinkedList不存在数组扩容机制, 所以LinkedList效率更高. 1234567891011121314151617181920212223242526public class ListTest &#123; //迭代次数 public static int ITERATION_NUM = 100000; public static void main(String[] agrs) &#123; insertPerformanceCompare(); &#125; //新增性能比较： public static void insertPerformanceCompare() &#123; System.out.println("LinkedList新增测试开始"); long start = System.nanoTime(); List&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;(); for (int x = 0; x &lt; ITERATION_NUM; x++) &#123; linkedList.add(x); &#125; long end = System.nanoTime(); System.out.println(end - start); System.out.println("ArrayList新增测试开始"); start = System.nanoTime(); List&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); for (int x = 0; x &lt; ITERATION_NUM; x++) &#123; arrayList.add(x); &#125; end = System.nanoTime(); System.out.println(end - start); &#125;&#125; 结果: 1234567891011121314151617第一组:LinkedList新增测试开始7609993ArrayList新增测试开始6071437第二组:LinkedList新增测试开始12317919ArrayList新增测试开始5754172第三组:LinkedList新增测试开始8291202ArrayList新增测试开始5320576 结果与预想的有些不太一样, ArrayList的新增性能并不低.究其原因, 可能是经过JDK近几年的更新发展, 对于数组复制的实现进行了优化, 以至于ArrayList的性能也得到了提高. 也可能是由于, LinkedList每次add操作都需要创建一个node对象, 这会产生额外开销, 而ArrayList只有在扩容的时候才需要数组的复制, 不扩容的时候, 没有额外开销. 3.4.2 元素获取由于LinkedList是链表结构, 没有角标的概念, 没有实现RandomAccess接口, 不具备随机元素访问功能, 所以在get方面表现的差强人意, ArrayList再一次完胜. 1234567891011121314151617181920212223242526272829303132333435363738public class ListTest &#123; //迭代次数，集合大小： public static int ITERATION_NUM = 100000; public static void main(String[] agrs) &#123; getPerformanceCompare(); &#125; //获取性能比较： public static void getPerformanceCompare() &#123; //填充ArrayList集合： List&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); for (int x = 0; x &lt; ITERATION_NUM; x++) &#123; arrayList.add(x); &#125; //填充LinkedList集合： List&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;(); for (int x = 0; x &lt; ITERATION_NUM; x++) &#123; linkedList.add(x); &#125; //创建随机数对象： Random random = new Random(); System.out.println("LinkedList获取测试开始"); long start = System.nanoTime(); for (int x = 0; x &lt; ITERATION_NUM; x++) &#123; int j = random.nextInt(x + 1); int k = linkedList.get(j); &#125; long end = System.nanoTime(); System.out.println(end - start); System.out.println("ArrayList获取测试开始"); start = System.nanoTime(); for (int x = 0; x &lt; ITERATION_NUM; x++) &#123; int j = random.nextInt(x + 1); int k = arrayList.get(j); &#125; end = System.nanoTime(); System.out.println(end - start); &#125;&#125; 结果: 1234567891011121314151617第一组:LinkedList获取测试开始6193992452ArrayList获取测试开始9773597第二组:LinkedList获取测试开始6920119875ArrayList获取测试开始4026352第三组:LinkedList获取测试开始5559676521ArrayList获取测试开始10468298 从结果中可以看到, ArrayList在随机访问方面表现的十分优秀, 比LinkedList强了很多, 基本上保持在500-1000倍.LinkedList为什么这么慢呢?这主要是LinkedList的代码实现所致, 每一次获取都是从头开始遍历, 一个个节点去查找, 每查找一次就遍历一次, 所以性能自然得不到提升. 3.5 ArrayList源码分析(基于JDK1.7.0_45)接下来, 我们几对ArrayList的源码进行一个解析, 主要从以下几个问题出发.(1)ArrayList构造(2)增删改查实现(3)迭代器-modCount(4)为什么数组对象要使用transient修饰符(5)System.arraycopy()参数含义 和 Arrays.copyOf()参数含义我们通过这这几个问题, 来一步步的学习ArrayList. 3.5.1 ArrayList构造器在JDK1.7版本中, ArrayList的无参构造方法并没有生成容量为10的数组;elementData对象是ArrayList集合底层保存元素的实现;size属性记录了ArrayList集合中实际元素的个数; 123456789101112131415161718192021222324252627282930313233343536373839public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; //实现Serializable接口，生成的序列版本号： private static final long serialVersionUID = 8683452581122892189L; //ArrayList初始容量大小：在无参构造中不使用了 private static final int DEFAULT_CAPACITY = 10; //空数组对象：初始化中默认赋值给elementData private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //ArrayList中实际存储元素的数组： private transient Object[] elementData; //集合实际存储元素长度： private int size; //ArrayList有参构造：容量大小 public ArrayList(int initialCapacity) &#123; //即父类构造：protected AbstractList() &#123;&#125;空方法 super(); //如果传递的初始容量小于0 ，抛出异常 if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); //初始化数据：创建Object数组 this.elementData = new Object[initialCapacity]; &#125; //ArrayList无参构造： public ArrayList() &#123; //即父类构造：protected AbstractList() &#123;&#125;空方法 super(); //初始化数组：空数组，容量为0 this.elementData = EMPTY_ELEMENTDATA; &#125; //ArrayList有参构造：Java集合 public ArrayList(Collection&lt;? extends E&gt; c) &#123; //将集合转换为数组： elementData = c.toArray(); //设置数组的长度： size = elementData.length; if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125;&#125; 3.5.2 add()ArrayList增加元素的方法事关重要, 我们都知道ArrayList底层是由数组, 可以随着元素的增加而扩容, 那么具体是如何实现的呢?在JDK1.7当中, 当第一个元素添加时, ensureCapacityInternal()方法会计算ArrayList的扩容大小, 默认为10;其中grow()方法最为重要, 如果需要扩容, 那么扩容后的大小是原来的1.5倍, 实际上最终调用了Arrays.copyOf()方法得以实现; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//添加元素epublic boolean add(E e) &#123; ensureCapacityInternal(size + 1); //将对应角标下的元素赋值为e： elementData[size++] = e; return true;&#125;//得到最小扩容量private void ensureCapacityInternal(int minCapacity) &#123; //如果此时ArrayList是空数组,则将最小扩容大小设置为10： if (elementData == EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //判断是否需要扩容： ensureExplicitCapacity(minCapacity);&#125;//判断是否需要扩容private void ensureExplicitCapacity(int minCapacity) &#123; //操作数+1 modCount++; //判断最小扩容容量-数组大小是否大于0： if (minCapacity - elementData.length &gt; 0) //扩容： grow(minCapacity);&#125;//ArrayList动态扩容的核心方法:private void grow(int minCapacity) &#123; //获取现有数组大小： int oldCapacity = elementData.length; //位运算，得到新的数组容量大小，为原有的1.5倍： int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //如果新扩容的大小依旧小于传入的容量值，那么将传入的值设为新容器大小： if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //如果新容器大小，大于ArrayList最大长度： if (newCapacity - MAX_ARRAY_SIZE &gt; 0) //计算出最大容量值： newCapacity = hugeCapacity(minCapacity); //数组复制： elementData = Arrays.copyOf(elementData, newCapacity);&#125;//计算ArrayList最大容量：private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) throw new OutOfMemoryError(); //如果新的容量大于MAX_ARRAY_SIZE。将会调用hugeCapacity将int的最大值赋给newCapacity: return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 3.5.3 remove()remove(int index)是针对于角标来进行删除, 不需要去遍历整个集合, 效率更高;而remove(Object o)是针对于对象来进行删除, 需要遍历整个集合进行equals()方法比对, 所以效率较低;不过, 无论是哪种形式的删除, 最终都会调用System.arraycopy()方法进行数组复制操作, 所以效率都会受到影响; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//在ArrayList的移除index位置的元素public E remove(int index) &#123; //检查角标是否合法：不合法抛异常 rangeCheck(index); //操作数+1： modCount++; //获取当前角标的value: E oldValue = elementData(index); //获取需要删除元素 到最后一个元素的长度，也就是删除元素后，后续元素移动的个数； int numMoved = size - index - 1; //如果移动元素个数大于0 ，也就是说删除的不是最后一个元素： if (numMoved &gt; 0) // 将elementData数组index+1位置开始拷贝到elementData从index开始的空间 System.arraycopy(elementData, index+1, elementData, index, numMoved); //size减1，并将最后一个元素置为null elementData[--size] = null; //返回被删除的元素： return oldValue;&#125;//在ArrayList的移除对象为O的元素，不返回被删除的元素：public boolean remove(Object o) &#123; //如果o==null，则遍历集合，判断哪个元素为null： if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; //快速删除，和前面的remove（index）一样的逻辑 fastRemove(index); return true; &#125; &#125; else &#123; //同理： for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;//快速删除：private void fastRemove(int index) &#123; //操作数+1 modCount++; //获取需要删除元素 到最后一个元素的长度，也就是删除元素后，后续元素移动的个数； int numMoved = size - index - 1; //如果移动元素个数大于0 ，也就是说删除的不是最后一个元素： if (numMoved &gt; 0) // 将elementData数组index+1位置开始拷贝到elementData从index开始的空间 System.arraycopy(elementData, index+1, elementData, index, numMoved); //size减1，并将最后一个元素置为null elementData[--size] = null;&#125; 3.5.4 set()由于ArrayList实现了RandomAccess, 所以具备了随机访问特性, 调用elementData()可以获取到对应元素的值； 1234567891011//设置index位置的元素值了element，返回该位置的之前的值public E set(int index, E element) &#123; //检查index是否合法：判断index是否大于size rangeCheck(index); //获取该index原来的元素： E oldValue = elementData(index); //替换成新的元素： elementData[index] = element; //返回旧的元素： return oldValue;&#125; 3.5.5 get()通过elementData()方法获取对应角标元素, 在返回时候进行类型转换; 1234567891011//获取index位置的元素public E get(int index) &#123; //检查index是否合法： rangeCheck(index); //获取元素： return elementData(index);&#125;//获取数组index位置的元素：返回时类型转换E elementData(int index) &#123; return (E) elementData[index];&#125; 3.5.6 modCount含义在Itr迭代器初始化时,将ArrayList的modCount属性的值赋值给了expectedModCount.通过上面的例子中, 我们可以知道当进行增删改时, modCount会随着每一次的操作而+1, modCount记录了ArrayList内发生改变的次数.当迭代器在迭代时, 会判断expectedModCount的值是否还与modCount的值保持一致, 如果不一致则抛出异常.AbstractList类当中定义的变量: 1protected transient int modCount = 0; ArrayList获取迭代器对象: 1234//返回一个Iterator对象，Itr为ArrayList的一个内部类，其实现了Iterator&lt;E&gt;接口public Iterator&lt;E&gt; iterator() &#123; return new java.util.ArrayList.Itr();&#125; 迭代器实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//Itr实现了Iterator接口，是ArrayList集合的迭代器对象private class Itr implements Iterator&lt;E&gt; &#123; //类似游标，指向迭代器下一个值的位置 int cursor; //迭代器最后一次取出的元素的位置。 int lastRet = -1; //Itr初始化时候ArrayList的modCount的值。 int expectedModCount = modCount; //利用游标，与size之前的比较，判断迭代器是否还有下一个元素 public boolean hasNext() &#123; return cursor != size; &#125; //迭代器获取下一个元素： public E next() &#123; //检查modCount是否改变： checkForComodification(); int i = cursor; //游标不会大于等于集合的长度： if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = java.util.ArrayList.this.elementData; //游标不会大于集合中数组的长度： if (i &gt;= elementData.length) throw new ConcurrentModificationException(); //游标+1 cursor = i + 1; //取出元素： return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); //检查modCount是否改变：防止并发操作集合 checkForComodification(); try &#123; //删除这个元素： java.util.ArrayList.this.remove(lastRet); //删除后，重置游标，和当前指向元素的角标 lastRet cursor = lastRet; lastRet = -1; //重置expectedModCount： expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; //并发检查： final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 3.5.7 transienttransient修饰符是什么含义?当我们序列化对象时, 如果对象中某个属性不进行序列化操作, 那么在该属性前添加transient修饰符即可实现; 例如: 1private transient Object[] elementData; 那么, 为什么ArrayList不想对elementData属性进行序列化呢? elementData可是集合中保存元素的数组啊, 如果不序列化elementData属性, 那么在反序列化时候, 岂不是丢失了原先的元素?ArrayList在添加元素时, 可能会对elementData数组进行扩容操作, 而扩容后的数组可能并没有全部保存元素.例如: 我们创建了new Object[10]数组对象, 但是我们只向其中添加了1个元素, 而剩余的9个位置并没有添加元素. 当我们进行序列化时, 并不会只序列化其中一个元素, 而是将整个数组进行序列化操作, 那些没有被元素填充的位置也进行了序列化操作, 间接的浪费了磁盘的空间, 以及程序的性能.所以, ArrayList才会在elementData属性前加上transient修饰符.接下来, 我们来看下ArrayList的writeObject(), readObject(): 12345678910111213141516171819202122232425//序列化写入：private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; int expectedModCount = modCount; s.defaultWriteObject(); s.writeInt(size); for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;// 序列化读取：private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; s.defaultReadObject(); s.readInt(); if (size &gt; 0) &#123; ensureCapacityInternal(size); Object[] a = elementData; for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; ArrayList在序列化时会调用writeObject(), 直接将elementData写入ObjectOutputStream;而反序列化时则调用readObject(), 从ObjectInputStream获取elementData; 3.5.8 Arrays.copyOf()该方法在内部创建了一个新数组, 底层实现是调用System.arraycopy(); 12345678public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; original - 要复制的数组newLength - 要返回的副本的长度newType - 要返回的副本的类型 3.5.9 System.arraycopy()该方法是用了native关键字, 调用的为C++编写的底层函数. 123public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); src - 源数组srcPos - 源数组中的起始位置dest - 目标数组destPos - 目标数据中的起始位置length - 要复制的数组元素的数量 3.6 LinkedList源码分析(基于JDK1.7.0_45)发现很多文章在介绍的时候, 都说LinkedList是一个环形链表结构, 头尾相连. 但, 当我开始看源码的时候, 发现并不是环形链表, 是一个直线型链表结构. 这是因为JDK1.7之前的版本是环形链表, 而到了JDK1.7以后进行了优化, 变成了直线型链表结构; 3.6.1 LinkedList基础结构在LinkedList中, 内部类Node对象最为重要, 它组成了LinkedList集合的整个链表, 分别指向上一个点, 下一个结点, 存储着集合中的元素;成员变量中, first表明是头结点, last表明是尾结点; 1234567891011121314151617181920212223242526272829303132public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123; //LinkedList的元素个数： transient int size = 0; //LinkedList的头结点：Node内部类 transient java.util.LinkedList.Node&lt;E&gt; first; //LinkedList尾结点：Node内部类 transient java.util.LinkedList.Node&lt;E&gt; last; //空实现：头尾结点均为null，链表不存在 public LinkedList() &#123; &#125; //调用添加方法： public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; //节点的数据结构，包含前后节点的引用和当前节点 private static class Node&lt;E&gt; &#123; //结点元素： E item; //结点后指针 java.util.LinkedList.Node&lt;E&gt; next; //结点前指针 java.util.LinkedList.Node&lt;E&gt; prev; Node(java.util.LinkedList.Node&lt;E&gt; prev, E element, java.util.LinkedList.Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125;&#125; 3.6.2 add()LinkedList的添加方法, 主要分为2种, 一是直接添加一个元素, 二是在指定角标下添加一个元素;add(E e)底层调用linkLast(E e)方法, 就是在链表的最后面插入一个元素;add(int index, E element), 插入的角标如果==size, 则插入到链表最后; 否则, 按照角标大小插入到对应位置; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//添加元素：添加到最后一个结点；public boolean add(E e) &#123; linkLast(e); return true;&#125;//last节点插入新元素：void linkLast(E e) &#123; //将尾结点赋值个体L: final java.util.LinkedList.Node&lt;E&gt; l = last; //创建新的结点，将新节点的前指针指向l: final java.util.LinkedList.Node&lt;E&gt; newNode = new java.util.LinkedList.Node&lt;&gt;(l, e, null); //新节点置为尾结点： last = newNode; //如果尾结点l为null：则是空集合新插入 if (l == null) //头结点也置为 新节点： first = newNode; else //l节点的后指针指向新节点： l.next = newNode; //长度+1 size++; //操作数+1 modCount++;&#125;//向对应角标添加元素：public void add(int index, E element) &#123; //检查传入的角标 是否正确： checkPositionIndex(index); //如果插入角标==集合长度，则插入到集合的最后面： if (index == size) linkLast(element); else //插入到对应角标的位置：获取此角标下的元素先 linkBefore(element, node(index));&#125;//在succ前插入 新元素e：void linkBefore(E e, java.util.LinkedList.Node&lt;E&gt; succ) &#123; //获取被插入元素succ的前指针元素： final java.util.LinkedList.Node&lt;E&gt; pred = succ.prev; //创建新增元素节点，前指针 和 后指针分别指向对应元素： final java.util.LinkedList.Node&lt;E&gt; newNode = new java.util.LinkedList.Node&lt;&gt;(pred, e, succ); succ.prev = newNode; //succ的前指针元素可能为null，为null的话说明succ是头结点，则把新建立的结点置为头结点： if (pred == null) first = newNode; else //succ前指针不为null，则将前指针的结点的后指针指向新节点： pred.next = newNode; //长度+1 size++; //操作数+1 modCount++;&#125; 对于LinkedList集合增加元素来说, 可以简单的概括为以下几点:将添加的元素转换为LinkedList的Node对象节点;增加该Node节点的前后引用, 即该Node节点的prev, next属性, 让其分别指向哪一个节点);修改该Node节点的前后Node节点中pre/next属性, 使其指向该节点. 3.6.3 remove()LinkedList的删除也提供了2种形式, 其一是通过角标删除元素, 其二就是通过对象删除元素; 不过, 无论哪种删除, 最终调用的都是unlink来实现的; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//删除对应角标的元素：public E remove(int index) &#123; checkElementIndex(index); //node()方法通过角标获取对应的元素，在后面介绍 return unlink(node(index));&#125;//删除LinkedList中的元素，可以删除为null的元素，逐个遍历LinkedList的元素，重复元素只删除第一个：public boolean remove(Object o) &#123; //如果删除元素为null： if (o == null) &#123; for (java.util.LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; //如果删除元素不为null： for (java.util.LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125;//移除LinkedList结点：remove()方法中调用E unlink(java.util.LinkedList.Node&lt;E&gt; x) &#123; //获取被删除结点的元素E： final E element = x.item; //获取被删除元素的后指针结点： final java.util.LinkedList.Node&lt;E&gt; next = x.next; //获取被删除元素的前指针结点： final java.util.LinkedList.Node&lt;E&gt; prev = x.prev; //被删除结点的 前结点为null的话： if (prev == null) &#123; //将后指针指向的结点置为头结点 first = next; &#125; else &#123; //前置结点的 尾结点指向被删除的next结点； prev.next = next; //被删除结点前指针置为null: x.prev = null; &#125; //对尾结点同样处理： if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 3.6.4 set()LinkedList的set(int index, E element)方法与add(int index,E element)的设计思路基本一致, 都是创建新Node节点, 插入到对应的角标下, 修改前后节点的prev, next属性;其中, node(int index)方法至关重要, 通过对应角标获取到对应的集合元素.可以看到, node()中是根据角标的大小是选择从前遍历还是从后遍历整个集合. 也可以间接的说明, LinkedList在随机获取元素时性能很低, 每次的获取都得从头或者从尾遍历半个集合. 123456789101112131415161718192021222324252627//设置对应角标的元素：public E set(int index, E element) &#123; checkElementIndex(index); //通过node()方法，获取到对应角标的元素： java.util.LinkedList.Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125;//获取对应角标所属于的结点：java.util.LinkedList.Node&lt;E&gt; node(int index) &#123; //位运算：如果位置索引小于列表长度的一半，则从头开始遍历；否则，从后开始遍历； if (index &lt; (size &gt;&gt; 1)) &#123; java.util.LinkedList.Node&lt;E&gt; x = first; //从头结点开始遍历：遍历的长度就是index的长度，获取对应的index的元素 for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; //从集合尾结点遍历： java.util.LinkedList.Node&lt;E&gt; x = last; //同样道理： for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 3.6.5 get()1get(int index) 终于到了最后一个方法, 也是开发中最常用的方法. 其中, 核心方法node(int index)在上面已经介绍过.在通过node(int index)获取到对应节点后, 返回节点中的item属性, 该属性就是我们所保存的元素. 1234567//获取相应角标的元素：public E get(int index) &#123; //检查角标是否正确： checkElementIndex(index); //获取角标所属结点的 元素值： return node(index).item;&#125; 4. 参考链接Java集合：ListJava集合：List源码详细分析]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础储备</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人收藏]]></title>
    <url>%2F2018%2F09%2F22%2F%E4%B8%AA%E4%BA%BA%E6%94%B6%E8%97%8F%2F</url>
    <content type="text"><![CDATA[一、日常使用二、在线工具 markdown表格在线生成工具http://www.tablesgenerator.com/markdown_tables 16进制转文本字符串http://www.bejson.com/convert/ox2str/ 密码生成器https://suijimimashengcheng.51240.com/ 三、客户端工具 Sublime Text(可以以十六进制的形式显示文本文件)https://www.sublimetext.com/]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>收藏夹</tag>
      </tags>
  </entry>
</search>
